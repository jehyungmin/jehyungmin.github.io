! function(t) {
    function e(n) {
        if (i[n]) return i[n].exports;
        var r = i[n] = {
            exports: {},
            id: n,
            loaded: !1
        };
        return t[n].call(r.exports, r, r.exports, e), r.loaded = !0, r.exports
    }
    var i = {};
    e.m = t, e.c = i, e.p = "", e(0)
}([function(t, e, i) {
    "use strict";
    var n = i(1),
        r = i(14);
    if (document.documentElement.classList.contains("csstransitions")) new n, new r({
        selector: ".nav-trigger"
    });
    else window.location.href = "browser-update.html"
}, function(t, e, i) {
    "use strict";

    function n(t, e) {
        if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
    }
    var r = function() {
            function t(t, e) {
                for (var i = 0; i < e.length; i++) {
                    var n = e[i];
                    n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(t, n.key, n)
                }
            }
            return function(e, i, n) {
                return i && t(e.prototype, i), n && t(e, n), e
            }
        }(),
        o = i(2),
        a = i(12),
        s = i(8),
        l = function() {
            function t() {
                var e = this;
                n(this, t), this.artwork = new o(this), this.preloader = new a, this.preloader.addOnComplete(function() {
                    e.artwork.loadScene(e.preloader.queue.getResult("model"))
                }), this.preloader.addOnTransitionOut(function() {
                    e.artwork.transitionIn()
                }), this.preload()
            }
            return r(t, [{
                key: "preload",
                value: function(t) {
                    var e = this.preloader;
                    s("img").each(function(t) {
                        e.queue.loadFile({
                            id: "image-" + t,
                            src: s(this).attr("src")
                        })
                    }), s(".brl").each(function(t) {
                        e.queue.loadFile({
                            id: "background-" + t,
                            src: s(this).css("background-image").replace("url(", "").replace(")", "").replace(/\"/gi, "")
                        })
                    }), e.queue.loadFile({
                        id: "model",
                        src: "js/model.json"
                    })
                }
            }]), t
        }();
    t.exports = l
}, function(t, e, i) {
    "use strict";

    function n(t, e) {
        if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
    }
    var r = function() {
            function t(t, e) {
                for (var i = 0; i < e.length; i++) {
                    var n = e[i];
                    n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(t, n.key, n)
                }
            }
            return function(e, i, n) {
                return i && t(e.prototype, i), n && t(e, n), e
            }
        }(),
        o = i(3),
        a = (i(4), i(6), i(7)),
        s = i(8);
    i(9);
    i(10), i(11);
    var l = function() {
        function t(e) {
            n(this, t), this.artwork = e, this.status = "init", this.direction = "null", this.webgl = s("html").hasClass("webgl")
        }
        return r(t, [{
            key: "setupScene",
            value: function() {
                var t = this;
                this.scene.appendTo(document.getElementById("artwork-canvas")), this.mouse = {}, this.mouse.vector = new o.Vector2, this.mouse.position = {
                    x: 0,
                    y: 0
                }, this.touch = {}, this.touch.down = {}, this.touch.up = {}, this.touch.delta = {}, window.addEventListener("resize", function() {
                    t.scene.setSize(window.innerWidth, window.innerHeight)
                }), this.scene.events.update.push(function(e) {
                    e.objects.cam.lookAt(e.objects.target.position), e.objects.particle.rotation.y -= .002, e.objects.stone1.rotation.y -= .001, e.objects.stone2.rotation.y -= .001, e.objects.stone3.rotation.y -= .001, e.objects.stone4.rotation.y -= .001, e.objects.stone1.position.x += .1 * (t.mouse.position.x / 40 - e.objects.stone1.position.x), e.objects.stone2.position.x += .1 * (t.mouse.position.x / 40 - e.objects.stone2.position.x), e.objects.stone3.position.x += .1 * (t.mouse.position.x / 40 - e.objects.stone3.position.x), e.objects.stone4.position.x += .1 * (t.mouse.position.x / 40 - e.objects.stone4.position.x), e.objects.stone1.position.y += .1 * (t.mouse.position.y / 20 - e.objects.stone1.position.y), e.objects.stone2.position.y += .1 * (t.mouse.position.y / 20 - e.objects.stone2.position.y), e.objects.stone3.position.y += .1 * (t.mouse.position.y / 20 - e.objects.stone3.position.y), e.objects.stone4.position.y += .1 * (t.mouse.position.y / 20 - e.objects.stone4.position.y), e.objects.particle.position.x += .04 * (t.mouse.position.x / 40 - e.objects.particle.position.x), e.objects.particle.position.y += .04 * (t.mouse.position.y / 40 - e.objects.particle.position.y - 25), e.objects.main.rotation.x += .04 * (t.mouse.position.y / 5e3 - e.objects.main.rotation.x), e.objects.main.rotation.y += .04 * (t.mouse.position.x / 1e3 - e.objects.main.rotation.y)
                }), this.events = {}, this.events.mousedown = function(t) {
                    t.preventDefault()
                }, this.events.mouseup = function(t) {
                    t.preventDefault()
                }, this.events.mousemove = function(e) {
                    t.mouse.position.x = e.clientX - t.scene.width / 2, t.mouse.position.y = e.clientY - t.scene.height / 2, t.mouse.vector.x = e.clientX / t.scene.width * 2 - 1, t.mouse.vector.y = -e.clientY / t.scene.height * 2 + 1
                }, this.events.mouseout = function(t) {}, this.events.mousewheel = function(t) {}, Object.keys(this.events).forEach(function(e) {
                    return document.addEventListener(e, t.events[e])
                })
            }
        }, {
            key: "transitionIn",
            value: function() {
                var t = this;
                TweenLite.to(this.scene.objects.cam.position, 3, {
                    x: this.scene.campos.x1,
                    y: this.scene.campos.y1,
                    z: this.scene.campos.z1,
                    ease: Power3.easeInOut
                }), TweenLite.to(this.scene.objects.target.position, 3, {
                    x: this.scene.targetpos.x1,
                    y: -54.96,
                    ease: Power3.easeInOut
                }), TweenLite.to(this.scene.objects.stone1.position, 4, {
                    x: 0,
                    ease: Power3.easeInOut
                }), TweenLite.to(this.scene.objects.stone2.position, 4, {
                    x: 0,
                    ease: Power3.easeInOut
                }), TweenLite.to(this.scene.objects.stone3.position, 4, {
                    x: 0,
                    ease: Power3.easeInOut
                }), TweenLite.to(this.scene.objects.stone4.position, 4, {
                    x: 0,
                    ease: Power3.easeInOut
                }), TweenLite.to(this.scene.objects.stone1.rotation, 4, {
                    z: 0,
                    ease: Power3.easeInOut
                }), TweenLite.to(this.scene.objects.stone2.rotation, 4, {
                    z: 0,
                    ease: Power3.easeInOut
                }), TweenLite.to(this.scene.objects.stone3.rotation, 4, {
                    z: 0,
                    ease: Power3.easeInOut
                }), TweenLite.to(this.scene.objects.stone4.rotation, 4, {
                    z: 0,
                    ease: Power3.easeInOut
                }), TweenLite.to(s("header"), 1, {
                    y: 0,
                    opacity: 1,
                    delay: 1,
                    onComplete: function() {
                        t.screenAnimateIn(1)
                    }
                }), TweenLite.to(s("#scroll-nav"), 1, {
                    opacity: 1,
                    delay: 2.5,
                    onComplete: function() {
                        //s("#app").fullpage.setAllowScrolling(!0)
                    }
                }), s(".scrolltosec").bind("click", function(t) {
                    var e = s(t.currentTarget).data("sec");
                    s("#app").fullpage.moveTo(e)
                }), s(".scroll-btn").bind("click", function(t) {
                    s("#app").fullpage.moveTo(2)
                });
                for (var e = new o.TetrahedronGeometry(1.5, 0), i = new o.MeshPhongMaterial({
                        color: 0,
                        flatShading: o.FlatShading,
                        emissive: 1118481,
                        specular: 2236962,
                        shininess: 8.74
                    }), n = 0; n < 600; n++) {
                    var r = new o.Mesh(e, i);
                    r.position.set(0, 0, 0), r.position.multiplyScalar(90 + 700 * Math.random()), r.rotation.set(2 * Math.random(), 2 * Math.random(), 2 * Math.random()), this.scene.objects.particle.add(r), TweenLite.to(r.position, 3, {
                        x: Math.floor(501 * Math.random()) - 250,
                        y: Math.floor(51 * Math.random()) - 25,
                        z: Math.floor(501 * Math.random()) - 250,
                        delay: n / 700 + 2,
                        ease: Expo.easeOut
                    })
                }
            }
        }, {
            key: "firstView",
            value: function() {
                TweenLite.to(this.scene.objects.cam.position, 2.4, {
                    x: this.scene.campos.x1,
                    y: this.scene.campos.y1,
                    z: this.scene.campos.z1,
                    ease: Power3.easeInOut
                }), TweenLite.to(this.scene.objects.target.position, 2.4, {
                    x: this.scene.targetpos.x1,
                    ease: Power3.easeInOut
                })
            }
        }, {
            key: "secondView",
            value: function() {
                TweenLite.to(this.scene.objects.cam.position, 2.4, {
                    x: this.scene.campos.x1 + 300,
                    y: this.scene.campos.y1 + 100,
                    z: this.scene.campos.z1 - 150,
                    ease: Power3.easeInOut
                }), TweenLite.to(this.scene.objects.target.position, 2.4, {
                    x: this.scene.targetpos.x1 + this.scene.targetpos.x1plus,
                    ease: Power3.easeInOut
                })
            }
        }, {
            key: "thirdView",
            value: function() {
                TweenLite.to(this.scene.objects.cam.position, 2.4, {
                    x: this.scene.campos.x1 + 300,
                    y: this.scene.campos.y1 + 25,
                    z: this.scene.campos.z1 - 200,
                    ease: Power3.easeInOut
                }), TweenLite.to(this.scene.objects.target.position, 2.4, {
                    x: this.scene.targetpos.x1 + this.scene.targetpos.x1plus,
                    ease: Power3.easeInOut
                })
            }
        }, {
            key: "forthView",
            value: function() {
                TweenLite.to(this.scene.objects.cam.position, 2.4, {
                    x: this.scene.campos.x1 + 300,
                    y: this.scene.campos.y1 - 50,
                    z: this.scene.campos.z1 - 250,
                    ease: Power3.easeInOut
                }), TweenLite.to(this.scene.objects.target.position, 2.4, {
                    x: this.scene.targetpos.x1 + this.scene.targetpos.x1plus,
                    ease: Power3.easeInOut
                })
            }
        }, {
            key: "screenAnimateIn",
            value: function(t) {
                this.status = t, s("#screen-" + t).addClass("show"), s("#sts-" + t).addClass("active"), s("#screen-" + t + " .slidein").length > 0 && ("up" == this.direction && TweenLite.set(s("#screen-" + t + " .slidein-elm"), {
                    y: "-100%"
                }), TweenLite.to(s("#screen-" + t + " .slidein-elm"), 1, {
                    y: "0%",
                    ease: Power3.easeInOut
                })), s("#screen-" + t + " .fade").length > 0 && TweenLite.to(s("#screen-" + t + " .fade"), 1, {
                    opacity: 1,
                    delay: 1
                })
            }
        }, {
            key: "screenAnimateOut",
            value: function(t, e) {
                var i = void 0;
                i = "up" == e ? "100%" : "-100%", s("#sts-" + t).removeClass("active"), s("#screen-" + t + " .slidein").length > 0 && TweenLite.to(s("#screen-" + t + " .slidein-elm"), 1, {
                    y: i,
                    ease: Power3.easeInOut,
                    onComplete: function(e) {
                        TweenLite.set(s("#screen-" + t + " .slidein-elm"), {
                            y: "100%"
                        }), s("#screen-" + t).removeClass("show")
                    }
                }), s("#screen-" + t + " .fade").length > 0 && TweenLite.to(s("#screen-" + t + " .fade"), 1, {
                    opacity: 0
                })
            }
        }, {
            key: "imageTransition",
            value: function(t, e) {
                if (1 != t && 5 != t) {
                    s("#portfolio-img").addClass("show");
                    var i = t - 1;
                    "down" != e && s(".pfi-cover").addClass("shift"), TweenLite.to(s(".pfi-cover"), 1, {
                        scaleY: 1,
                        ease: Power3.easeInOut,
                        onComplete: function() {
                            s(".pfi-image").hide(), TweenLite.set(s(".pfi-image"), {
                                scale: 1.4
                            }), s("#pfi-image-" + i).show(), s(".pfi-cover").addClass("shift"), "down" != e ? s(".pfi-cover").removeClass("shift") : s(".pfi-cover").addClass("shift"), TweenLite.to(s("#pfi-image-" + i), 2, {
                                scale: 1,
                                ease: Power3.easeOut
                            }), TweenLite.to(s(".pfi-cover"), 1, {
                                scaleY: 0,
                                ease: Power3.easeInOut,
                                onComplete: function() {
                                    s(".pfi-cover").removeClass("shift")
                                }
                            })
                        }
                    })
                }
                1 != t && 5 != t || ("down" != e && s(".pfi-cover").addClass("shift"), TweenLite.to(s(".pfi-cover"), 1, {
                    scaleY: 1,
                    ease: Power3.easeInOut,
                    onComplete: function() {
                        s(".pfi-image").hide(), TweenLite.set(s(".pfi-image"), {
                            scale: 1.4
                        }), "down" != e ? s(".pfi-cover").removeClass("shift") : s(".pfi-cover").addClass("shift"), TweenLite.to(s(".pfi-cover"), 1, {
                            scaleY: 0,
                            ease: Power3.easeInOut,
                            onComplete: function() {
                                s(".pfi-cover").removeClass("shift")
                            }
                        })
                    }
                }))
            }
        }, {
            key: "loadScene",
            value: function(t) {
                var e = this;
                this.webgl && (this.scene = new a(this, t), this.setupScene(), this.scene.setSize(window.innerWidth, window.innerHeight), this.scene.start()), s("#app").fullpage({
                    scrollingSpeed: 1e3,
                    fadingEffect: !0,
                    fadingEffectKey: "bmF0aGFuZ2FvLnh5el92QVVabUZrYVc1blJXWm1aV04wMTQy",
                    onLeave: function(t, i, n) {
                        e.direction = n, e.screenAnimateOut(t, n), e.imageTransition(i, n), e.webgl && (2 == i && e.secondView(), 3 == i && e.thirdView(), 4 == i && e.forthView(), 1 != i && 5 != i || e.firstView())
                    },
                    afterLoad: function(t, i) {
                        "init" != e.status && e.screenAnimateIn(i)
                    }
                })//, s("#app").fullpage.setAllowScrolling(!1)
            }
        }]), t
    }();
    t.exports = l
}, function(t, e, i) {
    ! function(t, i) {
        i(e)
    }(0, function(t) {
        "use strict";

        function e() {}

        function i(t, e) {
            this.x = t || 0, this.y = e || 0
        }

        function n() {
            this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1], arguments.length > 0 && console.error("THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.")
        }

        function r(t, e, i, n) {
            this._x = t || 0, this._y = e || 0, this._z = i || 0, this._w = void 0 !== n ? n : 1
        }

        function o(t, e, i) {
            this.x = t || 0, this.y = e || 0, this.z = i || 0
        }

        function a() {
            this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1], arguments.length > 0 && console.error("THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.")
        }

        function s(t, e, n, r, o, l, c, u, h, d) {
            Object.defineProperty(this, "id", {
                value: Ga++
            }), this.uuid = Ha.generateUUID(), this.name = "", this.image = void 0 !== t ? t : s.DEFAULT_IMAGE, this.mipmaps = [], this.mapping = void 0 !== e ? e : s.DEFAULT_MAPPING, this.wrapS = void 0 !== n ? n : Wo, this.wrapT = void 0 !== r ? r : Wo, this.magFilter = void 0 !== o ? o : Zo, this.minFilter = void 0 !== l ? l : $o, this.anisotropy = void 0 !== h ? h : 1, this.format = void 0 !== c ? c : pa, this.type = void 0 !== u ? u : Ko, this.offset = new i(0, 0), this.repeat = new i(1, 1), this.center = new i(0, 0), this.rotation = 0, this.matrixAutoUpdate = !0, this.matrix = new a, this.generateMipmaps = !0, this.premultiplyAlpha = !1, this.flipY = !0, this.unpackAlignment = 4, this.encoding = void 0 !== d ? d : Ia, this.version = 0, this.onUpdate = null
        }

        function l(t, e, i, n) {
            this.x = t || 0, this.y = e || 0, this.z = i || 0, this.w = void 0 !== n ? n : 1
        }

        function c(t, e, i) {
            this.uuid = Ha.generateUUID(), this.width = t, this.height = e, this.scissor = new l(0, 0, t, e), this.scissorTest = !1, this.viewport = new l(0, 0, t, e), void 0 === (i = i || {}).minFilter && (i.minFilter = Zo), this.texture = new s(void 0, void 0, i.wrapS, i.wrapT, i.magFilter, i.minFilter, i.format, i.type, i.anisotropy, i.encoding), this.depthBuffer = void 0 === i.depthBuffer || i.depthBuffer, this.stencilBuffer = void 0 === i.stencilBuffer || i.stencilBuffer, this.depthTexture = void 0 !== i.depthTexture ? i.depthTexture : null
        }

        function u(t, e, i) {
            c.call(this, t, e, i), this.activeCubeFace = 0, this.activeMipMapLevel = 0
        }

        function h(t, e, i, n, r, o, a, l, c, u, h, d) {
            s.call(this, null, o, a, l, c, u, n, r, h, d), this.image = {
                data: t,
                width: e,
                height: i
            }, this.magFilter = void 0 !== c ? c : qo, this.minFilter = void 0 !== u ? u : qo, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1
        }

        function d(t, e, i, n, r, o, a, l, c, u) {
            t = void 0 !== t ? t : [], e = void 0 !== e ? e : ko, s.call(this, t, e, i, n, r, o, a, l, c, u), this.flipY = !1
        }

        function p() {
            this.seq = [], this.map = {}
        }

        function f(t, e, i) {
            var n = t[0];
            if (n <= 0 || n > 0) return t;
            var r = e * i,
                o = Xa[r];
            if (void 0 === o && (o = new Float32Array(r), Xa[r] = o), 0 !== e) {
                n.toArray(o, 0);
                for (var a = 1, s = 0; a !== e; ++a) s += i, t[a].toArray(o, s)
            }
            return o
        }

        function m(t, e) {
            var i = qa[e];
            void 0 === i && (i = new Int32Array(e), qa[e] = i);
            for (var n = 0; n !== e; ++n) i[n] = t.allocTextureUnit();
            return i
        }

        function g(t, e) {
            t.uniform1f(this.addr, e)
        }

        function v(t, e) {
            t.uniform1i(this.addr, e)
        }

        function y(t, e) {
            void 0 === e.x ? t.uniform2fv(this.addr, e) : t.uniform2f(this.addr, e.x, e.y)
        }

        function _(t, e) {
            void 0 !== e.x ? t.uniform3f(this.addr, e.x, e.y, e.z) : void 0 !== e.r ? t.uniform3f(this.addr, e.r, e.g, e.b) : t.uniform3fv(this.addr, e)
        }

        function x(t, e) {
            void 0 === e.x ? t.uniform4fv(this.addr, e) : t.uniform4f(this.addr, e.x, e.y, e.z, e.w)
        }

        function b(t, e) {
            t.uniformMatrix2fv(this.addr, !1, e.elements || e)
        }

        function w(t, e) {
            void 0 === e.elements ? t.uniformMatrix3fv(this.addr, !1, e) : (Qa.set(e.elements), t.uniformMatrix3fv(this.addr, !1, Qa))
        }

        function T(t, e) {
            void 0 === e.elements ? t.uniformMatrix4fv(this.addr, !1, e) : (Ya.set(e.elements), t.uniformMatrix4fv(this.addr, !1, Ya))
        }

        function S(t, e, i) {
            var n = i.allocTextureUnit();
            t.uniform1i(this.addr, n), i.setTexture2D(e || Va, n)
        }

        function E(t, e, i) {
            var n = i.allocTextureUnit();
            t.uniform1i(this.addr, n), i.setTextureCube(e || Wa, n)
        }

        function M(t, e) {
            t.uniform2iv(this.addr, e)
        }

        function A(t, e) {
            t.uniform3iv(this.addr, e)
        }

        function L(t, e) {
            t.uniform4iv(this.addr, e)
        }

        function C(t) {
            switch (t) {
                case 5126:
                    return g;
                case 35664:
                    return y;
                case 35665:
                    return _;
                case 35666:
                    return x;
                case 35674:
                    return b;
                case 35675:
                    return w;
                case 35676:
                    return T;
                case 35678:
                case 36198:
                    return S;
                case 35680:
                    return E;
                case 5124:
                case 35670:
                    return v;
                case 35667:
                case 35671:
                    return M;
                case 35668:
                case 35672:
                    return A;
                case 35669:
                case 35673:
                    return L
            }
        }

        function P(t, e) {
            t.uniform1fv(this.addr, e)
        }

        function R(t, e) {
            t.uniform1iv(this.addr, e)
        }

        function O(t, e) {
            t.uniform2fv(this.addr, f(e, this.size, 2))
        }

        function I(t, e) {
            t.uniform3fv(this.addr, f(e, this.size, 3))
        }

        function D(t, e) {
            t.uniform4fv(this.addr, f(e, this.size, 4))
        }

        function N(t, e) {
            t.uniformMatrix2fv(this.addr, !1, f(e, this.size, 4))
        }

        function F(t, e) {
            t.uniformMatrix3fv(this.addr, !1, f(e, this.size, 9))
        }

        function k(t, e) {
            t.uniformMatrix4fv(this.addr, !1, f(e, this.size, 16))
        }

        function U(t, e, i) {
            var n = e.length,
                r = m(i, n);
            t.uniform1iv(this.addr, r);
            for (var o = 0; o !== n; ++o) i.setTexture2D(e[o] || Va, r[o])
        }

        function B(t, e, i) {
            var n = e.length,
                r = m(i, n);
            t.uniform1iv(this.addr, r);
            for (var o = 0; o !== n; ++o) i.setTextureCube(e[o] || Wa, r[o])
        }

        function z(t) {
            switch (t) {
                case 5126:
                    return P;
                case 35664:
                    return O;
                case 35665:
                    return I;
                case 35666:
                    return D;
                case 35674:
                    return N;
                case 35675:
                    return F;
                case 35676:
                    return k;
                case 35678:
                    return U;
                case 35680:
                    return B;
                case 5124:
                case 35670:
                    return R;
                case 35667:
                case 35671:
                    return M;
                case 35668:
                case 35672:
                    return A;
                case 35669:
                case 35673:
                    return L
            }
        }

        function j(t, e, i) {
            this.id = t, this.addr = i, this.setValue = C(e.type)
        }

        function H(t, e, i) {
            this.id = t, this.addr = i, this.size = e.size, this.setValue = z(e.type)
        }

        function G(t) {
            this.id = t, p.call(this)
        }

        function V(t, e) {
            t.seq.push(e), t.map[e.id] = e
        }

        function W(t, e, i) {
            var n = t.name,
                r = n.length;
            for (Za.lastIndex = 0;;) {
                var o = Za.exec(n),
                    a = Za.lastIndex,
                    s = o[1],
                    l = "]" === o[2],
                    c = o[3];
                if (l && (s |= 0), void 0 === c || "[" === c && a + 2 === r) {
                    V(i, void 0 === c ? new j(s, t, e) : new H(s, t, e));
                    break
                }
                var u = i.map[s];
                void 0 === u && V(i, u = new G(s)), i = u
            }
        }

        function X(t, e, i) {
            p.call(this), this.renderer = i;
            for (var n = t.getProgramParameter(e, t.ACTIVE_UNIFORMS), r = 0; r < n; ++r) {
                var o = t.getActiveUniform(e, r),
                    a = o.name;
                W(o, t.getUniformLocation(e, a), this)
            }
        }

        function q(t, e, i) {
            return void 0 === e && void 0 === i ? this.set(t) : this.setRGB(t, e, i)
        }

        function Y(t, e) {
            this.min = void 0 !== t ? t : new i(1 / 0, 1 / 0), this.max = void 0 !== e ? e : new i(-1 / 0, -1 / 0)
        }

        function Q(t, e, n, r, a) {
            function s() {
                var t = new Float32Array([-1, -1, 0, 0, 1, -1, 1, 0, 1, 1, 1, 1, -1, 1, 0, 1]),
                    i = new Uint16Array([0, 1, 2, 0, 2, 3]);
                c = e.createBuffer(), u = e.createBuffer(), e.bindBuffer(e.ARRAY_BUFFER, c), e.bufferData(e.ARRAY_BUFFER, t, e.STATIC_DRAW), e.bindBuffer(e.ELEMENT_ARRAY_BUFFER, u), e.bufferData(e.ELEMENT_ARRAY_BUFFER, i, e.STATIC_DRAW), m = e.createTexture(), g = e.createTexture(), n.bindTexture(e.TEXTURE_2D, m), e.texImage2D(e.TEXTURE_2D, 0, e.RGB, 16, 16, 0, e.RGB, e.UNSIGNED_BYTE, null), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_S, e.CLAMP_TO_EDGE), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_T, e.CLAMP_TO_EDGE), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MAG_FILTER, e.NEAREST), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MIN_FILTER, e.NEAREST), n.bindTexture(e.TEXTURE_2D, g), e.texImage2D(e.TEXTURE_2D, 0, e.RGBA, 16, 16, 0, e.RGBA, e.UNSIGNED_BYTE, null), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_S, e.CLAMP_TO_EDGE), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_T, e.CLAMP_TO_EDGE), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MAG_FILTER, e.NEAREST), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MIN_FILTER, e.NEAREST), h = {
                    vertexShader: ["uniform lowp int renderType;", "uniform vec3 screenPosition;", "uniform vec2 scale;", "uniform float rotation;", "uniform sampler2D occlusionMap;", "attribute vec2 position;", "attribute vec2 uv;", "varying vec2 vUV;", "varying float vVisibility;", "void main() {", "\tvUV = uv;", "\tvec2 pos = position;", "\tif ( renderType == 2 ) {", "\t\tvec4 visibility = texture2D( occlusionMap, vec2( 0.1, 0.1 ) );", "\t\tvisibility += texture2D( occlusionMap, vec2( 0.5, 0.1 ) );", "\t\tvisibility += texture2D( occlusionMap, vec2( 0.9, 0.1 ) );", "\t\tvisibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) );", "\t\tvisibility += texture2D( occlusionMap, vec2( 0.9, 0.9 ) );", "\t\tvisibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) );", "\t\tvisibility += texture2D( occlusionMap, vec2( 0.1, 0.9 ) );", "\t\tvisibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) );", "\t\tvisibility += texture2D( occlusionMap, vec2( 0.5, 0.5 ) );", "\t\tvVisibility =        visibility.r / 9.0;", "\t\tvVisibility *= 1.0 - visibility.g / 9.0;", "\t\tvVisibility *=       visibility.b / 9.0;", "\t\tvVisibility *= 1.0 - visibility.a / 9.0;", "\t\tpos.x = cos( rotation ) * position.x - sin( rotation ) * position.y;", "\t\tpos.y = sin( rotation ) * position.x + cos( rotation ) * position.y;", "\t}", "\tgl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );", "}"].join("\n"),
                    fragmentShader: ["uniform lowp int renderType;", "uniform sampler2D map;", "uniform float opacity;", "uniform vec3 color;", "varying vec2 vUV;", "varying float vVisibility;", "void main() {", "\tif ( renderType == 0 ) {", "\t\tgl_FragColor = vec4( 1.0, 0.0, 1.0, 0.0 );", "\t} else if ( renderType == 1 ) {", "\t\tgl_FragColor = texture2D( map, vUV );", "\t} else {", "\t\tvec4 texture = texture2D( map, vUV );", "\t\ttexture.a *= opacity * vVisibility;", "\t\tgl_FragColor = texture;", "\t\tgl_FragColor.rgb *= color;", "\t}", "}"].join("\n")
                }, d = l(h), p = {
                    vertex: e.getAttribLocation(d, "position"),
                    uv: e.getAttribLocation(d, "uv")
                }, f = {
                    renderType: e.getUniformLocation(d, "renderType"),
                    map: e.getUniformLocation(d, "map"),
                    occlusionMap: e.getUniformLocation(d, "occlusionMap"),
                    opacity: e.getUniformLocation(d, "opacity"),
                    color: e.getUniformLocation(d, "color"),
                    scale: e.getUniformLocation(d, "scale"),
                    rotation: e.getUniformLocation(d, "rotation"),
                    screenPosition: e.getUniformLocation(d, "screenPosition")
                }
            }

            function l(t) {
                var i = e.createProgram(),
                    n = e.createShader(e.FRAGMENT_SHADER),
                    r = e.createShader(e.VERTEX_SHADER),
                    o = "precision " + a.precision + " float;\n";
                return e.shaderSource(n, o + t.fragmentShader), e.shaderSource(r, o + t.vertexShader), e.compileShader(n), e.compileShader(r), e.attachShader(i, n), e.attachShader(i, r), e.linkProgram(i), i
            }
            var c, u, h, d, p, f, m, g;
            this.render = function(t, a, l, h) {
                if (0 !== t.length) {
                    var v = new o,
                        y = h.w / h.z,
                        _ = .5 * h.z,
                        x = .5 * h.w,
                        b = 16 / h.w,
                        w = new i(b * y, b),
                        T = new o(1, 1, 0),
                        S = new i(1, 1),
                        E = new Y;
                    E.min.set(h.x, h.y), E.max.set(h.x + (h.z - 16), h.y + (h.w - 16)), void 0 === d && s(), n.useProgram(d), n.initAttributes(), n.enableAttribute(p.vertex), n.enableAttribute(p.uv), n.disableUnusedAttributes(), e.uniform1i(f.occlusionMap, 0), e.uniform1i(f.map, 1), e.bindBuffer(e.ARRAY_BUFFER, c), e.vertexAttribPointer(p.vertex, 2, e.FLOAT, !1, 16, 0), e.vertexAttribPointer(p.uv, 2, e.FLOAT, !1, 16, 8), e.bindBuffer(e.ELEMENT_ARRAY_BUFFER, u), n.disable(e.CULL_FACE), n.buffers.depth.setMask(!1);
                    for (var M = 0, A = t.length; M < A; M++) {
                        b = 16 / h.w, w.set(b * y, b);
                        var L = t[M];
                        if (v.set(L.matrixWorld.elements[12], L.matrixWorld.elements[13], L.matrixWorld.elements[14]), v.applyMatrix4(l.matrixWorldInverse), v.applyMatrix4(l.projectionMatrix), T.copy(v), S.x = h.x + T.x * _ + _ - 8, S.y = h.y + T.y * x + x - 8, !0 === E.containsPoint(S)) {
                            n.activeTexture(e.TEXTURE0), n.bindTexture(e.TEXTURE_2D, null), n.activeTexture(e.TEXTURE1), n.bindTexture(e.TEXTURE_2D, m), e.copyTexImage2D(e.TEXTURE_2D, 0, e.RGB, S.x, S.y, 16, 16, 0), e.uniform1i(f.renderType, 0), e.uniform2f(f.scale, w.x, w.y), e.uniform3f(f.screenPosition, T.x, T.y, T.z), n.disable(e.BLEND), n.enable(e.DEPTH_TEST), e.drawElements(e.TRIANGLES, 6, e.UNSIGNED_SHORT, 0), n.activeTexture(e.TEXTURE0), n.bindTexture(e.TEXTURE_2D, g), e.copyTexImage2D(e.TEXTURE_2D, 0, e.RGBA, S.x, S.y, 16, 16, 0), e.uniform1i(f.renderType, 1), n.disable(e.DEPTH_TEST), n.activeTexture(e.TEXTURE1), n.bindTexture(e.TEXTURE_2D, m), e.drawElements(e.TRIANGLES, 6, e.UNSIGNED_SHORT, 0), L.positionScreen.copy(T), L.customUpdateCallback ? L.customUpdateCallback(L) : L.updateLensFlares(), e.uniform1i(f.renderType, 2), n.enable(e.BLEND);
                            for (var C = 0, P = L.lensFlares.length; C < P; C++) {
                                var R = L.lensFlares[C];
                                R.opacity > .001 && R.scale > .001 && (T.x = R.x, T.y = R.y, T.z = R.z, b = R.size * R.scale / h.w, w.x = b * y, w.y = b, e.uniform3f(f.screenPosition, T.x, T.y, T.z), e.uniform2f(f.scale, w.x, w.y), e.uniform1f(f.rotation, R.rotation), e.uniform1f(f.opacity, R.opacity), e.uniform3f(f.color, R.color.r, R.color.g, R.color.b), n.setBlending(R.blending, R.blendEquation, R.blendSrc, R.blendDst), r.setTexture2D(R.texture, 1), e.drawElements(e.TRIANGLES, 6, e.UNSIGNED_SHORT, 0))
                            }
                        }
                    }
                    n.enable(e.CULL_FACE), n.enable(e.DEPTH_TEST), n.buffers.depth.setMask(!0), n.reset()
                }
            }
        }

        function Z(t, e, i, n, r, o, a, l, c) {
            s.call(this, t, e, i, n, r, o, a, l, c), this.needsUpdate = !0
        }

        function J(t, e, i, n, a) {
            function s() {
                var t = new Float32Array([-.5, -.5, 0, 0, .5, -.5, 1, 0, .5, .5, 1, 1, -.5, .5, 0, 1]),
                    i = new Uint16Array([0, 1, 2, 0, 2, 3]);
                u = e.createBuffer(), h = e.createBuffer(), e.bindBuffer(e.ARRAY_BUFFER, u), e.bufferData(e.ARRAY_BUFFER, t, e.STATIC_DRAW), e.bindBuffer(e.ELEMENT_ARRAY_BUFFER, h), e.bufferData(e.ELEMENT_ARRAY_BUFFER, i, e.STATIC_DRAW), d = l(), p = {
                    position: e.getAttribLocation(d, "position"),
                    uv: e.getAttribLocation(d, "uv")
                }, f = {
                    uvOffset: e.getUniformLocation(d, "uvOffset"),
                    uvScale: e.getUniformLocation(d, "uvScale"),
                    rotation: e.getUniformLocation(d, "rotation"),
                    scale: e.getUniformLocation(d, "scale"),
                    color: e.getUniformLocation(d, "color"),
                    map: e.getUniformLocation(d, "map"),
                    opacity: e.getUniformLocation(d, "opacity"),
                    modelViewMatrix: e.getUniformLocation(d, "modelViewMatrix"),
                    projectionMatrix: e.getUniformLocation(d, "projectionMatrix"),
                    fogType: e.getUniformLocation(d, "fogType"),
                    fogDensity: e.getUniformLocation(d, "fogDensity"),
                    fogNear: e.getUniformLocation(d, "fogNear"),
                    fogFar: e.getUniformLocation(d, "fogFar"),
                    fogColor: e.getUniformLocation(d, "fogColor"),
                    fogDepth: e.getUniformLocation(d, "fogDepth"),
                    alphaTest: e.getUniformLocation(d, "alphaTest")
                };
                var n = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas");
                n.width = 8, n.height = 8;
                var r = n.getContext("2d");
                r.fillStyle = "white", r.fillRect(0, 0, 8, 8), m = new Z(n)
            }

            function l() {
                var t = e.createProgram(),
                    i = e.createShader(e.VERTEX_SHADER),
                    n = e.createShader(e.FRAGMENT_SHADER);
                return e.shaderSource(i, ["precision " + a.precision + " float;", "#define SHADER_NAME SpriteMaterial", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform float rotation;", "uniform vec2 scale;", "uniform vec2 uvOffset;", "uniform vec2 uvScale;", "attribute vec2 position;", "attribute vec2 uv;", "varying vec2 vUV;", "varying float fogDepth;", "void main() {", "\tvUV = uvOffset + uv * uvScale;", "\tvec2 alignedPosition = position * scale;", "\tvec2 rotatedPosition;", "\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;", "\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;", "\tvec4 mvPosition;", "\tmvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );", "\tmvPosition.xy += rotatedPosition;", "\tgl_Position = projectionMatrix * mvPosition;", "\tfogDepth = - mvPosition.z;", "}"].join("\n")), e.shaderSource(n, ["precision " + a.precision + " float;", "#define SHADER_NAME SpriteMaterial", "uniform vec3 color;", "uniform sampler2D map;", "uniform float opacity;", "uniform int fogType;", "uniform vec3 fogColor;", "uniform float fogDensity;", "uniform float fogNear;", "uniform float fogFar;", "uniform float alphaTest;", "varying vec2 vUV;", "varying float fogDepth;", "void main() {", "\tvec4 texture = texture2D( map, vUV );", "\tgl_FragColor = vec4( color * texture.xyz, texture.a * opacity );", "\tif ( gl_FragColor.a < alphaTest ) discard;", "\tif ( fogType > 0 ) {", "\t\tfloat fogFactor = 0.0;", "\t\tif ( fogType == 1 ) {", "\t\t\tfogFactor = smoothstep( fogNear, fogFar, fogDepth );", "\t\t} else {", "\t\t\tconst float LOG2 = 1.442695;", "\t\t\tfogFactor = exp2( - fogDensity * fogDensity * fogDepth * fogDepth * LOG2 );", "\t\t\tfogFactor = 1.0 - clamp( fogFactor, 0.0, 1.0 );", "\t\t}", "\t\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );", "\t}", "}"].join("\n")), e.compileShader(i), e.compileShader(n), e.attachShader(t, i), e.attachShader(t, n), e.linkProgram(t), t
            }

            function c(t, e) {
                return t.renderOrder !== e.renderOrder ? t.renderOrder - e.renderOrder : t.z !== e.z ? e.z - t.z : e.id - t.id
            }
            var u, h, d, p, f, m, g = new o,
                v = new r,
                y = new o;
            this.render = function(r, o, a) {
                if (0 !== r.length) {
                    void 0 === d && s(), i.useProgram(d), i.initAttributes(), i.enableAttribute(p.position), i.enableAttribute(p.uv), i.disableUnusedAttributes(), i.disable(e.CULL_FACE), i.enable(e.BLEND), e.bindBuffer(e.ARRAY_BUFFER, u), e.vertexAttribPointer(p.position, 2, e.FLOAT, !1, 16, 0), e.vertexAttribPointer(p.uv, 2, e.FLOAT, !1, 16, 8), e.bindBuffer(e.ELEMENT_ARRAY_BUFFER, h), e.uniformMatrix4fv(f.projectionMatrix, !1, a.projectionMatrix.elements), i.activeTexture(e.TEXTURE0), e.uniform1i(f.map, 0);
                    var l = 0,
                        _ = 0,
                        x = o.fog;
                    x ? (e.uniform3f(f.fogColor, x.color.r, x.color.g, x.color.b), x.isFog ? (e.uniform1f(f.fogNear, x.near), e.uniform1f(f.fogFar, x.far), e.uniform1i(f.fogType, 1), l = 1, _ = 1) : x.isFogExp2 && (e.uniform1f(f.fogDensity, x.density), e.uniform1i(f.fogType, 2), l = 2, _ = 2)) : (e.uniform1i(f.fogType, 0), l = 0, _ = 0);
                    for (var b = 0, w = r.length; b < w; b++)(S = r[b]).modelViewMatrix.multiplyMatrices(a.matrixWorldInverse, S.matrixWorld), S.z = -S.modelViewMatrix.elements[14];
                    r.sort(c);
                    for (var T = [], b = 0, w = r.length; b < w; b++) {
                        var S = r[b],
                            E = S.material;
                        if (!1 !== E.visible) {
                            S.onBeforeRender(t, o, a, void 0, E, void 0), e.uniform1f(f.alphaTest, E.alphaTest), e.uniformMatrix4fv(f.modelViewMatrix, !1, S.modelViewMatrix.elements), S.matrixWorld.decompose(g, v, y), T[0] = y.x, T[1] = y.y;
                            var M = 0;
                            o.fog && E.fog && (M = _), l !== M && (e.uniform1i(f.fogType, M), l = M), null !== E.map ? (e.uniform2f(f.uvOffset, E.map.offset.x, E.map.offset.y), e.uniform2f(f.uvScale, E.map.repeat.x, E.map.repeat.y)) : (e.uniform2f(f.uvOffset, 0, 0), e.uniform2f(f.uvScale, 1, 1)), e.uniform1f(f.opacity, E.opacity), e.uniform3f(f.color, E.color.r, E.color.g, E.color.b), e.uniform1f(f.rotation, E.rotation), e.uniform2fv(f.scale, T), i.setBlending(E.blending, E.blendEquation, E.blendSrc, E.blendDst, E.blendEquationAlpha, E.blendSrcAlpha, E.blendDstAlpha, E.premultipliedAlpha), i.buffers.depth.setTest(E.depthTest), i.buffers.depth.setMask(E.depthWrite), i.buffers.color.setMask(E.colorWrite), n.setTexture2D(E.map || m, 0), e.drawElements(e.TRIANGLES, 6, e.UNSIGNED_SHORT, 0), S.onAfterRender(t, o, a, void 0, E, void 0)
                        }
                    }
                    i.enable(e.CULL_FACE), i.reset()
                }
            }
        }

        function $() {
            Object.defineProperty(this, "id", {
                value: is++
            }), this.uuid = Ha.generateUUID(), this.name = "", this.type = "Material", this.fog = !0, this.lights = !0, this.blending = Kr, this.side = Xr, this.flatShading = !1, this.vertexColors = Qr, this.opacity = 1, this.transparent = !1, this.blendSrc = fo, this.blendDst = mo, this.blendEquation = ro, this.blendSrcAlpha = null, this.blendDstAlpha = null, this.blendEquationAlpha = null, this.depthFunc = So, this.depthTest = !0, this.depthWrite = !0, this.clippingPlanes = null, this.clipIntersection = !1, this.clipShadows = !1, this.colorWrite = !0, this.precision = null, this.polygonOffset = !1, this.polygonOffsetFactor = 0, this.polygonOffsetUnits = 0, this.dithering = !1, this.alphaTest = 0, this.premultipliedAlpha = !1, this.overdraw = 0, this.visible = !0, this.userData = {}, this.needsUpdate = !0
        }

        function K(t) {
            $.call(this), this.type = "MeshDepthMaterial", this.depthPacking = za, this.skinning = !1, this.morphTargets = !1, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.lights = !1, this.setValues(t)
        }

        function tt(t) {
            $.call(this), this.type = "MeshDistanceMaterial", this.referencePosition = new o, this.nearDistance = 1, this.farDistance = 1e3, this.skinning = !1, this.morphTargets = !1, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.fog = !1, this.lights = !1, this.setValues(t)
        }

        function et(t, e) {
            this.min = void 0 !== t ? t : new o(1 / 0, 1 / 0, 1 / 0), this.max = void 0 !== e ? e : new o(-1 / 0, -1 / 0, -1 / 0)
        }

        function it(t, e) {
            this.center = void 0 !== t ? t : new o, this.radius = void 0 !== e ? e : 0
        }

        function nt(t, e) {
            this.normal = void 0 !== t ? t : new o(1, 0, 0), this.constant = void 0 !== e ? e : 0
        }

        function rt(t, e, i, n, r, o) {
            this.planes = [void 0 !== t ? t : new nt, void 0 !== e ? e : new nt, void 0 !== i ? i : new nt, void 0 !== n ? n : new nt, void 0 !== r ? r : new nt, void 0 !== o ? o : new nt]
        }

        function ot(t, e, r) {
            function a(e, i, n, r, o, a) {
                var s = e.geometry,
                    l = null,
                    c = _,
                    u = e.customDepthMaterial;
                if (n && (c = x, u = e.customDistanceMaterial), u) l = u;
                else {
                    var h = !1;
                    i.morphTargets && (s && s.isBufferGeometry ? h = s.morphAttributes && s.morphAttributes.position && s.morphAttributes.position.length > 0 : s && s.isGeometry && (h = s.morphTargets && s.morphTargets.length > 0)), e.isSkinnedMesh && !1 === i.skinning && console.warn("THREE.WebGLShadowMap: THREE.SkinnedMesh with material.skinning set to false:", e);
                    var d = e.isSkinnedMesh && i.skinning,
                        p = 0;
                    h && (p |= g), d && (p |= v), l = c[p]
                }
                if (t.localClippingEnabled && !0 === i.clipShadows && 0 !== i.clippingPlanes.length) {
                    var f = l.uuid,
                        m = i.uuid,
                        y = b[f];
                    void 0 === y && (y = {}, b[f] = y);
                    var w = y[m];
                    void 0 === w && (w = l.clone(), y[m] = w), l = w
                }
                l.visible = i.visible, l.wireframe = i.wireframe;
                var T = i.side;
                return P.renderSingleSided && T == Yr && (T = Xr), P.renderReverseSided && (T === Xr ? T = qr : T === qr && (T = Xr)), l.side = T, l.clipShadows = i.clipShadows, l.clippingPlanes = i.clippingPlanes, l.clipIntersection = i.clipIntersection, l.wireframeLinewidth = i.wireframeLinewidth, l.linewidth = i.linewidth, n && l.isMeshDistanceMaterial && (l.referencePosition.copy(r), l.nearDistance = o, l.farDistance = a), l
            }

            function s(i, n, r, o) {
                if (!1 !== i.visible) {
                    if (i.layers.test(n.layers) && (i.isMesh || i.isLine || i.isPoints) && i.castShadow && (!i.frustumCulled || u.intersectsObject(i))) {
                        i.modelViewMatrix.multiplyMatrices(r.matrixWorldInverse, i.matrixWorld);
                        var l = e.update(i),
                            c = i.material;
                        if (Array.isArray(c))
                            for (var h = l.groups, d = 0, p = h.length; d < p; d++) {
                                var f = h[d],
                                    g = c[f.materialIndex];
                                if (g && g.visible) {
                                    v = a(i, g, o, m, r.near, r.far);
                                    t.renderBufferDirect(r, null, l, v, i, f)
                                }
                            } else if (c.visible) {
                                var v = a(i, c, o, m, r.near, r.far);
                                t.renderBufferDirect(r, null, l, v, i, null)
                            }
                    }
                    for (var y = i.children, _ = 0, x = y.length; _ < x; _++) s(y[_], n, r, o)
                }
            }
            for (var u = new rt, h = new n, d = new i, p = new i(r, r), f = new o, m = new o, g = 1, v = 2, y = 1 + (g | v), _ = new Array(y), x = new Array(y), b = {}, w = [new o(1, 0, 0), new o(-1, 0, 0), new o(0, 0, 1), new o(0, 0, -1), new o(0, 1, 0), new o(0, -1, 0)], T = [new o(0, 1, 0), new o(0, 1, 0), new o(0, 1, 0), new o(0, 1, 0), new o(0, 0, 1), new o(0, 0, -1)], S = [new l, new l, new l, new l, new l, new l], E = 0; E !== y; ++E) {
                var M = 0 != (E & g),
                    A = 0 != (E & v),
                    L = new K({
                        depthPacking: ja,
                        morphTargets: M,
                        skinning: A
                    });
                _[E] = L;
                var C = new tt({
                    morphTargets: M,
                    skinning: A
                });
                x[E] = C
            }
            var P = this;
            this.enabled = !1, this.autoUpdate = !0, this.needsUpdate = !1, this.type = Vr, this.renderReverseSided = !0, this.renderSingleSided = !0, this.render = function(e, i, n) {
                if (!1 !== P.enabled && (!1 !== P.autoUpdate || !1 !== P.needsUpdate) && 0 !== e.length) {
                    var r = t.context,
                        o = t.state;
                    o.disable(r.BLEND), o.buffers.color.setClear(1, 1, 1, 1), o.buffers.depth.setTest(!0), o.setScissorTest(!1);
                    for (var a, l = 0, g = e.length; l < g; l++) {
                        var v = e[l],
                            y = v.shadow,
                            _ = v && v.isPointLight;
                        if (void 0 !== y) {
                            var x = y.camera;
                            if (d.copy(y.mapSize), d.min(p), _) {
                                var b = d.x,
                                    E = d.y;
                                S[0].set(2 * b, E, b, E), S[1].set(0, E, b, E), S[2].set(3 * b, E, b, E), S[3].set(b, E, b, E), S[4].set(3 * b, 0, b, E), S[5].set(b, 0, b, E), d.x *= 4, d.y *= 2
                            }
                            if (null === y.map) {
                                var M = {
                                    minFilter: qo,
                                    magFilter: qo,
                                    format: pa
                                };
                                y.map = new c(d.x, d.y, M), y.map.texture.name = v.name + ".shadowMap", x.updateProjectionMatrix()
                            }
                            y.isSpotLightShadow && y.update(v);
                            var A = y.map,
                                L = y.matrix;
                            m.setFromMatrixPosition(v.matrixWorld), x.position.copy(m), _ ? (a = 6, L.makeTranslation(-m.x, -m.y, -m.z)) : (a = 1, f.setFromMatrixPosition(v.target.matrixWorld), x.lookAt(f), x.updateMatrixWorld(), L.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1), L.multiply(x.projectionMatrix), L.multiply(x.matrixWorldInverse)), t.setRenderTarget(A), t.clear();
                            for (var C = 0; C < a; C++) {
                                if (_) {
                                    f.copy(x.position), f.add(w[C]), x.up.copy(T[C]), x.lookAt(f), x.updateMatrixWorld();
                                    var R = S[C];
                                    o.viewport(R)
                                }
                                h.multiplyMatrices(x.projectionMatrix, x.matrixWorldInverse), u.setFromMatrix(h), s(i, n, x, _)
                            }
                        } else console.warn("THREE.WebGLShadowMap:", v, "has no shadow.")
                    }
                    P.needsUpdate = !1
                }
            }
        }

        function at(t) {
            function e(e, i) {
                var n = e.array,
                    r = e.dynamic ? t.DYNAMIC_DRAW : t.STATIC_DRAW,
                    o = t.createBuffer();
                t.bindBuffer(i, o), t.bufferData(i, n, r), e.onUploadCallback();
                var a = t.FLOAT;
                return n instanceof Float32Array ? a = t.FLOAT : n instanceof Float64Array ? console.warn("THREE.WebGLAttributes: Unsupported data buffer format: Float64Array.") : n instanceof Uint16Array ? a = t.UNSIGNED_SHORT : n instanceof Int16Array ? a = t.SHORT : n instanceof Uint32Array ? a = t.UNSIGNED_INT : n instanceof Int32Array ? a = t.INT : n instanceof Int8Array ? a = t.BYTE : n instanceof Uint8Array && (a = t.UNSIGNED_BYTE), {
                    buffer: o,
                    type: a,
                    bytesPerElement: n.BYTES_PER_ELEMENT,
                    version: e.version
                }
            }

            function i(e, i, n) {
                var r = i.array,
                    o = i.updateRange;
                t.bindBuffer(n, e), !1 === i.dynamic ? t.bufferData(n, r, t.STATIC_DRAW) : -1 === o.count ? t.bufferSubData(n, 0, r) : 0 === o.count ? console.error("THREE.WebGLObjects.updateBuffer: dynamic THREE.BufferAttribute marked as needsUpdate but updateRange.count is 0, ensure you are using set methods or updating manually.") : (t.bufferSubData(n, o.offset * r.BYTES_PER_ELEMENT, r.subarray(o.offset, o.offset + o.count)), o.count = -1)
            }
            var n = {};
            return {
                get: function(t) {
                    return t.isInterleavedBufferAttribute && (t = t.data), n[t.uuid]
                },
                remove: function(e) {
                    e.isInterleavedBufferAttribute && (e = e.data);
                    var i = n[e.uuid];
                    i && (t.deleteBuffer(i.buffer), delete n[e.uuid])
                },
                update: function(t, r) {
                    t.isInterleavedBufferAttribute && (t = t.data);
                    var o = n[t.uuid];
                    void 0 === o ? n[t.uuid] = e(t, r) : o.version < t.version && (i(o.buffer, t, r), o.version = t.version)
                }
            }
        }

        function st(t, e, i, n) {
            this._x = t || 0, this._y = e || 0, this._z = i || 0, this._order = n || st.DefaultOrder
        }

        function lt() {
            this.mask = 1
        }

        function ct() {
            Object.defineProperty(this, "id", {
                value: ns++
            }), this.uuid = Ha.generateUUID(), this.name = "", this.type = "Object3D", this.parent = null, this.children = [], this.up = ct.DefaultUp.clone();
            var t = new o,
                e = new st,
                i = new r,
                s = new o(1, 1, 1);
            e.onChange(function() {
                i.setFromEuler(e, !1)
            }), i.onChange(function() {
                e.setFromQuaternion(i, void 0, !1)
            }), Object.defineProperties(this, {
                position: {
                    enumerable: !0,
                    value: t
                },
                rotation: {
                    enumerable: !0,
                    value: e
                },
                quaternion: {
                    enumerable: !0,
                    value: i
                },
                scale: {
                    enumerable: !0,
                    value: s
                },
                modelViewMatrix: {
                    value: new n
                },
                normalMatrix: {
                    value: new a
                }
            }), this.matrix = new n, this.matrixWorld = new n, this.matrixAutoUpdate = ct.DefaultMatrixAutoUpdate, this.matrixWorldNeedsUpdate = !1, this.layers = new lt, this.visible = !0, this.castShadow = !1, this.receiveShadow = !1, this.frustumCulled = !0, this.renderOrder = 0, this.userData = {}
        }

        function ut() {
            ct.call(this), this.type = "Camera", this.matrixWorldInverse = new n, this.projectionMatrix = new n
        }

        function ht(t, e, i, n, r, o) {
            ut.call(this), this.type = "OrthographicCamera", this.zoom = 1, this.view = null, this.left = t, this.right = e, this.top = i, this.bottom = n, this.near = void 0 !== r ? r : .1, this.far = void 0 !== o ? o : 2e3, this.updateProjectionMatrix()
        }

        function dt(t, e, i, n, r, a) {
            this.a = t, this.b = e, this.c = i, this.normal = n && n.isVector3 ? n : new o, this.vertexNormals = Array.isArray(n) ? n : [], this.color = r && r.isColor ? r : new q, this.vertexColors = Array.isArray(r) ? r : [], this.materialIndex = void 0 !== a ? a : 0
        }

        function pt() {
            Object.defineProperty(this, "id", {
                value: rs += 2
            }), this.uuid = Ha.generateUUID(), this.name = "", this.type = "Geometry", this.vertices = [], this.colors = [], this.faces = [], this.faceVertexUvs = [
                []
            ], this.morphTargets = [], this.morphNormals = [], this.skinWeights = [], this.skinIndices = [], this.lineDistances = [], this.boundingBox = null, this.boundingSphere = null, this.elementsNeedUpdate = !1, this.verticesNeedUpdate = !1, this.uvsNeedUpdate = !1, this.normalsNeedUpdate = !1, this.colorsNeedUpdate = !1, this.lineDistancesNeedUpdate = !1, this.groupsNeedUpdate = !1
        }

        function ft(t, e, i) {
            if (Array.isArray(t)) throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
            this.uuid = Ha.generateUUID(), this.name = "", this.array = t, this.itemSize = e, this.count = void 0 !== t ? t.length / e : 0, this.normalized = !0 === i, this.dynamic = !1, this.updateRange = {
                offset: 0,
                count: -1
            }, this.onUploadCallback = function() {}, this.version = 0
        }

        function mt(t, e, i) {
            ft.call(this, new Int8Array(t), e, i)
        }

        function gt(t, e, i) {
            ft.call(this, new Uint8Array(t), e, i)
        }

        function vt(t, e, i) {
            ft.call(this, new Uint8ClampedArray(t), e, i)
        }

        function yt(t, e, i) {
            ft.call(this, new Int16Array(t), e, i)
        }

        function _t(t, e, i) {
            ft.call(this, new Uint16Array(t), e, i)
        }

        function xt(t, e, i) {
            ft.call(this, new Int32Array(t), e, i)
        }

        function bt(t, e, i) {
            ft.call(this, new Uint32Array(t), e, i)
        }

        function wt(t, e, i) {
            ft.call(this, new Float32Array(t), e, i)
        }

        function Tt(t, e, i) {
            ft.call(this, new Float64Array(t), e, i)
        }

        function St() {
            this.indices = [], this.vertices = [], this.normals = [], this.colors = [], this.uvs = [], this.uvs2 = [], this.groups = [], this.morphTargets = {}, this.skinWeights = [], this.skinIndices = [], this.boundingBox = null, this.boundingSphere = null, this.verticesNeedUpdate = !1, this.normalsNeedUpdate = !1, this.colorsNeedUpdate = !1, this.uvsNeedUpdate = !1, this.groupsNeedUpdate = !1
        }

        function Et(t) {
            if (0 === t.length) return -1 / 0;
            for (var e = t[0], i = 1, n = t.length; i < n; ++i) t[i] > e && (e = t[i]);
            return e
        }

        function Mt() {
            Object.defineProperty(this, "id", {
                value: os += 2
            }), this.uuid = Ha.generateUUID(), this.name = "", this.type = "BufferGeometry", this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingBox = null, this.boundingSphere = null, this.drawRange = {
                start: 0,
                count: 1 / 0
            }
        }

        function At(t, e, i, n, r, o) {
            pt.call(this), this.type = "BoxGeometry", this.parameters = {
                width: t,
                height: e,
                depth: i,
                widthSegments: n,
                heightSegments: r,
                depthSegments: o
            }, this.fromBufferGeometry(new Lt(t, e, i, n, r, o)), this.mergeVertices()
        }

        function Lt(t, e, i, n, r, a) {
            function s(t, e, i, n, r, a, s, m, g, v, y) {
                var _, x, b = a / g,
                    w = s / v,
                    T = a / 2,
                    S = s / 2,
                    E = m / 2,
                    M = g + 1,
                    A = v + 1,
                    L = 0,
                    C = 0,
                    P = new o;
                for (x = 0; x < A; x++) {
                    var R = x * w - S;
                    for (_ = 0; _ < M; _++) {
                        var O = _ * b - T;
                        P[t] = O * n, P[e] = R * r, P[i] = E, u.push(P.x, P.y, P.z), P[t] = 0, P[e] = 0, P[i] = m > 0 ? 1 : -1, h.push(P.x, P.y, P.z), d.push(_ / g), d.push(1 - x / v), L += 1
                    }
                }
                for (x = 0; x < v; x++)
                    for (_ = 0; _ < g; _++) {
                        var I = p + _ + M * x,
                            D = p + _ + M * (x + 1),
                            N = p + (_ + 1) + M * (x + 1),
                            F = p + (_ + 1) + M * x;
                        c.push(I, D, F), c.push(D, N, F), C += 6
                    }
                l.addGroup(f, C, y), f += C, p += L
            }
            Mt.call(this), this.type = "BoxBufferGeometry", this.parameters = {
                width: t,
                height: e,
                depth: i,
                widthSegments: n,
                heightSegments: r,
                depthSegments: a
            };
            var l = this;
            t = t || 1, e = e || 1, i = i || 1, n = Math.floor(n) || 1, r = Math.floor(r) || 1;
            var c = [],
                u = [],
                h = [],
                d = [],
                p = 0,
                f = 0;
            s("z", "y", "x", -1, -1, i, e, t, a = Math.floor(a) || 1, r, 0), s("z", "y", "x", 1, -1, i, e, -t, a, r, 1), s("x", "z", "y", 1, 1, t, i, e, n, a, 2), s("x", "z", "y", 1, -1, t, i, -e, n, a, 3), s("x", "y", "z", 1, -1, t, e, i, n, r, 4), s("x", "y", "z", -1, -1, t, e, -i, n, r, 5), this.setIndex(c), this.addAttribute("position", new wt(u, 3)), this.addAttribute("normal", new wt(h, 3)), this.addAttribute("uv", new wt(d, 2))
        }

        function Ct(t, e, i, n) {
            pt.call(this), this.type = "PlaneGeometry", this.parameters = {
                width: t,
                height: e,
                widthSegments: i,
                heightSegments: n
            }, this.fromBufferGeometry(new Pt(t, e, i, n)), this.mergeVertices()
        }

        function Pt(t, e, i, n) {
            Mt.call(this), this.type = "PlaneBufferGeometry", this.parameters = {
                width: t,
                height: e,
                widthSegments: i,
                heightSegments: n
            };
            var r, o, a = (t = t || 1) / 2,
                s = (e = e || 1) / 2,
                l = Math.floor(i) || 1,
                c = Math.floor(n) || 1,
                u = l + 1,
                h = c + 1,
                d = t / l,
                p = e / c,
                f = [],
                m = [],
                g = [],
                v = [];
            for (o = 0; o < h; o++) {
                var y = o * p - s;
                for (r = 0; r < u; r++) {
                    var _ = r * d - a;
                    m.push(_, -y, 0), g.push(0, 0, 1), v.push(r / l), v.push(1 - o / c)
                }
            }
            for (o = 0; o < c; o++)
                for (r = 0; r < l; r++) {
                    var x = r + u * o,
                        b = r + u * (o + 1),
                        w = r + 1 + u * (o + 1),
                        T = r + 1 + u * o;
                    f.push(x, b, T), f.push(b, w, T)
                }
            this.setIndex(f), this.addAttribute("position", new wt(m, 3)), this.addAttribute("normal", new wt(g, 3)), this.addAttribute("uv", new wt(v, 2))
        }

        function Rt(t) {
            $.call(this), this.type = "MeshBasicMaterial", this.color = new q(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = Co, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.skinning = !1, this.morphTargets = !1, this.lights = !1, this.setValues(t)
        }

        function Ot(t) {
            $.call(this), this.type = "ShaderMaterial", this.defines = {}, this.uniforms = {}, this.vertexShader = "void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}", this.fragmentShader = "void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}", this.linewidth = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.lights = !1, this.clipping = !1, this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.extensions = {
                derivatives: !1,
                fragDepth: !1,
                drawBuffers: !1,
                shaderTextureLOD: !1
            }, this.defaultAttributeValues = {
                color: [1, 1, 1],
                uv: [0, 0],
                uv2: [0, 0]
            }, this.index0AttributeName = void 0, void 0 !== t && (void 0 !== t.attributes && console.error("THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead."), this.setValues(t))
        }

        function It(t, e) {
            this.origin = void 0 !== t ? t : new o, this.direction = void 0 !== e ? e : new o
        }

        function Dt(t, e) {
            this.start = void 0 !== t ? t : new o, this.end = void 0 !== e ? e : new o
        }

        function Nt(t, e, i) {
            this.a = void 0 !== t ? t : new o, this.b = void 0 !== e ? e : new o, this.c = void 0 !== i ? i : new o
        }

        function Ft(t, e) {
            ct.call(this), this.type = "Mesh", this.geometry = void 0 !== t ? t : new Mt, this.material = void 0 !== e ? e : new Rt({
                color: 16777215 * Math.random()
            }), this.drawMode = Pa, this.updateMorphTargets()
        }

        function kt(t, e, i, n) {
            function r(t, i) {
                e.buffers.color.setClear(t.r, t.g, t.b, i, n)
            }
            var o, a, s, l = new q(0),
                c = 0;
            return {
                getClearColor: function() {
                    return l
                },
                setClearColor: function(t, e) {
                    l.set(t), r(l, c = void 0 !== e ? e : 1)
                },
                getClearAlpha: function() {
                    return c
                },
                setClearAlpha: function(t) {
                    r(l, c = t)
                },
                render: function(e, n, u, h) {
                    var d = n.background;
                    null === d ? r(l, c) : d && d.isColor && (r(d, 1), h = !0), (t.autoClear || h) && t.clear(t.autoClearColor, t.autoClearDepth, t.autoClearStencil), d && d.isCubeTexture ? (void 0 === s && ((s = new Ft(new Lt(1, 1, 1), new Ot({
                        uniforms: es.cube.uniforms,
                        vertexShader: es.cube.vertexShader,
                        fragmentShader: es.cube.fragmentShader,
                        side: qr,
                        depthTest: !0,
                        depthWrite: !1,
                        fog: !1
                    }))).geometry.removeAttribute("normal"), s.geometry.removeAttribute("uv"), s.onBeforeRender = function(t, e, i) {
                        this.matrixWorld.copyPosition(i.matrixWorld)
                    }, i.update(s.geometry)), s.material.uniforms.tCube.value = d, e.push(s, s.geometry, s.material, 0, null)) : d && d.isTexture && (void 0 === o && (o = new ht(-1, 1, 1, -1, 0, 1), a = new Ft(new Pt(2, 2), new Rt({
                        depthTest: !1,
                        depthWrite: !1,
                        fog: !1
                    })), i.update(a.geometry)), a.material.map = d, t.renderBufferDirect(o, null, a.geometry, a.material, a, null))
                }
            }
        }

        function Ut(t, e) {
            return t.renderOrder !== e.renderOrder ? t.renderOrder - e.renderOrder : t.program && e.program && t.program !== e.program ? t.program.id - e.program.id : t.material.id !== e.material.id ? t.material.id - e.material.id : t.z !== e.z ? t.z - e.z : t.id - e.id
        }

        function Bt(t, e) {
            return t.renderOrder !== e.renderOrder ? t.renderOrder - e.renderOrder : t.z !== e.z ? e.z - t.z : t.id - e.id
        }

        function zt() {
            var t = [],
                e = 0,
                i = [],
                n = [];
            return {
                opaque: i,
                transparent: n,
                init: function() {
                    e = 0, i.length = 0, n.length = 0
                },
                push: function(r, o, a, s, l) {
                    var c = t[e];
                    void 0 === c ? (c = {
                        id: r.id,
                        object: r,
                        geometry: o,
                        material: a,
                        program: a.program,
                        renderOrder: r.renderOrder,
                        z: s,
                        group: l
                    }, t[e] = c) : (c.id = r.id, c.object = r, c.geometry = o, c.material = a, c.program = a.program, c.renderOrder = r.renderOrder, c.z = s, c.group = l), (!0 === a.transparent ? n : i).push(c), e++
                },
                sort: function() {
                    i.length > 1 && i.sort(Ut), n.length > 1 && n.sort(Bt)
                }
            }
        }

        function jt() {
            var t = {};
            return {
                get: function(e, i) {
                    var n = e.id + "," + i.id,
                        r = t[n];
                    return void 0 === r && (r = new zt, t[n] = r), r
                },
                dispose: function() {
                    t = {}
                }
            }
        }

        function Ht(t, e) {
            return Math.abs(e[1]) - Math.abs(t[1])
        }

        function Gt(t) {
            var e = {},
                i = new Float32Array(8);
            return {
                update: function(n, r, o, a) {
                    var s = n.morphTargetInfluences,
                        l = s.length,
                        c = e[r.id];
                    if (void 0 === c) {
                        for (c = [], d = 0; d < l; d++) c[d] = [d, 0];
                        e[r.id] = c
                    }
                    for (var u = o.morphTargets && r.morphAttributes.position, h = o.morphNormals && r.morphAttributes.normal, d = 0; d < l; d++) 0 !== (p = c[d])[1] && (u && r.removeAttribute("morphTarget" + d), h && r.removeAttribute("morphNormal" + d));
                    for (d = 0; d < l; d++)(p = c[d])[0] = d, p[1] = s[d];
                    c.sort(Ht);
                    for (d = 0; d < 8; d++) {
                        var p = c[d];
                        if (p) {
                            var f = p[0],
                                m = p[1];
                            if (m) {
                                u && r.addAttribute("morphTarget" + d, u[f]), h && r.addAttribute("morphNormal" + d, h[f]), i[d] = m;
                                continue
                            }
                        }
                        i[d] = 0
                    }
                    a.getUniforms().setValue(t, "morphTargetInfluences", i)
                }
            }
        }

        function Vt(t, e, i) {
            var n, r, o;
            this.setMode = function(t) {
                n = t
            }, this.setIndex = function(t) {
                r = t.type, o = t.bytesPerElement
            }, this.render = function(e, a) {
                t.drawElements(n, a, r, e * o), i.calls++, i.vertices += a, n === t.TRIANGLES ? i.faces += a / 3 : n === t.POINTS && (i.points += a)
            }, this.renderInstances = function(a, s, l) {
                var c = e.get("ANGLE_instanced_arrays");
                null !== c ? (c.drawElementsInstancedANGLE(n, l, r, s * o, a.maxInstancedCount), i.calls++, i.vertices += l * a.maxInstancedCount, n === t.TRIANGLES ? i.faces += a.maxInstancedCount * l / 3 : n === t.POINTS && (i.points += a.maxInstancedCount * l)) : console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.")
            }
        }

        function Wt(t, e, i) {
            var n;
            this.setMode = function(t) {
                n = t
            }, this.render = function(e, r) {
                t.drawArrays(n, e, r), i.calls++, i.vertices += r, n === t.TRIANGLES ? i.faces += r / 3 : n === t.POINTS && (i.points += r)
            }, this.renderInstances = function(r, o, a) {
                var s = e.get("ANGLE_instanced_arrays");
                if (null !== s) {
                    var l = r.attributes.position;
                    l.isInterleavedBufferAttribute ? (a = l.data.count, s.drawArraysInstancedANGLE(n, 0, a, r.maxInstancedCount)) : s.drawArraysInstancedANGLE(n, o, a, r.maxInstancedCount), i.calls++, i.vertices += a * r.maxInstancedCount, n === t.TRIANGLES ? i.faces += r.maxInstancedCount * a / 3 : n === t.POINTS && (i.points += r.maxInstancedCount * a)
                } else console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.")
            }
        }

        function Xt(t, e, i) {
            function n(t) {
                var a = t.target,
                    s = r[a.id];
                null !== s.index && e.remove(s.index);
                for (var l in s.attributes) e.remove(s.attributes[l]);
                a.removeEventListener("dispose", n), delete r[a.id];
                var c = o[a.id];
                c && (e.remove(c), delete o[a.id]), (c = o[s.id]) && (e.remove(c), delete o[s.id]), i.geometries--
            }
            var r = {},
                o = {};
            return {
                get: function(t, e) {
                    var o = r[e.id];
                    return o || (e.addEventListener("dispose", n), e.isBufferGeometry ? o = e : e.isGeometry && (void 0 === e._bufferGeometry && (e._bufferGeometry = (new Mt).setFromObject(t)), o = e._bufferGeometry), r[e.id] = o, i.geometries++, o)
                },
                update: function(i) {
                    var n = i.index,
                        r = i.attributes;
                    null !== n && e.update(n, t.ELEMENT_ARRAY_BUFFER);
                    for (var o in r) e.update(r[o], t.ARRAY_BUFFER);
                    var a = i.morphAttributes;
                    for (var o in a)
                        for (var s = a[o], l = 0, c = s.length; l < c; l++) e.update(s[l], t.ARRAY_BUFFER)
                },
                getWireframeAttribute: function(i) {
                    var n = o[i.id];
                    if (n) return n;
                    var r = [],
                        a = i.index,
                        s = i.attributes;
                    if (null !== a)
                        for (var l = 0, c = (p = a.array).length; l < c; l += 3) {
                            var u = p[l + 0],
                                h = p[l + 1],
                                d = p[l + 2];
                            r.push(u, h, h, d, d, u)
                        } else
                            for (var p = s.position.array, l = 0, c = p.length / 3 - 1; l < c; l += 3) {
                                var u = l + 0,
                                    h = l + 1,
                                    d = l + 2;
                                r.push(u, h, h, d, d, u)
                            }
                    return n = new(Et(r) > 65535 ? bt : _t)(r, 1), e.update(n, t.ELEMENT_ARRAY_BUFFER), o[i.id] = n, n
                }
            }
        }

        function qt() {
            var t = {};
            return {
                get: function(e) {
                    if (void 0 !== t[e.id]) return t[e.id];
                    var n;
                    switch (e.type) {
                        case "DirectionalLight":
                            n = {
                                direction: new o,
                                color: new q,
                                shadow: !1,
                                shadowBias: 0,
                                shadowRadius: 1,
                                shadowMapSize: new i
                            };
                            break;
                        case "SpotLight":
                            n = {
                                position: new o,
                                direction: new o,
                                color: new q,
                                distance: 0,
                                coneCos: 0,
                                penumbraCos: 0,
                                decay: 0,
                                shadow: !1,
                                shadowBias: 0,
                                shadowRadius: 1,
                                shadowMapSize: new i
                            };
                            break;
                        case "PointLight":
                            n = {
                                position: new o,
                                color: new q,
                                distance: 0,
                                decay: 0,
                                shadow: !1,
                                shadowBias: 0,
                                shadowRadius: 1,
                                shadowMapSize: new i,
                                shadowCameraNear: 1,
                                shadowCameraFar: 1e3
                            };
                            break;
                        case "HemisphereLight":
                            n = {
                                direction: new o,
                                skyColor: new q,
                                groundColor: new q
                            };
                            break;
                        case "RectAreaLight":
                            n = {
                                color: new q,
                                position: new o,
                                halfWidth: new o,
                                halfHeight: new o
                            }
                    }
                    return t[e.id] = n, n
                }
            }
        }

        function Yt() {
            var t = new qt,
                e = {
                    hash: "",
                    ambient: [0, 0, 0],
                    directional: [],
                    directionalShadowMap: [],
                    directionalShadowMatrix: [],
                    spot: [],
                    spotShadowMap: [],
                    spotShadowMatrix: [],
                    rectArea: [],
                    point: [],
                    pointShadowMap: [],
                    pointShadowMatrix: [],
                    hemi: []
                },
                i = new o,
                r = new n,
                a = new n;
            return {
                setup: function(n, o, s) {
                    for (var l = 0, c = 0, u = 0, h = 0, d = 0, p = 0, f = 0, m = 0, g = s.matrixWorldInverse, v = 0, y = n.length; v < y; v++) {
                        var _ = n[v],
                            x = _.color,
                            b = _.intensity,
                            w = _.distance,
                            T = _.shadow && _.shadow.map ? _.shadow.map.texture : null;
                        if (_.isAmbientLight) l += x.r * b, c += x.g * b, u += x.b * b;
                        else if (_.isDirectionalLight)(E = t.get(_)).color.copy(_.color).multiplyScalar(_.intensity), E.direction.setFromMatrixPosition(_.matrixWorld), i.setFromMatrixPosition(_.target.matrixWorld), E.direction.sub(i), E.direction.transformDirection(g), E.shadow = _.castShadow, _.castShadow && (S = _.shadow, E.shadowBias = S.bias, E.shadowRadius = S.radius, E.shadowMapSize = S.mapSize), e.directionalShadowMap[h] = T, e.directionalShadowMatrix[h] = _.shadow.matrix, e.directional[h] = E, h++;
                        else if (_.isSpotLight)(E = t.get(_)).position.setFromMatrixPosition(_.matrixWorld), E.position.applyMatrix4(g), E.color.copy(x).multiplyScalar(b), E.distance = w, E.direction.setFromMatrixPosition(_.matrixWorld), i.setFromMatrixPosition(_.target.matrixWorld), E.direction.sub(i), E.direction.transformDirection(g), E.coneCos = Math.cos(_.angle), E.penumbraCos = Math.cos(_.angle * (1 - _.penumbra)), E.decay = 0 === _.distance ? 0 : _.decay, E.shadow = _.castShadow, _.castShadow && (S = _.shadow, E.shadowBias = S.bias, E.shadowRadius = S.radius, E.shadowMapSize = S.mapSize), e.spotShadowMap[p] = T, e.spotShadowMatrix[p] = _.shadow.matrix, e.spot[p] = E, p++;
                        else if (_.isRectAreaLight)(E = t.get(_)).color.copy(x).multiplyScalar(b / (_.width * _.height)), E.position.setFromMatrixPosition(_.matrixWorld), E.position.applyMatrix4(g), a.identity(), r.copy(_.matrixWorld), r.premultiply(g), a.extractRotation(r), E.halfWidth.set(.5 * _.width, 0, 0), E.halfHeight.set(0, .5 * _.height, 0), E.halfWidth.applyMatrix4(a), E.halfHeight.applyMatrix4(a), e.rectArea[f] = E, f++;
                        else if (_.isPointLight) {
                            if ((E = t.get(_)).position.setFromMatrixPosition(_.matrixWorld), E.position.applyMatrix4(g), E.color.copy(_.color).multiplyScalar(_.intensity), E.distance = _.distance, E.decay = 0 === _.distance ? 0 : _.decay, E.shadow = _.castShadow, _.castShadow) {
                                var S = _.shadow;
                                E.shadowBias = S.bias, E.shadowRadius = S.radius, E.shadowMapSize = S.mapSize, E.shadowCameraNear = S.camera.near, E.shadowCameraFar = S.camera.far
                            }
                            e.pointShadowMap[d] = T, e.pointShadowMatrix[d] = _.shadow.matrix, e.point[d] = E, d++
                        } else if (_.isHemisphereLight) {
                            var E = t.get(_);
                            E.direction.setFromMatrixPosition(_.matrixWorld), E.direction.transformDirection(g), E.direction.normalize(), E.skyColor.copy(_.color).multiplyScalar(b), E.groundColor.copy(_.groundColor).multiplyScalar(b), e.hemi[m] = E, m++
                        }
                    }
                    e.ambient[0] = l, e.ambient[1] = c, e.ambient[2] = u, e.directional.length = h, e.spot.length = p, e.rectArea.length = f, e.point.length = d, e.hemi.length = m, e.hash = h + "," + d + "," + p + "," + f + "," + m + "," + o.length
                },
                state: e
            }
        }

        function Qt(t, e) {
            var i = {};
            return {
                update: function(n) {
                    var r = e.frame,
                        o = n.geometry,
                        a = t.get(n, o);
                    return i[a.id] !== r && (o.isGeometry && a.updateFromObject(n), t.update(a), i[a.id] = r), a
                },
                clear: function() {
                    i = {}
                }
            }
        }

        function Zt(t) {
            for (var e = t.split("\n"), i = 0; i < e.length; i++) e[i] = i + 1 + ": " + e[i];
            return e.join("\n")
        }

        function Jt(t, e, i) {
            var n = t.createShader(e);
            return t.shaderSource(n, i), t.compileShader(n), !1 === t.getShaderParameter(n, t.COMPILE_STATUS) && console.error("THREE.WebGLShader: Shader couldn't compile."), "" !== t.getShaderInfoLog(n) && console.warn("THREE.WebGLShader: gl.getShaderInfoLog()", e === t.VERTEX_SHADER ? "vertex" : "fragment", t.getShaderInfoLog(n), Zt(i)), n
        }

        function $t(t) {
            switch (t) {
                case Ia:
                    return ["Linear", "( value )"];
                case Da:
                    return ["sRGB", "( value )"];
                case Fa:
                    return ["RGBE", "( value )"];
                case ka:
                    return ["RGBM", "( value, 7.0 )"];
                case Ua:
                    return ["RGBM", "( value, 16.0 )"];
                case Ba:
                    return ["RGBD", "( value, 256.0 )"];
                case Na:
                    return ["Gamma", "( value, float( GAMMA_FACTOR ) )"];
                default:
                    throw new Error("unsupported encoding: " + t)
            }
        }

        function Kt(t, e) {
            var i = $t(e);
            return "vec4 " + t + "( vec4 value ) { return " + i[0] + "ToLinear" + i[1] + "; }"
        }

        function te(t, e) {
            var i = $t(e);
            return "vec4 " + t + "( vec4 value ) { return LinearTo" + i[0] + i[1] + "; }"
        }

        function ee(t, e) {
            var i;
            switch (e) {
                case Io:
                    i = "Linear";
                    break;
                case Do:
                    i = "Reinhard";
                    break;
                case No:
                    i = "Uncharted2";
                    break;
                case Fo:
                    i = "OptimizedCineon";
                    break;
                default:
                    throw new Error("unsupported toneMapping: " + e)
            }
            return "vec3 " + t + "( vec3 color ) { return " + i + "ToneMapping( color ); }"
        }

        function ie(t, e, i) {
            return [(t = t || {}).derivatives || e.envMapCubeUV || e.bumpMap || e.normalMap || e.flatShading ? "#extension GL_OES_standard_derivatives : enable" : "", (t.fragDepth || e.logarithmicDepthBuffer) && i.get("EXT_frag_depth") ? "#extension GL_EXT_frag_depth : enable" : "", t.drawBuffers && i.get("WEBGL_draw_buffers") ? "#extension GL_EXT_draw_buffers : require" : "", (t.shaderTextureLOD || e.envMap) && i.get("EXT_shader_texture_lod") ? "#extension GL_EXT_shader_texture_lod : enable" : ""].filter(oe).join("\n")
        }

        function ne(t) {
            var e = [];
            for (var i in t) {
                var n = t[i];
                !1 !== n && e.push("#define " + i + " " + n)
            }
            return e.join("\n")
        }

        function re(t, e) {
            for (var i = {}, n = t.getProgramParameter(e, t.ACTIVE_ATTRIBUTES), r = 0; r < n; r++) {
                var o = t.getActiveAttrib(e, r).name;
                i[o] = t.getAttribLocation(e, o)
            }
            return i
        }

        function oe(t) {
            return "" !== t
        }

        function ae(t, e) {
            return t.replace(/NUM_DIR_LIGHTS/g, e.numDirLights).replace(/NUM_SPOT_LIGHTS/g, e.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g, e.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, e.numPointLights).replace(/NUM_HEMI_LIGHTS/g, e.numHemiLights)
        }

        function se(t) {
            var e = /^[ \t]*#include +<([\w\d.]+)>/gm;
            return t.replace(e, function(t, e) {
                var i = ts[e];
                if (void 0 === i) throw new Error("Can not resolve #include <" + e + ">");
                return se(i)
            })
        }

        function le(t) {
            var e = /for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g;
            return t.replace(e, function(t, e, i, n) {
                for (var r = "", o = parseInt(e); o < parseInt(i); o++) r += n.replace(/\[ i \]/g, "[ " + o + " ]");
                return r
            })
        }

        function ce(t, e, i, n, r, o) {
            var a = t.context,
                s = n.defines,
                l = r.vertexShader,
                c = r.fragmentShader,
                u = "SHADOWMAP_TYPE_BASIC";
            o.shadowMapType === Vr ? u = "SHADOWMAP_TYPE_PCF" : o.shadowMapType === Wr && (u = "SHADOWMAP_TYPE_PCF_SOFT");
            var h = "ENVMAP_TYPE_CUBE",
                d = "ENVMAP_MODE_REFLECTION",
                p = "ENVMAP_BLENDING_MULTIPLY";
            if (o.envMap) {
                switch (n.envMap.mapping) {
                    case ko:
                    case Uo:
                        h = "ENVMAP_TYPE_CUBE";
                        break;
                    case Ho:
                    case Go:
                        h = "ENVMAP_TYPE_CUBE_UV";
                        break;
                    case Bo:
                    case zo:
                        h = "ENVMAP_TYPE_EQUIREC";
                        break;
                    case jo:
                        h = "ENVMAP_TYPE_SPHERE"
                }
                switch (n.envMap.mapping) {
                    case Uo:
                    case zo:
                        d = "ENVMAP_MODE_REFRACTION"
                }
                switch (n.combine) {
                    case Co:
                        p = "ENVMAP_BLENDING_MULTIPLY";
                        break;
                    case Po:
                        p = "ENVMAP_BLENDING_MIX";
                        break;
                    case Ro:
                        p = "ENVMAP_BLENDING_ADD"
                }
            }
            var f, m, g = t.gammaFactor > 0 ? t.gammaFactor : 1,
                v = ie(n.extensions, o, e),
                y = ne(s),
                _ = a.createProgram();
            n.isRawShaderMaterial ? ((f = [y].filter(oe).join("\n")).length > 0 && (f += "\n"), (m = [v, y].filter(oe).join("\n")).length > 0 && (m += "\n")) : (f = ["precision " + o.precision + " float;", "precision " + o.precision + " int;", "#define SHADER_NAME " + r.name, y, o.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "", "#define GAMMA_FACTOR " + g, "#define MAX_BONES " + o.maxBones, o.useFog && o.fog ? "#define USE_FOG" : "", o.useFog && o.fogExp ? "#define FOG_EXP2" : "", o.map ? "#define USE_MAP" : "", o.envMap ? "#define USE_ENVMAP" : "", o.envMap ? "#define " + d : "", o.lightMap ? "#define USE_LIGHTMAP" : "", o.aoMap ? "#define USE_AOMAP" : "", o.emissiveMap ? "#define USE_EMISSIVEMAP" : "", o.bumpMap ? "#define USE_BUMPMAP" : "", o.normalMap ? "#define USE_NORMALMAP" : "", o.displacementMap && o.supportsVertexTextures ? "#define USE_DISPLACEMENTMAP" : "", o.specularMap ? "#define USE_SPECULARMAP" : "", o.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", o.metalnessMap ? "#define USE_METALNESSMAP" : "", o.alphaMap ? "#define USE_ALPHAMAP" : "", o.vertexColors ? "#define USE_COLOR" : "", o.flatShading ? "#define FLAT_SHADED" : "", o.skinning ? "#define USE_SKINNING" : "", o.useVertexTexture ? "#define BONE_TEXTURE" : "", o.morphTargets ? "#define USE_MORPHTARGETS" : "", o.morphNormals && !1 === o.flatShading ? "#define USE_MORPHNORMALS" : "", o.doubleSided ? "#define DOUBLE_SIDED" : "", o.flipSided ? "#define FLIP_SIDED" : "", "#define NUM_CLIPPING_PLANES " + o.numClippingPlanes, o.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", o.shadowMapEnabled ? "#define " + u : "", o.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "", o.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", o.logarithmicDepthBuffer && e.get("EXT_frag_depth") ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 modelMatrix;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;", "uniform mat3 normalMatrix;", "uniform vec3 cameraPosition;", "attribute vec3 position;", "attribute vec3 normal;", "attribute vec2 uv;", "#ifdef USE_COLOR", "\tattribute vec3 color;", "#endif", "#ifdef USE_MORPHTARGETS", "\tattribute vec3 morphTarget0;", "\tattribute vec3 morphTarget1;", "\tattribute vec3 morphTarget2;", "\tattribute vec3 morphTarget3;", "\t#ifdef USE_MORPHNORMALS", "\t\tattribute vec3 morphNormal0;", "\t\tattribute vec3 morphNormal1;", "\t\tattribute vec3 morphNormal2;", "\t\tattribute vec3 morphNormal3;", "\t#else", "\t\tattribute vec3 morphTarget4;", "\t\tattribute vec3 morphTarget5;", "\t\tattribute vec3 morphTarget6;", "\t\tattribute vec3 morphTarget7;", "\t#endif", "#endif", "#ifdef USE_SKINNING", "\tattribute vec4 skinIndex;", "\tattribute vec4 skinWeight;", "#endif", "\n"].filter(oe).join("\n"), m = [v, "precision " + o.precision + " float;", "precision " + o.precision + " int;", "#define SHADER_NAME " + r.name, y, o.alphaTest ? "#define ALPHATEST " + o.alphaTest : "", "#define GAMMA_FACTOR " + g, o.useFog && o.fog ? "#define USE_FOG" : "", o.useFog && o.fogExp ? "#define FOG_EXP2" : "", o.map ? "#define USE_MAP" : "", o.envMap ? "#define USE_ENVMAP" : "", o.envMap ? "#define " + h : "", o.envMap ? "#define " + d : "", o.envMap ? "#define " + p : "", o.lightMap ? "#define USE_LIGHTMAP" : "", o.aoMap ? "#define USE_AOMAP" : "", o.emissiveMap ? "#define USE_EMISSIVEMAP" : "", o.bumpMap ? "#define USE_BUMPMAP" : "", o.normalMap ? "#define USE_NORMALMAP" : "", o.specularMap ? "#define USE_SPECULARMAP" : "", o.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", o.metalnessMap ? "#define USE_METALNESSMAP" : "", o.alphaMap ? "#define USE_ALPHAMAP" : "", o.vertexColors ? "#define USE_COLOR" : "", o.gradientMap ? "#define USE_GRADIENTMAP" : "", o.flatShading ? "#define FLAT_SHADED" : "", o.doubleSided ? "#define DOUBLE_SIDED" : "", o.flipSided ? "#define FLIP_SIDED" : "", "#define NUM_CLIPPING_PLANES " + o.numClippingPlanes, "#define UNION_CLIPPING_PLANES " + (o.numClippingPlanes - o.numClipIntersection), o.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", o.shadowMapEnabled ? "#define " + u : "", o.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "", o.physicallyCorrectLights ? "#define PHYSICALLY_CORRECT_LIGHTS" : "", o.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", o.logarithmicDepthBuffer && e.get("EXT_frag_depth") ? "#define USE_LOGDEPTHBUF_EXT" : "", o.envMap && e.get("EXT_shader_texture_lod") ? "#define TEXTURE_LOD_EXT" : "", "uniform mat4 viewMatrix;", "uniform vec3 cameraPosition;", o.toneMapping !== Oo ? "#define TONE_MAPPING" : "", o.toneMapping !== Oo ? ts.tonemapping_pars_fragment : "", o.toneMapping !== Oo ? ee("toneMapping", o.toneMapping) : "", o.dithering ? "#define DITHERING" : "", o.outputEncoding || o.mapEncoding || o.envMapEncoding || o.emissiveMapEncoding ? ts.encodings_pars_fragment : "", o.mapEncoding ? Kt("mapTexelToLinear", o.mapEncoding) : "", o.envMapEncoding ? Kt("envMapTexelToLinear", o.envMapEncoding) : "", o.emissiveMapEncoding ? Kt("emissiveMapTexelToLinear", o.emissiveMapEncoding) : "", o.outputEncoding ? te("linearToOutputTexel", o.outputEncoding) : "", o.depthPacking ? "#define DEPTH_PACKING " + n.depthPacking : "", "\n"].filter(oe).join("\n")), l = ae(l = se(l), o), c = ae(c = se(c), o), n.isShaderMaterial || (l = le(l), c = le(c));
            var x = f + l,
                b = m + c,
                w = Jt(a, a.VERTEX_SHADER, x),
                T = Jt(a, a.FRAGMENT_SHADER, b);
            a.attachShader(_, w), a.attachShader(_, T), void 0 !== n.index0AttributeName ? a.bindAttribLocation(_, 0, n.index0AttributeName) : !0 === o.morphTargets && a.bindAttribLocation(_, 0, "position"), a.linkProgram(_);
            var S = a.getProgramInfoLog(_),
                E = a.getShaderInfoLog(w),
                M = a.getShaderInfoLog(T),
                A = !0,
                L = !0;
            !1 === a.getProgramParameter(_, a.LINK_STATUS) ? (A = !1, console.error("THREE.WebGLProgram: shader error: ", a.getError(), "gl.VALIDATE_STATUS", a.getProgramParameter(_, a.VALIDATE_STATUS), "gl.getProgramInfoLog", S, E, M)) : "" !== S ? console.warn("THREE.WebGLProgram: gl.getProgramInfoLog()", S) : "" !== E && "" !== M || (L = !1), L && (this.diagnostics = {
                runnable: A,
                material: n,
                programLog: S,
                vertexShader: {
                    log: E,
                    prefix: f
                },
                fragmentShader: {
                    log: M,
                    prefix: m
                }
            }), a.deleteShader(w), a.deleteShader(T);
            var C;
            this.getUniforms = function() {
                return void 0 === C && (C = new X(a, _, t)), C
            };
            var P;
            return this.getAttributes = function() {
                return void 0 === P && (P = re(a, _)), P
            }, this.destroy = function() {
                a.deleteProgram(_), this.program = void 0
            }, Object.defineProperties(this, {
                uniforms: {
                    get: function() {
                        return console.warn("THREE.WebGLProgram: .uniforms is now .getUniforms()."), this.getUniforms()
                    }
                },
                attributes: {
                    get: function() {
                        return console.warn("THREE.WebGLProgram: .attributes is now .getAttributes()."), this.getAttributes()
                    }
                }
            }), this.id = as++, this.code = i, this.usedTimes = 1, this.program = _, this.vertexShader = w, this.fragmentShader = T, this
        }

        function ue(t, e, i) {
            function n(t) {
                var e = t.skeleton.bones;
                if (i.floatVertexTextures) return 1024;
                var n = i.maxVertexUniforms,
                    r = Math.floor((n - 20) / 4),
                    o = Math.min(r, e.length);
                return o < e.length ? (console.warn("THREE.WebGLRenderer: Skeleton has " + e.length + " bones. This GPU supports " + o + "."), 0) : o
            }

            function r(t, e) {
                var i;
                return t ? t.isTexture ? i = t.encoding : t.isWebGLRenderTarget && (console.warn("THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead."), i = t.texture.encoding) : i = Ia, i === Ia && e && (i = Na), i
            }
            var o = [],
                a = {
                    MeshDepthMaterial: "depth",
                    MeshDistanceMaterial: "distanceRGBA",
                    MeshNormalMaterial: "normal",
                    MeshBasicMaterial: "basic",
                    MeshLambertMaterial: "lambert",
                    MeshPhongMaterial: "phong",
                    MeshToonMaterial: "phong",
                    MeshStandardMaterial: "physical",
                    MeshPhysicalMaterial: "physical",
                    LineBasicMaterial: "basic",
                    LineDashedMaterial: "dashed",
                    PointsMaterial: "points",
                    ShadowMaterial: "shadow"
                },
                s = ["precision", "supportsVertexTextures", "map", "mapEncoding", "envMap", "envMapMode", "envMapEncoding", "lightMap", "aoMap", "emissiveMap", "emissiveMapEncoding", "bumpMap", "normalMap", "displacementMap", "specularMap", "roughnessMap", "metalnessMap", "gradientMap", "alphaMap", "combine", "vertexColors", "fog", "useFog", "fogExp", "flatShading", "sizeAttenuation", "logarithmicDepthBuffer", "skinning", "maxBones", "useVertexTexture", "morphTargets", "morphNormals", "maxMorphTargets", "maxMorphNormals", "premultipliedAlpha", "numDirLights", "numPointLights", "numSpotLights", "numHemiLights", "numRectAreaLights", "shadowMapEnabled", "shadowMapType", "toneMapping", "physicallyCorrectLights", "alphaTest", "doubleSided", "flipSided", "numClippingPlanes", "numClipIntersection", "depthPacking", "dithering"];
            this.getParameters = function(e, o, s, l, c, u, h) {
                var d = a[e.type],
                    p = h.isSkinnedMesh ? n(h) : 0,
                    f = i.precision;
                null !== e.precision && (f = i.getMaxPrecision(e.precision)) !== e.precision && console.warn("THREE.WebGLProgram.getParameters:", e.precision, "not supported, using", f, "instead.");
                var m = t.getRenderTarget();
                return {
                    shaderID: d,
                    precision: f,
                    supportsVertexTextures: i.vertexTextures,
                    outputEncoding: r(m ? m.texture : null, t.gammaOutput),
                    map: !!e.map,
                    mapEncoding: r(e.map, t.gammaInput),
                    envMap: !!e.envMap,
                    envMapMode: e.envMap && e.envMap.mapping,
                    envMapEncoding: r(e.envMap, t.gammaInput),
                    envMapCubeUV: !!e.envMap && (e.envMap.mapping === Ho || e.envMap.mapping === Go),
                    lightMap: !!e.lightMap,
                    aoMap: !!e.aoMap,
                    emissiveMap: !!e.emissiveMap,
                    emissiveMapEncoding: r(e.emissiveMap, t.gammaInput),
                    bumpMap: !!e.bumpMap,
                    normalMap: !!e.normalMap,
                    displacementMap: !!e.displacementMap,
                    roughnessMap: !!e.roughnessMap,
                    metalnessMap: !!e.metalnessMap,
                    specularMap: !!e.specularMap,
                    alphaMap: !!e.alphaMap,
                    gradientMap: !!e.gradientMap,
                    combine: e.combine,
                    vertexColors: e.vertexColors,
                    fog: !!l,
                    useFog: e.fog,
                    fogExp: l && l.isFogExp2,
                    flatShading: e.flatShading,
                    sizeAttenuation: e.sizeAttenuation,
                    logarithmicDepthBuffer: i.logarithmicDepthBuffer,
                    skinning: e.skinning && p > 0,
                    maxBones: p,
                    useVertexTexture: i.floatVertexTextures,
                    morphTargets: e.morphTargets,
                    morphNormals: e.morphNormals,
                    maxMorphTargets: t.maxMorphTargets,
                    maxMorphNormals: t.maxMorphNormals,
                    numDirLights: o.directional.length,
                    numPointLights: o.point.length,
                    numSpotLights: o.spot.length,
                    numRectAreaLights: o.rectArea.length,
                    numHemiLights: o.hemi.length,
                    numClippingPlanes: c,
                    numClipIntersection: u,
                    dithering: e.dithering,
                    shadowMapEnabled: t.shadowMap.enabled && h.receiveShadow && s.length > 0,
                    shadowMapType: t.shadowMap.type,
                    toneMapping: t.toneMapping,
                    physicallyCorrectLights: t.physicallyCorrectLights,
                    premultipliedAlpha: e.premultipliedAlpha,
                    alphaTest: e.alphaTest,
                    doubleSided: e.side === Yr,
                    flipSided: e.side === qr,
                    depthPacking: void 0 !== e.depthPacking && e.depthPacking
                }
            }, this.getProgramCode = function(e, i) {
                var n = [];
                if (i.shaderID ? n.push(i.shaderID) : (n.push(e.fragmentShader), n.push(e.vertexShader)), void 0 !== e.defines)
                    for (var r in e.defines) n.push(r), n.push(e.defines[r]);
                for (var o = 0; o < s.length; o++) n.push(i[s[o]]);
                return n.push(e.onBeforeCompile.toString()), n.push(t.gammaOutput), n.join()
            }, this.acquireProgram = function(i, n, r, a) {
                for (var s, l = 0, c = o.length; l < c; l++) {
                    var u = o[l];
                    if (u.code === a) {
                        ++(s = u).usedTimes;
                        break
                    }
                }
                return void 0 === s && (s = new ce(t, e, a, i, n, r), o.push(s)), s
            }, this.releaseProgram = function(t) {
                if (0 == --t.usedTimes) {
                    var e = o.indexOf(t);
                    o[e] = o[o.length - 1], o.pop(), t.destroy()
                }
            }, this.programs = o
        }

        function he(t, e, i, n, r, o, a) {
            function s(t, e) {
                if (t.width > e || t.height > e) {
                    var i = e / Math.max(t.width, t.height),
                        n = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas");
                    return n.width = Math.floor(t.width * i), n.height = Math.floor(t.height * i), n.getContext("2d").drawImage(t, 0, 0, t.width, t.height, 0, 0, n.width, n.height), console.warn("THREE.WebGLRenderer: image is too big (" + t.width + "x" + t.height + "). Resized to " + n.width + "x" + n.height, t), n
                }
                return t
            }

            function l(t) {
                return Ha.isPowerOfTwo(t.width) && Ha.isPowerOfTwo(t.height)
            }

            function c(t) {
                if (t instanceof HTMLImageElement || t instanceof HTMLCanvasElement || t instanceof ImageBitmap) {
                    var e = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas");
                    return e.width = Ha.floorPowerOfTwo(t.width), e.height = Ha.floorPowerOfTwo(t.height), e.getContext("2d").drawImage(t, 0, 0, e.width, e.height), console.warn("THREE.WebGLRenderer: image is not power of two (" + t.width + "x" + t.height + "). Resized to " + e.width + "x" + e.height, t), e
                }
                return t
            }

            function u(t) {
                return t.wrapS !== Wo || t.wrapT !== Wo || t.minFilter !== qo && t.minFilter !== Zo
            }

            function h(t, e) {
                return t.generateMipmaps && e && t.minFilter !== qo && t.minFilter !== Zo
            }

            function d(e) {
                return e === qo || e === Yo || e === Qo ? t.NEAREST : t.LINEAR
            }

            function p(t) {
                var e = t.target;
                e.removeEventListener("dispose", p), m(e), a.textures--
            }

            function f(t) {
                var e = t.target;
                e.removeEventListener("dispose", f), g(e), a.textures--
            }

            function m(e) {
                var i = n.get(e);
                if (e.image && i.__image__webglTextureCube) t.deleteTexture(i.__image__webglTextureCube);
                else {
                    if (void 0 === i.__webglInit) return;
                    t.deleteTexture(i.__webglTexture)
                }
                n.remove(e)
            }

            function g(e) {
                var i = n.get(e),
                    r = n.get(e.texture);
                if (e) {
                    if (void 0 !== r.__webglTexture && t.deleteTexture(r.__webglTexture), e.depthTexture && e.depthTexture.dispose(), e.isWebGLRenderTargetCube)
                        for (var o = 0; o < 6; o++) t.deleteFramebuffer(i.__webglFramebuffer[o]), i.__webglDepthbuffer && t.deleteRenderbuffer(i.__webglDepthbuffer[o]);
                    else t.deleteFramebuffer(i.__webglFramebuffer), i.__webglDepthbuffer && t.deleteRenderbuffer(i.__webglDepthbuffer);
                    n.remove(e.texture), n.remove(e)
                }
            }

            function v(e, r) {
                var o = n.get(e);
                if (e.version > 0 && o.__version !== e.version) {
                    var a = e.image;
                    if (void 0 === a) console.warn("THREE.WebGLRenderer: Texture marked for update but image is undefined", e);
                    else {
                        if (!1 !== a.complete) return void _(o, e, r);
                        console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete", e)
                    }
                }
                i.activeTexture(t.TEXTURE0 + r), i.bindTexture(t.TEXTURE_2D, o.__webglTexture)
            }

            function y(i, a, s) {
                var l;
                if (s ? (t.texParameteri(i, t.TEXTURE_WRAP_S, o.convert(a.wrapS)), t.texParameteri(i, t.TEXTURE_WRAP_T, o.convert(a.wrapT)), t.texParameteri(i, t.TEXTURE_MAG_FILTER, o.convert(a.magFilter)), t.texParameteri(i, t.TEXTURE_MIN_FILTER, o.convert(a.minFilter))) : (t.texParameteri(i, t.TEXTURE_WRAP_S, t.CLAMP_TO_EDGE), t.texParameteri(i, t.TEXTURE_WRAP_T, t.CLAMP_TO_EDGE), a.wrapS === Wo && a.wrapT === Wo || console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping.", a), t.texParameteri(i, t.TEXTURE_MAG_FILTER, d(a.magFilter)), t.texParameteri(i, t.TEXTURE_MIN_FILTER, d(a.minFilter)), a.minFilter !== qo && a.minFilter !== Zo && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.", a)), l = e.get("EXT_texture_filter_anisotropic")) {
                    if (a.type === oa && null === e.get("OES_texture_float_linear")) return;
                    if (a.type === aa && null === e.get("OES_texture_half_float_linear")) return;
                    (a.anisotropy > 1 || n.get(a).__currentAnisotropy) && (t.texParameterf(i, l.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(a.anisotropy, r.getMaxAnisotropy())), n.get(a).__currentAnisotropy = a.anisotropy)
                }
            }

            function _(e, n, d) {
                void 0 === e.__webglInit && (e.__webglInit = !0, n.addEventListener("dispose", p), e.__webglTexture = t.createTexture(), a.textures++), i.activeTexture(t.TEXTURE0 + d), i.bindTexture(t.TEXTURE_2D, e.__webglTexture), t.pixelStorei(t.UNPACK_FLIP_Y_WEBGL, n.flipY), t.pixelStorei(t.UNPACK_PREMULTIPLY_ALPHA_WEBGL, n.premultiplyAlpha), t.pixelStorei(t.UNPACK_ALIGNMENT, n.unpackAlignment);
                var f = s(n.image, r.maxTextureSize);
                u(n) && !1 === l(f) && (f = c(f));
                var m = l(f),
                    g = o.convert(n.format),
                    v = o.convert(n.type);
                y(t.TEXTURE_2D, n, m);
                var _, x = n.mipmaps;
                if (n.isDepthTexture) {
                    var b = t.DEPTH_COMPONENT;
                    if (n.type === oa) {
                        if (!S) throw new Error("Float Depth Texture only supported in WebGL2.0");
                        b = t.DEPTH_COMPONENT32F
                    } else S && (b = t.DEPTH_COMPONENT16);
                    n.format === va && b === t.DEPTH_COMPONENT && n.type !== ia && n.type !== ra && (console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."), n.type = ia, v = o.convert(n.type)), n.format === ya && (b = t.DEPTH_STENCIL, n.type !== ua && (console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."), n.type = ua, v = o.convert(n.type))), i.texImage2D(t.TEXTURE_2D, 0, b, f.width, f.height, 0, g, v, null)
                } else if (n.isDataTexture)
                    if (x.length > 0 && m) {
                        for (var w = 0, T = x.length; w < T; w++) _ = x[w], i.texImage2D(t.TEXTURE_2D, w, g, _.width, _.height, 0, g, v, _.data);
                        n.generateMipmaps = !1
                    } else i.texImage2D(t.TEXTURE_2D, 0, g, f.width, f.height, 0, g, v, f.data);
                else if (n.isCompressedTexture)
                    for (var w = 0, T = x.length; w < T; w++) _ = x[w], n.format !== pa && n.format !== da ? i.getCompressedTextureFormats().indexOf(g) > -1 ? i.compressedTexImage2D(t.TEXTURE_2D, w, g, _.width, _.height, 0, _.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : i.texImage2D(t.TEXTURE_2D, w, g, _.width, _.height, 0, g, v, _.data);
                else if (x.length > 0 && m) {
                    for (var w = 0, T = x.length; w < T; w++) _ = x[w], i.texImage2D(t.TEXTURE_2D, w, g, g, v, _);
                    n.generateMipmaps = !1
                } else i.texImage2D(t.TEXTURE_2D, 0, g, g, v, f);
                h(n, m) && t.generateMipmap(t.TEXTURE_2D), e.__version = n.version, n.onUpdate && n.onUpdate(n)
            }

            function x(e, r, a, s) {
                var l = o.convert(r.texture.format),
                    c = o.convert(r.texture.type);
                i.texImage2D(s, 0, l, r.width, r.height, 0, l, c, null), t.bindFramebuffer(t.FRAMEBUFFER, e), t.framebufferTexture2D(t.FRAMEBUFFER, a, s, n.get(r.texture).__webglTexture, 0), t.bindFramebuffer(t.FRAMEBUFFER, null)
            }

            function b(e, i) {
                t.bindRenderbuffer(t.RENDERBUFFER, e), i.depthBuffer && !i.stencilBuffer ? (t.renderbufferStorage(t.RENDERBUFFER, t.DEPTH_COMPONENT16, i.width, i.height), t.framebufferRenderbuffer(t.FRAMEBUFFER, t.DEPTH_ATTACHMENT, t.RENDERBUFFER, e)) : i.depthBuffer && i.stencilBuffer ? (t.renderbufferStorage(t.RENDERBUFFER, t.DEPTH_STENCIL, i.width, i.height), t.framebufferRenderbuffer(t.FRAMEBUFFER, t.DEPTH_STENCIL_ATTACHMENT, t.RENDERBUFFER, e)) : t.renderbufferStorage(t.RENDERBUFFER, t.RGBA4, i.width, i.height), t.bindRenderbuffer(t.RENDERBUFFER, null)
            }

            function w(e, i) {
                if (i && i.isWebGLRenderTargetCube) throw new Error("Depth Texture with cube render targets is not supported");
                if (t.bindFramebuffer(t.FRAMEBUFFER, e), !i.depthTexture || !i.depthTexture.isDepthTexture) throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
                n.get(i.depthTexture).__webglTexture && i.depthTexture.image.width === i.width && i.depthTexture.image.height === i.height || (i.depthTexture.image.width = i.width, i.depthTexture.image.height = i.height, i.depthTexture.needsUpdate = !0), v(i.depthTexture, 0);
                var r = n.get(i.depthTexture).__webglTexture;
                if (i.depthTexture.format === va) t.framebufferTexture2D(t.FRAMEBUFFER, t.DEPTH_ATTACHMENT, t.TEXTURE_2D, r, 0);
                else {
                    if (i.depthTexture.format !== ya) throw new Error("Unknown depthTexture format");
                    t.framebufferTexture2D(t.FRAMEBUFFER, t.DEPTH_STENCIL_ATTACHMENT, t.TEXTURE_2D, r, 0)
                }
            }

            function T(e) {
                var i = n.get(e),
                    r = !0 === e.isWebGLRenderTargetCube;
                if (e.depthTexture) {
                    if (r) throw new Error("target.depthTexture not supported in Cube render targets");
                    w(i.__webglFramebuffer, e)
                } else if (r) {
                    i.__webglDepthbuffer = [];
                    for (var o = 0; o < 6; o++) t.bindFramebuffer(t.FRAMEBUFFER, i.__webglFramebuffer[o]), i.__webglDepthbuffer[o] = t.createRenderbuffer(), b(i.__webglDepthbuffer[o], e)
                } else t.bindFramebuffer(t.FRAMEBUFFER, i.__webglFramebuffer), i.__webglDepthbuffer = t.createRenderbuffer(), b(i.__webglDepthbuffer, e);
                t.bindFramebuffer(t.FRAMEBUFFER, null)
            }
            var S = "undefined" != typeof WebGL2RenderingContext && t instanceof window.WebGL2RenderingContext;
            this.setTexture2D = v, this.setTextureCube = function(e, c) {
                var u = n.get(e);
                if (6 === e.image.length)
                    if (e.version > 0 && u.__version !== e.version) {
                        u.__image__webglTextureCube || (e.addEventListener("dispose", p), u.__image__webglTextureCube = t.createTexture(), a.textures++), i.activeTexture(t.TEXTURE0 + c), i.bindTexture(t.TEXTURE_CUBE_MAP, u.__image__webglTextureCube), t.pixelStorei(t.UNPACK_FLIP_Y_WEBGL, e.flipY);
                        for (var d = e && e.isCompressedTexture, f = e.image[0] && e.image[0].isDataTexture, m = [], g = 0; g < 6; g++) m[g] = d || f ? f ? e.image[g].image : e.image[g] : s(e.image[g], r.maxCubemapSize);
                        var v = l(m[0]),
                            _ = o.convert(e.format),
                            x = o.convert(e.type);
                        for (y(t.TEXTURE_CUBE_MAP, e, v), g = 0; g < 6; g++)
                            if (d)
                                for (var b, w = m[g].mipmaps, T = 0, S = w.length; T < S; T++) b = w[T], e.format !== pa && e.format !== da ? i.getCompressedTextureFormats().indexOf(_) > -1 ? i.compressedTexImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + g, T, _, b.width, b.height, 0, b.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : i.texImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + g, T, _, b.width, b.height, 0, _, x, b.data);
                            else f ? i.texImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + g, 0, _, m[g].width, m[g].height, 0, _, x, m[g].data) : i.texImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + g, 0, _, _, x, m[g]);
                        h(e, v) && t.generateMipmap(t.TEXTURE_CUBE_MAP), u.__version = e.version, e.onUpdate && e.onUpdate(e)
                    } else i.activeTexture(t.TEXTURE0 + c), i.bindTexture(t.TEXTURE_CUBE_MAP, u.__image__webglTextureCube)
            }, this.setTextureCubeDynamic = function(e, r) {
                i.activeTexture(t.TEXTURE0 + r), i.bindTexture(t.TEXTURE_CUBE_MAP, n.get(e).__webglTexture)
            }, this.setupRenderTarget = function(e) {
                var r = n.get(e),
                    o = n.get(e.texture);
                e.addEventListener("dispose", f), o.__webglTexture = t.createTexture(), a.textures++;
                var s = !0 === e.isWebGLRenderTargetCube,
                    c = l(e);
                if (s)
                    for (r.__webglFramebuffer = [], u = 0; u < 6; u++) r.__webglFramebuffer[u] = t.createFramebuffer();
                else r.__webglFramebuffer = t.createFramebuffer();
                if (s) {
                    i.bindTexture(t.TEXTURE_CUBE_MAP, o.__webglTexture), y(t.TEXTURE_CUBE_MAP, e.texture, c);
                    for (var u = 0; u < 6; u++) x(r.__webglFramebuffer[u], e, t.COLOR_ATTACHMENT0, t.TEXTURE_CUBE_MAP_POSITIVE_X + u);
                    h(e.texture, c) && t.generateMipmap(t.TEXTURE_CUBE_MAP), i.bindTexture(t.TEXTURE_CUBE_MAP, null)
                } else i.bindTexture(t.TEXTURE_2D, o.__webglTexture), y(t.TEXTURE_2D, e.texture, c), x(r.__webglFramebuffer, e, t.COLOR_ATTACHMENT0, t.TEXTURE_2D), h(e.texture, c) && t.generateMipmap(t.TEXTURE_2D), i.bindTexture(t.TEXTURE_2D, null);
                e.depthBuffer && T(e)
            }, this.updateRenderTargetMipmap = function(e) {
                var r = e.texture;
                if (h(r, l(e))) {
                    var o = e.isWebGLRenderTargetCube ? t.TEXTURE_CUBE_MAP : t.TEXTURE_2D,
                        a = n.get(r).__webglTexture;
                    i.bindTexture(o, a), t.generateMipmap(o), i.bindTexture(o, null)
                }
            }
        }

        function de() {
            var t = {};
            return {
                get: function(e) {
                    var i = e.uuid,
                        n = t[i];
                    return void 0 === n && (n = {}, t[i] = n), n
                },
                remove: function(e) {
                    delete t[e.uuid]
                },
                clear: function() {
                    t = {}
                }
            }
        }

        function pe(t, e, i) {
            function n(e, i, n) {
                var r = new Uint8Array(4),
                    o = t.createTexture();
                t.bindTexture(e, o), t.texParameteri(e, t.TEXTURE_MIN_FILTER, t.NEAREST), t.texParameteri(e, t.TEXTURE_MAG_FILTER, t.NEAREST);
                for (var a = 0; a < n; a++) t.texImage2D(i + a, 0, t.RGBA, 1, 1, 0, t.RGBA, t.UNSIGNED_BYTE, r);
                return o
            }

            function r(e) {
                !0 !== _[e] && (t.enable(e), _[e] = !0)
            }

            function o(e) {
                !1 !== _[e] && (t.disable(e), _[e] = !1)
            }

            function a(e, n, a, s, l, c, u, h) {
                if (e !== $r ? r(t.BLEND) : o(t.BLEND), e !== no) {
                    if (e !== w || h !== C) switch (e) {
                        case to:
                            h ? (t.blendEquationSeparate(t.FUNC_ADD, t.FUNC_ADD), t.blendFuncSeparate(t.ONE, t.ONE, t.ONE, t.ONE)) : (t.blendEquation(t.FUNC_ADD), t.blendFunc(t.SRC_ALPHA, t.ONE));
                            break;
                        case eo:
                            h ? (t.blendEquationSeparate(t.FUNC_ADD, t.FUNC_ADD), t.blendFuncSeparate(t.ZERO, t.ZERO, t.ONE_MINUS_SRC_COLOR, t.ONE_MINUS_SRC_ALPHA)) : (t.blendEquation(t.FUNC_ADD), t.blendFunc(t.ZERO, t.ONE_MINUS_SRC_COLOR));
                            break;
                        case io:
                            h ? (t.blendEquationSeparate(t.FUNC_ADD, t.FUNC_ADD), t.blendFuncSeparate(t.ZERO, t.SRC_COLOR, t.ZERO, t.SRC_ALPHA)) : (t.blendEquation(t.FUNC_ADD), t.blendFunc(t.ZERO, t.SRC_COLOR));
                            break;
                        default:
                            h ? (t.blendEquationSeparate(t.FUNC_ADD, t.FUNC_ADD), t.blendFuncSeparate(t.ONE, t.ONE_MINUS_SRC_ALPHA, t.ONE, t.ONE_MINUS_SRC_ALPHA)) : (t.blendEquationSeparate(t.FUNC_ADD, t.FUNC_ADD), t.blendFuncSeparate(t.SRC_ALPHA, t.ONE_MINUS_SRC_ALPHA, t.ONE, t.ONE_MINUS_SRC_ALPHA))
                    }
                    T = null, S = null, E = null, M = null, A = null, L = null
                } else l = l || n, c = c || a, u = u || s, n === T && l === M || (t.blendEquationSeparate(i.convert(n), i.convert(l)), T = n, M = l), a === S && s === E && c === A && u === L || (t.blendFuncSeparate(i.convert(a), i.convert(s), i.convert(c), i.convert(u)), S = a, E = s, A = c, L = u);
                w = e, C = h
            }

            function s(e) {
                P !== e && (e ? t.frontFace(t.CW) : t.frontFace(t.CCW), P = e)
            }

            function c(e) {
                e !== zr ? (r(t.CULL_FACE), e !== R && (e === jr ? t.cullFace(t.BACK) : e === Hr ? t.cullFace(t.FRONT) : t.cullFace(t.FRONT_AND_BACK))) : o(t.CULL_FACE), R = e
            }

            function u(e, i, n) {
                e ? (r(t.POLYGON_OFFSET_FILL), I === i && D === n || (t.polygonOffset(i, n), I = i, D = n)) : o(t.POLYGON_OFFSET_FILL)
            }

            function h(e) {
                void 0 === e && (e = t.TEXTURE0 + N - 1), U !== e && (t.activeTexture(e), U = e)
            }
            var d = new function() {
                    var e = !1,
                        i = new l,
                        n = null,
                        r = new l(0, 0, 0, 0);
                    return {
                        setMask: function(i) {
                            n === i || e || (t.colorMask(i, i, i, i), n = i)
                        },
                        setLocked: function(t) {
                            e = t
                        },
                        setClear: function(e, n, o, a, s) {
                            !0 === s && (e *= a, n *= a, o *= a), i.set(e, n, o, a), !1 === r.equals(i) && (t.clearColor(e, n, o, a), r.copy(i))
                        },
                        reset: function() {
                            e = !1, n = null, r.set(-1, 0, 0, 0)
                        }
                    }
                },
                p = new function() {
                    var e = !1,
                        i = null,
                        n = null,
                        a = null;
                    return {
                        setTest: function(e) {
                            e ? r(t.DEPTH_TEST) : o(t.DEPTH_TEST)
                        },
                        setMask: function(n) {
                            i === n || e || (t.depthMask(n), i = n)
                        },
                        setFunc: function(e) {
                            if (n !== e) {
                                if (e) switch (e) {
                                    case bo:
                                        t.depthFunc(t.NEVER);
                                        break;
                                    case wo:
                                        t.depthFunc(t.ALWAYS);
                                        break;
                                    case To:
                                        t.depthFunc(t.LESS);
                                        break;
                                    case So:
                                        t.depthFunc(t.LEQUAL);
                                        break;
                                    case Eo:
                                        t.depthFunc(t.EQUAL);
                                        break;
                                    case Mo:
                                        t.depthFunc(t.GEQUAL);
                                        break;
                                    case Ao:
                                        t.depthFunc(t.GREATER);
                                        break;
                                    case Lo:
                                        t.depthFunc(t.NOTEQUAL);
                                        break;
                                    default:
                                        t.depthFunc(t.LEQUAL)
                                } else t.depthFunc(t.LEQUAL);
                                n = e
                            }
                        },
                        setLocked: function(t) {
                            e = t
                        },
                        setClear: function(e) {
                            a !== e && (t.clearDepth(e), a = e)
                        },
                        reset: function() {
                            e = !1, i = null, n = null, a = null
                        }
                    }
                },
                f = new function() {
                    var e = !1,
                        i = null,
                        n = null,
                        a = null,
                        s = null,
                        l = null,
                        c = null,
                        u = null,
                        h = null;
                    return {
                        setTest: function(e) {
                            e ? r(t.STENCIL_TEST) : o(t.STENCIL_TEST)
                        },
                        setMask: function(n) {
                            i === n || e || (t.stencilMask(n), i = n)
                        },
                        setFunc: function(e, i, r) {
                            n === e && a === i && s === r || (t.stencilFunc(e, i, r), n = e, a = i, s = r)
                        },
                        setOp: function(e, i, n) {
                            l === e && c === i && u === n || (t.stencilOp(e, i, n), l = e, c = i, u = n)
                        },
                        setLocked: function(t) {
                            e = t
                        },
                        setClear: function(e) {
                            h !== e && (t.clearStencil(e), h = e)
                        },
                        reset: function() {
                            e = !1, i = null, n = null, a = null, s = null, l = null, c = null, u = null, h = null
                        }
                    }
                },
                m = t.getParameter(t.MAX_VERTEX_ATTRIBS),
                g = new Uint8Array(m),
                v = new Uint8Array(m),
                y = new Uint8Array(m),
                _ = {},
                x = null,
                b = null,
                w = null,
                T = null,
                S = null,
                E = null,
                M = null,
                A = null,
                L = null,
                C = !1,
                P = null,
                R = null,
                O = null,
                I = null,
                D = null,
                N = t.getParameter(t.MAX_COMBINED_TEXTURE_IMAGE_UNITS),
                F = parseFloat(/^WebGL\ ([0-9])/.exec(t.getParameter(t.VERSION))[1]),
                k = parseFloat(F) >= 1,
                U = null,
                B = {},
                z = new l,
                j = new l,
                H = {};
            return H[t.TEXTURE_2D] = n(t.TEXTURE_2D, t.TEXTURE_2D, 1), H[t.TEXTURE_CUBE_MAP] = n(t.TEXTURE_CUBE_MAP, t.TEXTURE_CUBE_MAP_POSITIVE_X, 6), d.setClear(0, 0, 0, 1), p.setClear(1), f.setClear(0), r(t.DEPTH_TEST), p.setFunc(So), s(!1), c(jr), r(t.CULL_FACE), r(t.BLEND), a(Kr), {
                buffers: {
                    color: d,
                    depth: p,
                    stencil: f
                },
                initAttributes: function() {
                    for (var t = 0, e = g.length; t < e; t++) g[t] = 0
                },
                enableAttribute: function(i) {
                    g[i] = 1, 0 === v[i] && (t.enableVertexAttribArray(i), v[i] = 1), 0 !== y[i] && (e.get("ANGLE_instanced_arrays").vertexAttribDivisorANGLE(i, 0), y[i] = 0)
                },
                enableAttributeAndDivisor: function(i, n) {
                    g[i] = 1, 0 === v[i] && (t.enableVertexAttribArray(i), v[i] = 1), y[i] !== n && (e.get("ANGLE_instanced_arrays").vertexAttribDivisorANGLE(i, n), y[i] = n)
                },
                disableUnusedAttributes: function() {
                    for (var e = 0, i = v.length; e !== i; ++e) v[e] !== g[e] && (t.disableVertexAttribArray(e), v[e] = 0)
                },
                enable: r,
                disable: o,
                getCompressedTextureFormats: function() {
                    if (null === x && (x = [], e.get("WEBGL_compressed_texture_pvrtc") || e.get("WEBGL_compressed_texture_s3tc") || e.get("WEBGL_compressed_texture_etc1")))
                        for (var i = t.getParameter(t.COMPRESSED_TEXTURE_FORMATS), n = 0; n < i.length; n++) x.push(i[n]);
                    return x
                },
                useProgram: function(e) {
                    return b !== e && (t.useProgram(e), b = e, !0)
                },
                setBlending: a,
                setMaterial: function(e) {
                    e.side === Yr ? o(t.CULL_FACE) : r(t.CULL_FACE), s(e.side === qr), !0 === e.transparent ? a(e.blending, e.blendEquation, e.blendSrc, e.blendDst, e.blendEquationAlpha, e.blendSrcAlpha, e.blendDstAlpha, e.premultipliedAlpha) : a($r), p.setFunc(e.depthFunc), p.setTest(e.depthTest), p.setMask(e.depthWrite), d.setMask(e.colorWrite), u(e.polygonOffset, e.polygonOffsetFactor, e.polygonOffsetUnits)
                },
                setFlipSided: s,
                setCullFace: c,
                setLineWidth: function(e) {
                    e !== O && (k && t.lineWidth(e), O = e)
                },
                setPolygonOffset: u,
                setScissorTest: function(e) {
                    e ? r(t.SCISSOR_TEST) : o(t.SCISSOR_TEST)
                },
                activeTexture: h,
                bindTexture: function(e, i) {
                    null === U && h();
                    var n = B[U];
                    void 0 === n && (n = {
                        type: void 0,
                        texture: void 0
                    }, B[U] = n), n.type === e && n.texture === i || (t.bindTexture(e, i || H[e]), n.type = e, n.texture = i)
                },
                compressedTexImage2D: function() {
                    try {
                        t.compressedTexImage2D.apply(t, arguments)
                    } catch (t) {
                        console.error("THREE.WebGLState:", t)
                    }
                },
                texImage2D: function() {
                    try {
                        t.texImage2D.apply(t, arguments)
                    } catch (t) {
                        console.error("THREE.WebGLState:", t)
                    }
                },
                scissor: function(e) {
                    !1 === z.equals(e) && (t.scissor(e.x, e.y, e.z, e.w), z.copy(e))
                },
                viewport: function(e) {
                    !1 === j.equals(e) && (t.viewport(e.x, e.y, e.z, e.w), j.copy(e))
                },
                reset: function() {
                    for (var e = 0; e < v.length; e++) 1 === v[e] && (t.disableVertexAttribArray(e), v[e] = 0);
                    _ = {}, x = null, U = null, B = {}, b = null, w = null, P = null, R = null, d.reset(), p.reset(), f.reset()
                }
            }
        }

        function fe(t, e, i) {
            function n(e) {
                if ("highp" === e) {
                    if (t.getShaderPrecisionFormat(t.VERTEX_SHADER, t.HIGH_FLOAT).precision > 0 && t.getShaderPrecisionFormat(t.FRAGMENT_SHADER, t.HIGH_FLOAT).precision > 0) return "highp";
                    e = "mediump"
                }
                return "mediump" === e && t.getShaderPrecisionFormat(t.VERTEX_SHADER, t.MEDIUM_FLOAT).precision > 0 && t.getShaderPrecisionFormat(t.FRAGMENT_SHADER, t.MEDIUM_FLOAT).precision > 0 ? "mediump" : "lowp"
            }
            var r, o = void 0 !== i.precision ? i.precision : "highp",
                a = n(o);
            a !== o && (console.warn("THREE.WebGLRenderer:", o, "not supported, using", a, "instead."), o = a);
            var s = !0 === i.logarithmicDepthBuffer,
                l = t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS),
                c = t.getParameter(t.MAX_VERTEX_TEXTURE_IMAGE_UNITS),
                u = t.getParameter(t.MAX_TEXTURE_SIZE),
                h = t.getParameter(t.MAX_CUBE_MAP_TEXTURE_SIZE),
                d = t.getParameter(t.MAX_VERTEX_ATTRIBS),
                p = t.getParameter(t.MAX_VERTEX_UNIFORM_VECTORS),
                f = t.getParameter(t.MAX_VARYING_VECTORS),
                m = t.getParameter(t.MAX_FRAGMENT_UNIFORM_VECTORS),
                g = c > 0,
                v = !!e.get("OES_texture_float");
            return {
                getMaxAnisotropy: function() {
                    if (void 0 !== r) return r;
                    var i = e.get("EXT_texture_filter_anisotropic");
                    return r = null !== i ? t.getParameter(i.MAX_TEXTURE_MAX_ANISOTROPY_EXT) : 0
                },
                getMaxPrecision: n,
                precision: o,
                logarithmicDepthBuffer: s,
                maxTextures: l,
                maxVertexTextures: c,
                maxTextureSize: u,
                maxCubemapSize: h,
                maxAttributes: d,
                maxVertexUniforms: p,
                maxVaryings: f,
                maxFragmentUniforms: m,
                vertexTextures: g,
                floatFragmentTextures: v,
                floatVertexTextures: g && v
            }
        }

        function me(t, e, i, n) {
            ut.call(this), this.type = "PerspectiveCamera", this.fov = void 0 !== t ? t : 50, this.zoom = 1, this.near = void 0 !== i ? i : .1, this.far = void 0 !== n ? n : 2e3, this.focus = 10, this.aspect = void 0 !== e ? e : 1, this.view = null, this.filmGauge = 35, this.filmOffset = 0, this.updateProjectionMatrix()
        }

        function ge(t) {
            me.call(this), this.cameras = t || []
        }

        function ve(t) {
            function e() {
                if (null !== r && r.isPresenting) {
                    var e = r.getEyeParameters("left"),
                        n = e.renderWidth,
                        o = e.renderHeight;
                    f = t.getPixelRatio(), p = t.getSize(), t.setDrawingBufferSize(2 * n, o, 1)
                } else i.enabled && t.setDrawingBufferSize(p.width, p.height, f)
            }
            var i = this,
                r = null,
                o = null;
            "undefined" != typeof window && "VRFrameData" in window && (o = new window.VRFrameData);
            var a = new n,
                s = new n,
                c = new n,
                u = new me;
            u.bounds = new l(0, 0, .5, 1), u.layers.enable(1);
            var h = new me;
            h.bounds = new l(.5, 0, .5, 1), h.layers.enable(2);
            var d = new ge([u, h]);
            d.layers.enable(1), d.layers.enable(2);
            var p, f;
            "undefined" != typeof window && window.addEventListener("vrdisplaypresentchange", e, !1), this.enabled = !1, this.standing = !1, this.getDevice = function() {
                return r
            }, this.setDevice = function(t) {
                void 0 !== t && (r = t)
            }, this.getCamera = function(t) {
                if (null === r) return t;
                r.depthNear = t.near, r.depthFar = t.far, r.getFrameData(o);
                var e = o.pose;
                null !== e.position ? t.position.fromArray(e.position) : t.position.set(0, 0, 0), null !== e.orientation && t.quaternion.fromArray(e.orientation), t.updateMatrixWorld();
                var i = r.stageParameters;
                if (this.standing && i && (s.fromArray(i.sittingToStandingTransform), c.getInverse(s), t.matrixWorld.multiply(s), t.matrixWorldInverse.multiply(c)), !1 === r.isPresenting) return t;
                u.near = t.near, h.near = t.near, u.far = t.far, h.far = t.far, d.matrixWorld.copy(t.matrixWorld), d.matrixWorldInverse.copy(t.matrixWorldInverse), u.matrixWorldInverse.fromArray(o.leftViewMatrix), h.matrixWorldInverse.fromArray(o.rightViewMatrix), this.standing && i && (u.matrixWorldInverse.multiply(c), h.matrixWorldInverse.multiply(c));
                var n = t.parent;
                null !== n && (a.getInverse(n.matrixWorld), u.matrixWorldInverse.multiply(a), h.matrixWorldInverse.multiply(a)), u.matrixWorld.getInverse(u.matrixWorldInverse), h.matrixWorld.getInverse(h.matrixWorldInverse), u.projectionMatrix.fromArray(o.leftProjectionMatrix), h.projectionMatrix.fromArray(o.rightProjectionMatrix), d.projectionMatrix.copy(u.projectionMatrix);
                var l = r.getLayers();
                if (l.length) {
                    var p = l[0];
                    null !== p.leftBounds && 4 === p.leftBounds.length && u.bounds.fromArray(p.leftBounds), null !== p.rightBounds && 4 === p.rightBounds.length && h.bounds.fromArray(p.rightBounds)
                }
                return d
            }, this.getStandingMatrix = function() {
                return s
            }, this.submitFrame = function() {
                r && r.isPresenting && r.submitFrame()
            }, this.dispose = function() {
                "undefined" != typeof window && window.removeEventListener("vrdisplaypresentchange", e)
            }
        }

        function ye(t) {
            var e = {};
            return {
                get: function(i) {
                    if (void 0 !== e[i]) return e[i];
                    var n;
                    switch (i) {
                        case "WEBGL_depth_texture":
                            n = t.getExtension("WEBGL_depth_texture") || t.getExtension("MOZ_WEBGL_depth_texture") || t.getExtension("WEBKIT_WEBGL_depth_texture");
                            break;
                        case "EXT_texture_filter_anisotropic":
                            n = t.getExtension("EXT_texture_filter_anisotropic") || t.getExtension("MOZ_EXT_texture_filter_anisotropic") || t.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
                            break;
                        case "WEBGL_compressed_texture_s3tc":
                            n = t.getExtension("WEBGL_compressed_texture_s3tc") || t.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || t.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
                            break;
                        case "WEBGL_compressed_texture_pvrtc":
                            n = t.getExtension("WEBGL_compressed_texture_pvrtc") || t.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
                            break;
                        case "WEBGL_compressed_texture_etc1":
                            n = t.getExtension("WEBGL_compressed_texture_etc1");
                            break;
                        default:
                            n = t.getExtension(i)
                    }
                    return null === n && console.warn("THREE.WebGLRenderer: " + i + " extension not supported."), e[i] = n, n
                }
            }
        }

        function _e() {
            function t() {
                u.value !== n && (u.value = n, u.needsUpdate = r > 0), i.numPlanes = r, i.numIntersection = 0
            }

            function e(t, e, n, r) {
                var o = null !== t ? t.length : 0,
                    a = null;
                if (0 !== o) {
                    if (a = u.value, !0 !== r || null === a) {
                        var s = n + 4 * o,
                            h = e.matrixWorldInverse;
                        c.getNormalMatrix(h), (null === a || a.length < s) && (a = new Float32Array(s));
                        for (var d = 0, p = n; d !== o; ++d, p += 4) l.copy(t[d]).applyMatrix4(h, c), l.normal.toArray(a, p), a[p + 3] = l.constant
                    }
                    u.value = a, u.needsUpdate = !0
                }
                return i.numPlanes = o, a
            }
            var i = this,
                n = null,
                r = 0,
                o = !1,
                s = !1,
                l = new nt,
                c = new a,
                u = {
                    value: null,
                    needsUpdate: !1
                };
            this.uniform = u, this.numPlanes = 0, this.numIntersection = 0, this.init = function(t, i, a) {
                var s = 0 !== t.length || i || 0 !== r || o;
                return o = i, n = e(t, a, 0), r = t.length, s
            }, this.beginShadows = function() {
                s = !0, e(null)
            }, this.endShadows = function() {
                s = !1, t()
            }, this.setState = function(i, a, l, c, h, d) {
                if (!o || null === i || 0 === i.length || s && !l) s ? e(null) : t();
                else {
                    var p = s ? 0 : r,
                        f = 4 * p,
                        m = h.clippingState || null;
                    u.value = m, m = e(i, c, f, d);
                    for (var g = 0; g !== f; ++g) m[g] = n[g];
                    h.clippingState = m, this.numIntersection = a ? this.numPlanes : 0, this.numPlanes += p
                }
            }
        }

        function xe(t, e) {
            return {
                convert: function(i) {
                    var n;
                    if (i === Vo) return t.REPEAT;
                    if (i === Wo) return t.CLAMP_TO_EDGE;
                    if (i === Xo) return t.MIRRORED_REPEAT;
                    if (i === qo) return t.NEAREST;
                    if (i === Yo) return t.NEAREST_MIPMAP_NEAREST;
                    if (i === Qo) return t.NEAREST_MIPMAP_LINEAR;
                    if (i === Zo) return t.LINEAR;
                    if (i === Jo) return t.LINEAR_MIPMAP_NEAREST;
                    if (i === $o) return t.LINEAR_MIPMAP_LINEAR;
                    if (i === Ko) return t.UNSIGNED_BYTE;
                    if (i === sa) return t.UNSIGNED_SHORT_4_4_4_4;
                    if (i === la) return t.UNSIGNED_SHORT_5_5_5_1;
                    if (i === ca) return t.UNSIGNED_SHORT_5_6_5;
                    if (i === ta) return t.BYTE;
                    if (i === ea) return t.SHORT;
                    if (i === ia) return t.UNSIGNED_SHORT;
                    if (i === na) return t.INT;
                    if (i === ra) return t.UNSIGNED_INT;
                    if (i === oa) return t.FLOAT;
                    if (i === aa && null !== (n = e.get("OES_texture_half_float"))) return n.HALF_FLOAT_OES;
                    if (i === ha) return t.ALPHA;
                    if (i === da) return t.RGB;
                    if (i === pa) return t.RGBA;
                    if (i === fa) return t.LUMINANCE;
                    if (i === ma) return t.LUMINANCE_ALPHA;
                    if (i === va) return t.DEPTH_COMPONENT;
                    if (i === ya) return t.DEPTH_STENCIL;
                    if (i === ro) return t.FUNC_ADD;
                    if (i === oo) return t.FUNC_SUBTRACT;
                    if (i === ao) return t.FUNC_REVERSE_SUBTRACT;
                    if (i === co) return t.ZERO;
                    if (i === uo) return t.ONE;
                    if (i === ho) return t.SRC_COLOR;
                    if (i === po) return t.ONE_MINUS_SRC_COLOR;
                    if (i === fo) return t.SRC_ALPHA;
                    if (i === mo) return t.ONE_MINUS_SRC_ALPHA;
                    if (i === go) return t.DST_ALPHA;
                    if (i === vo) return t.ONE_MINUS_DST_ALPHA;
                    if (i === yo) return t.DST_COLOR;
                    if (i === _o) return t.ONE_MINUS_DST_COLOR;
                    if (i === xo) return t.SRC_ALPHA_SATURATE;
                    if ((i === _a || i === xa || i === ba || i === wa) && null !== (n = e.get("WEBGL_compressed_texture_s3tc"))) {
                        if (i === _a) return n.COMPRESSED_RGB_S3TC_DXT1_EXT;
                        if (i === xa) return n.COMPRESSED_RGBA_S3TC_DXT1_EXT;
                        if (i === ba) return n.COMPRESSED_RGBA_S3TC_DXT3_EXT;
                        if (i === wa) return n.COMPRESSED_RGBA_S3TC_DXT5_EXT
                    }
                    if ((i === Ta || i === Sa || i === Ea || i === Ma) && null !== (n = e.get("WEBGL_compressed_texture_pvrtc"))) {
                        if (i === Ta) return n.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
                        if (i === Sa) return n.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
                        if (i === Ea) return n.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
                        if (i === Ma) return n.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG
                    }
                    if (i === Aa && null !== (n = e.get("WEBGL_compressed_texture_etc1"))) return n.COMPRESSED_RGB_ETC1_WEBGL;
                    if ((i === so || i === lo) && null !== (n = e.get("EXT_blend_minmax"))) {
                        if (i === so) return n.MIN_EXT;
                        if (i === lo) return n.MAX_EXT
                    }
                    return i === ua && null !== (n = e.get("WEBGL_depth_texture")) ? n.UNSIGNED_INT_24_8_WEBGL : 0
                }
            }
        }

        function be(t) {
            function e() {
                return null === K ? ft : 1
            }

            function i() {
                (Lt = new ye(Mt)).get("WEBGL_depth_texture"), Lt.get("OES_texture_float"), Lt.get("OES_texture_float_linear"), Lt.get("OES_texture_half_float"), Lt.get("OES_texture_half_float_linear"), Lt.get("OES_standard_derivatives"), Lt.get("OES_element_index_uint"), Lt.get("ANGLE_instanced_arrays"), Kt = new xe(Mt, Lt), Ct = new fe(Mt, Lt, t), (Pt = new pe(Mt, Lt, Kt)).scissor(ct.copy(gt).multiplyScalar(ft)), Pt.viewport(lt.copy(mt).multiplyScalar(ft)), Rt = new de, Ot = new he(Mt, Lt, Pt, Rt, Ct, Kt, St), It = new at(Mt), Dt = new Xt(Mt, It, St), Nt = new Qt(Dt, Et), Ht = new Gt(Mt), Ut = new ue(Z, Lt, Ct), Ft = new Yt, Bt = new jt, zt = new kt(Z, Pt, Dt, j), qt = new Wt(Mt, Lt, Et), Zt = new Vt(Mt, Lt, Et), Jt = new Q(Z, Mt, Pt, Ot, Ct), $t = new J(Z, Mt, Pt, Ot, Ct), Z.info.programs = Ut.programs, Z.context = Mt, Z.capabilities = Ct, Z.extensions = Lt, Z.properties = Rt, Z.renderLists = Bt, Z.state = Pt
            }

            function r(t) {
                t.preventDefault(), console.log("THREE.WebGLRenderer: Context Lost."), $ = !0
            }

            function a() {
                console.log("THREE.WebGLRenderer: Context Restored."), $ = !1, i()
            }

            function s(t) {
                var e = t.target;
                e.removeEventListener("dispose", s), c(e)
            }

            function c(t) {
                u(t), Rt.remove(t)
            }

            function u(t) {
                var e = Rt.get(t).program;
                t.program = void 0, void 0 !== e && Ut.releaseProgram(e)
            }

            function d(t, e, i) {
                t.render(function(t) {
                    Z.renderBufferImmediate(t, e, i)
                })
            }

            function p(t, e, i, n) {
                if (i && i.isInstancedBufferGeometry && null === Lt.get("ANGLE_instanced_arrays")) console.error("THREE.WebGLRenderer.setupVertexAttributes: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
                else {
                    void 0 === n && (n = 0), Pt.initAttributes();
                    var r = i.attributes,
                        o = e.getAttributes(),
                        a = t.defaultAttributeValues;
                    for (var s in o) {
                        var l = o[s];
                        if (l >= 0) {
                            var c = r[s];
                            if (void 0 !== c) {
                                var u = c.normalized,
                                    h = c.itemSize,
                                    d = It.get(c);
                                if (void 0 === d) continue;
                                var p = d.buffer,
                                    f = d.type,
                                    m = d.bytesPerElement;
                                if (c.isInterleavedBufferAttribute) {
                                    var g = c.data,
                                        v = g.stride,
                                        y = c.offset;
                                    g && g.isInstancedInterleavedBuffer ? (Pt.enableAttributeAndDivisor(l, g.meshPerAttribute), void 0 === i.maxInstancedCount && (i.maxInstancedCount = g.meshPerAttribute * g.count)) : Pt.enableAttribute(l), Mt.bindBuffer(Mt.ARRAY_BUFFER, p), Mt.vertexAttribPointer(l, h, f, u, v * m, (n * v + y) * m)
                                } else c.isInstancedBufferAttribute ? (Pt.enableAttributeAndDivisor(l, c.meshPerAttribute), void 0 === i.maxInstancedCount && (i.maxInstancedCount = c.meshPerAttribute * c.count)) : Pt.enableAttribute(l), Mt.bindBuffer(Mt.ARRAY_BUFFER, p), Mt.vertexAttribPointer(l, h, f, u, 0, n * h * m)
                            } else if (void 0 !== a) {
                                var _ = a[s];
                                if (void 0 !== _) switch (_.length) {
                                    case 2:
                                        Mt.vertexAttrib2fv(l, _);
                                        break;
                                    case 3:
                                        Mt.vertexAttrib3fv(l, _);
                                        break;
                                    case 4:
                                        Mt.vertexAttrib4fv(l, _);
                                        break;
                                    default:
                                        Mt.vertexAttrib1fv(l, _)
                                }
                            }
                        }
                    }
                    Pt.disableUnusedAttributes()
                }
            }

            function f() {
                if (!ie) {
                    var t = te.getDevice();
                    t && t.isPresenting ? t.requestAnimationFrame(m) : window.requestAnimationFrame(m), ie = !0
                }
            }

            function m(t) {
                null !== ne && ne(t);
                var e = te.getDevice();
                e && e.isPresenting ? e.requestAnimationFrame(m) : window.requestAnimationFrame(m)
            }

            function g(t, e, i) {
                if (!1 !== t.visible) {
                    if (t.layers.test(e.layers))
                        if (t.isLight) G.push(t), t.castShadow && V.push(t);
                        else if (t.isSprite) t.frustumCulled && !yt.intersectsSprite(t) || q.push(t);
                    else if (t.isLensFlare) Y.push(t);
                    else if (t.isImmediateRenderObject) i && Tt.setFromMatrixPosition(t.matrixWorld).applyMatrix4(wt), W.push(t, null, t.material, Tt.z, null);
                    else if ((t.isMesh || t.isLine || t.isPoints) && (t.isSkinnedMesh && t.skeleton.update(), !t.frustumCulled || yt.intersectsObject(t))) {
                        i && Tt.setFromMatrixPosition(t.matrixWorld).applyMatrix4(wt);
                        var n = Nt.update(t),
                            r = t.material;
                        if (Array.isArray(r))
                            for (var o = n.groups, a = 0, s = o.length; a < s; a++) {
                                var l = o[a],
                                    c = r[l.materialIndex];
                                c && c.visible && W.push(t, n, c, Tt.z, l)
                            } else r.visible && W.push(t, n, r, Tt.z, null)
                    }
                    for (var u = t.children, a = 0, s = u.length; a < s; a++) g(u[a], e, i)
                }
            }

            function v(t, e, i, n) {
                for (var r = 0, o = t.length; r < o; r++) {
                    var a = t[r],
                        s = a.object,
                        l = a.geometry,
                        c = void 0 === n ? a.material : n,
                        u = a.group;
                    if (i.isArrayCamera) {
                        st = i;
                        for (var h = i.cameras, d = 0, p = h.length; d < p; d++) {
                            var f = h[d];
                            if (s.layers.test(f.layers)) {
                                var m = f.bounds,
                                    g = m.x * dt,
                                    v = m.y * pt,
                                    _ = m.z * dt,
                                    x = m.w * pt;
                                Pt.viewport(lt.set(g, v, _, x).multiplyScalar(ft)), y(s, e, f, l, c, u)
                            }
                        }
                    } else st = null, y(s, e, i, l, c, u)
                }
            }

            function y(t, e, i, n, r, o) {
                if (t.onBeforeRender(Z, e, i, n, r, o), t.modelViewMatrix.multiplyMatrices(i.matrixWorldInverse, t.matrixWorld), t.normalMatrix.getNormalMatrix(t.modelViewMatrix), t.isImmediateRenderObject) {
                    Pt.setMaterial(r);
                    var a = x(i, e.fog, r, t);
                    it = "", d(t, a, r)
                } else Z.renderBufferDirect(i, e.fog, n, r, t, o);
                t.onAfterRender(Z, e, i, n, r, o)
            }

            function _(t, e, i) {
                var n = Rt.get(t),
                    r = Ut.getParameters(t, Ft.state, V, e, _t.numPlanes, _t.numIntersection, i),
                    o = Ut.getProgramCode(t, r),
                    a = n.program,
                    l = !0;
                if (void 0 === a) t.addEventListener("dispose", s);
                else if (a.code !== o) u(t);
                else {
                    if (void 0 !== r.shaderID) return;
                    l = !1
                }
                if (l) {
                    if (r.shaderID) {
                        var c = es[r.shaderID];
                        n.shader = {
                            name: t.type,
                            uniforms: Ka.clone(c.uniforms),
                            vertexShader: c.vertexShader,
                            fragmentShader: c.fragmentShader
                        }
                    } else n.shader = {
                        name: t.type,
                        uniforms: t.uniforms,
                        vertexShader: t.vertexShader,
                        fragmentShader: t.fragmentShader
                    };
                    t.onBeforeCompile(n.shader), a = Ut.acquireProgram(t, n.shader, r, o), n.program = a, t.program = a
                }
                var h = a.getAttributes();
                if (t.morphTargets) {
                    t.numSupportedMorphTargets = 0;
                    for (d = 0; d < Z.maxMorphTargets; d++) h["morphTarget" + d] >= 0 && t.numSupportedMorphTargets++
                }
                if (t.morphNormals) {
                    t.numSupportedMorphNormals = 0;
                    for (var d = 0; d < Z.maxMorphNormals; d++) h["morphNormal" + d] >= 0 && t.numSupportedMorphNormals++
                }
                var p = n.shader.uniforms;
                (t.isShaderMaterial || t.isRawShaderMaterial) && !0 !== t.clipping || (n.numClippingPlanes = _t.numPlanes, n.numIntersection = _t.numIntersection, p.clippingPlanes = _t.uniform), n.fog = e, n.lightsHash = Ft.state.hash, t.lights && (p.ambientLightColor.value = Ft.state.ambient, p.directionalLights.value = Ft.state.directional, p.spotLights.value = Ft.state.spot, p.rectAreaLights.value = Ft.state.rectArea, p.pointLights.value = Ft.state.point, p.hemisphereLights.value = Ft.state.hemi, p.directionalShadowMap.value = Ft.state.directionalShadowMap, p.directionalShadowMatrix.value = Ft.state.directionalShadowMatrix, p.spotShadowMap.value = Ft.state.spotShadowMap, p.spotShadowMatrix.value = Ft.state.spotShadowMatrix, p.pointShadowMap.value = Ft.state.pointShadowMap, p.pointShadowMatrix.value = Ft.state.pointShadowMatrix);
                var f = n.program.getUniforms(),
                    m = X.seqWithValue(f.seq, p);
                n.uniformsList = m
            }

            function x(t, e, i, n) {
                ht = 0;
                var r = Rt.get(i);
                if (xt && (bt || t !== nt)) {
                    var o = t === nt && i.id === et;
                    _t.setState(i.clippingPlanes, i.clipIntersection, i.clipShadows, t, r, o)
                }!1 === i.needsUpdate && (void 0 === r.program ? i.needsUpdate = !0 : i.fog && r.fog !== e ? i.needsUpdate = !0 : i.lights && r.lightsHash !== Ft.state.hash ? i.needsUpdate = !0 : void 0 === r.numClippingPlanes || r.numClippingPlanes === _t.numPlanes && r.numIntersection === _t.numIntersection || (i.needsUpdate = !0)), i.needsUpdate && (_(i, e, n), i.needsUpdate = !1);
                var a = !1,
                    s = !1,
                    l = !1,
                    c = r.program,
                    u = c.getUniforms(),
                    d = r.shader.uniforms;
                if (Pt.useProgram(c.program) && (a = !0, s = !0, l = !0), i.id !== et && (et = i.id, s = !0), a || t !== nt) {
                    if (u.setValue(Mt, "projectionMatrix", t.projectionMatrix), Ct.logarithmicDepthBuffer && u.setValue(Mt, "logDepthBufFC", 2 / (Math.log(t.far + 1) / Math.LN2)), nt !== (st || t) && (nt = st || t, s = !0, l = !0), i.isShaderMaterial || i.isMeshPhongMaterial || i.isMeshStandardMaterial || i.envMap) {
                        var p = u.map.cameraPosition;
                        void 0 !== p && p.setValue(Mt, Tt.setFromMatrixPosition(t.matrixWorld))
                    }(i.isMeshPhongMaterial || i.isMeshLambertMaterial || i.isMeshBasicMaterial || i.isMeshStandardMaterial || i.isShaderMaterial || i.skinning) && u.setValue(Mt, "viewMatrix", t.matrixWorldInverse)
                }
                if (i.skinning) {
                    u.setOptional(Mt, n, "bindMatrix"), u.setOptional(Mt, n, "bindMatrixInverse");
                    var f = n.skeleton;
                    if (f) {
                        var m = f.bones;
                        if (Ct.floatVertexTextures) {
                            if (void 0 === f.boneTexture) {
                                var g = Math.sqrt(4 * m.length);
                                g = Ha.ceilPowerOfTwo(g), g = Math.max(g, 4);
                                var v = new Float32Array(g * g * 4);
                                v.set(f.boneMatrices);
                                var y = new h(v, g, g, pa, oa);
                                f.boneMatrices = v, f.boneTexture = y, f.boneTextureSize = g
                            }
                            u.setValue(Mt, "boneTexture", f.boneTexture), u.setValue(Mt, "boneTextureSize", f.boneTextureSize)
                        } else u.setOptional(Mt, f, "boneMatrices")
                    }
                }
                return s && (u.setValue(Mt, "toneMappingExposure", Z.toneMappingExposure), u.setValue(Mt, "toneMappingWhitePoint", Z.toneMappingWhitePoint), i.lights && D(d, l), e && i.fog && E(d, e), i.isMeshBasicMaterial ? b(d, i) : i.isMeshLambertMaterial ? (b(d, i), M(d, i)) : i.isMeshPhongMaterial ? (b(d, i), i.isMeshToonMaterial ? L(d, i) : A(d, i)) : i.isMeshStandardMaterial ? (b(d, i), i.isMeshPhysicalMaterial ? P(d, i) : C(d, i)) : i.isMeshDepthMaterial ? (b(d, i), R(d, i)) : i.isMeshDistanceMaterial ? (b(d, i), O(d, i)) : i.isMeshNormalMaterial ? (b(d, i), I(d, i)) : i.isLineBasicMaterial ? (w(d, i), i.isLineDashedMaterial && T(d, i)) : i.isPointsMaterial ? S(d, i) : i.isShadowMaterial && (d.color.value = i.color, d.opacity.value = i.opacity), void 0 !== d.ltcMat && (d.ltcMat.value = $a.LTC_MAT_TEXTURE), void 0 !== d.ltcMag && (d.ltcMag.value = $a.LTC_MAG_TEXTURE), X.upload(Mt, r.uniformsList, d, Z)), u.setValue(Mt, "modelViewMatrix", n.modelViewMatrix), u.setValue(Mt, "normalMatrix", n.normalMatrix), u.setValue(Mt, "modelMatrix", n.matrixWorld), c
            }

            function b(t, e) {
                t.opacity.value = e.opacity, e.color && (t.diffuse.value = e.color), e.emissive && t.emissive.value.copy(e.emissive).multiplyScalar(e.emissiveIntensity), e.map && (t.map.value = e.map), e.alphaMap && (t.alphaMap.value = e.alphaMap), e.specularMap && (t.specularMap.value = e.specularMap), e.envMap && (t.envMap.value = e.envMap, t.flipEnvMap.value = e.envMap && e.envMap.isCubeTexture ? -1 : 1, t.reflectivity.value = e.reflectivity, t.refractionRatio.value = e.refractionRatio), e.lightMap && (t.lightMap.value = e.lightMap, t.lightMapIntensity.value = e.lightMapIntensity), e.aoMap && (t.aoMap.value = e.aoMap, t.aoMapIntensity.value = e.aoMapIntensity);
                var i;
                if (e.map ? i = e.map : e.specularMap ? i = e.specularMap : e.displacementMap ? i = e.displacementMap : e.normalMap ? i = e.normalMap : e.bumpMap ? i = e.bumpMap : e.roughnessMap ? i = e.roughnessMap : e.metalnessMap ? i = e.metalnessMap : e.alphaMap ? i = e.alphaMap : e.emissiveMap && (i = e.emissiveMap), void 0 !== i) {
                    if (i.isWebGLRenderTarget && (i = i.texture), !0 === i.matrixAutoUpdate) {
                        var n = i.offset,
                            r = i.repeat,
                            o = i.rotation,
                            a = i.center;
                        i.matrix.setUvTransform(n.x, n.y, r.x, r.y, o, a.x, a.y)
                    }
                    t.uvTransform.value.copy(i.matrix)
                }
            }

            function w(t, e) {
                t.diffuse.value = e.color, t.opacity.value = e.opacity
            }

            function T(t, e) {
                t.dashSize.value = e.dashSize, t.totalSize.value = e.dashSize + e.gapSize, t.scale.value = e.scale
            }

            function S(t, e) {
                if (t.diffuse.value = e.color, t.opacity.value = e.opacity, t.size.value = e.size * ft, t.scale.value = .5 * pt, t.map.value = e.map, null !== e.map) {
                    if (!0 === e.map.matrixAutoUpdate) {
                        var i = e.map.offset,
                            n = e.map.repeat,
                            r = e.map.rotation,
                            o = e.map.center;
                        e.map.matrix.setUvTransform(i.x, i.y, n.x, n.y, r, o.x, o.y)
                    }
                    t.uvTransform.value.copy(e.map.matrix)
                }
            }

            function E(t, e) {
                t.fogColor.value = e.color, e.isFog ? (t.fogNear.value = e.near, t.fogFar.value = e.far) : e.isFogExp2 && (t.fogDensity.value = e.density)
            }

            function M(t, e) {
                e.emissiveMap && (t.emissiveMap.value = e.emissiveMap)
            }

            function A(t, e) {
                t.specular.value = e.specular, t.shininess.value = Math.max(e.shininess, 1e-4), e.emissiveMap && (t.emissiveMap.value = e.emissiveMap), e.bumpMap && (t.bumpMap.value = e.bumpMap, t.bumpScale.value = e.bumpScale), e.normalMap && (t.normalMap.value = e.normalMap, t.normalScale.value.copy(e.normalScale)), e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias)
            }

            function L(t, e) {
                A(t, e), e.gradientMap && (t.gradientMap.value = e.gradientMap)
            }

            function C(t, e) {
                t.roughness.value = e.roughness, t.metalness.value = e.metalness, e.roughnessMap && (t.roughnessMap.value = e.roughnessMap), e.metalnessMap && (t.metalnessMap.value = e.metalnessMap), e.emissiveMap && (t.emissiveMap.value = e.emissiveMap), e.bumpMap && (t.bumpMap.value = e.bumpMap, t.bumpScale.value = e.bumpScale), e.normalMap && (t.normalMap.value = e.normalMap, t.normalScale.value.copy(e.normalScale)), e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias), e.envMap && (t.envMapIntensity.value = e.envMapIntensity)
            }

            function P(t, e) {
                t.clearCoat.value = e.clearCoat, t.clearCoatRoughness.value = e.clearCoatRoughness, C(t, e)
            }

            function R(t, e) {
                e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias)
            }

            function O(t, e) {
                e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias), t.referencePosition.value.copy(e.referencePosition), t.nearDistance.value = e.nearDistance, t.farDistance.value = e.farDistance
            }

            function I(t, e) {
                e.bumpMap && (t.bumpMap.value = e.bumpMap, t.bumpScale.value = e.bumpScale), e.normalMap && (t.normalMap.value = e.normalMap, t.normalScale.value.copy(e.normalScale)), e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias)
            }

            function D(t, e) {
                t.ambientLightColor.needsUpdate = e, t.directionalLights.needsUpdate = e, t.pointLights.needsUpdate = e, t.spotLights.needsUpdate = e, t.rectAreaLights.needsUpdate = e, t.hemisphereLights.needsUpdate = e
            }
            console.log("THREE.WebGLRenderer", Ur);
            var N = void 0 !== (t = t || {}).canvas ? t.canvas : document.createElementNS("http://www.w3.org/1999/xhtml", "canvas"),
                F = void 0 !== t.context ? t.context : null,
                k = void 0 !== t.alpha && t.alpha,
                U = void 0 === t.depth || t.depth,
                B = void 0 === t.stencil || t.stencil,
                z = void 0 !== t.antialias && t.antialias,
                j = void 0 === t.premultipliedAlpha || t.premultipliedAlpha,
                H = void 0 !== t.preserveDrawingBuffer && t.preserveDrawingBuffer,
                G = [],
                V = [],
                W = null,
                q = [],
                Y = [];
            this.domElement = N, this.context = null, this.autoClear = !0, this.autoClearColor = !0, this.autoClearDepth = !0, this.autoClearStencil = !0, this.sortObjects = !0, this.clippingPlanes = [], this.localClippingEnabled = !1, this.gammaFactor = 2, this.gammaInput = !1, this.gammaOutput = !1, this.physicallyCorrectLights = !1, this.toneMapping = Io, this.toneMappingExposure = 1, this.toneMappingWhitePoint = 1, this.maxMorphTargets = 8, this.maxMorphNormals = 4;
            var Z = this,
                $ = !1,
                K = null,
                tt = null,
                et = -1,
                it = "",
                nt = null,
                st = null,
                lt = new l,
                ct = new l,
                ut = null,
                ht = 0,
                dt = N.width,
                pt = N.height,
                ft = 1,
                mt = new l(0, 0, dt, pt),
                gt = new l(0, 0, dt, pt),
                vt = !1,
                yt = new rt,
                _t = new _e,
                xt = !1,
                bt = !1,
                wt = new n,
                Tt = new o,
                St = {
                    geometries: 0,
                    textures: 0
                },
                Et = {
                    frame: 0,
                    calls: 0,
                    vertices: 0,
                    faces: 0,
                    points: 0
                };
            this.info = {
                render: Et,
                memory: St,
                programs: null
            };
            var Mt;
            try {
                var At = {
                    alpha: k,
                    depth: U,
                    stencil: B,
                    antialias: z,
                    premultipliedAlpha: j,
                    preserveDrawingBuffer: H
                };
                if (null === (Mt = F || N.getContext("webgl", At) || N.getContext("experimental-webgl", At))) throw null !== N.getContext("webgl") ? "Error creating WebGL context with your selected attributes." : "Error creating WebGL context.";
                void 0 === Mt.getShaderPrecisionFormat && (Mt.getShaderPrecisionFormat = function() {
                    return {
                        rangeMin: 1,
                        rangeMax: 1,
                        precision: 1
                    }
                }), N.addEventListener("webglcontextlost", r, !1), N.addEventListener("webglcontextrestored", a, !1)
            } catch (t) {
                console.error("THREE.WebGLRenderer: " + t)
            }
            var Lt, Ct, Pt, Rt, Ot, It, Dt, Nt, Ft, Ut, Bt, zt, Ht, qt, Zt, Jt, $t, Kt;
            i();
            var te = new ve(Z);
            this.vr = te;
            var ee = new ot(Z, Nt, Ct.maxTextureSize);
            this.shadowMap = ee, this.getContext = function() {
                return Mt
            }, this.getContextAttributes = function() {
                return Mt.getContextAttributes()
            }, this.forceContextLoss = function() {
                var t = Lt.get("WEBGL_lose_context");
                t && t.loseContext()
            }, this.forceContextRestore = function() {
                var t = Lt.get("WEBGL_lose_context");
                t && t.restoreContext()
            }, this.getPixelRatio = function() {
                return ft
            }, this.setPixelRatio = function(t) {
                void 0 !== t && (ft = t, this.setSize(dt, pt, !1))
            }, this.getSize = function() {
                return {
                    width: dt,
                    height: pt
                }
            }, this.setSize = function(t, e, i) {
                var n = te.getDevice();
                n && n.isPresenting ? console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.") : (dt = t, pt = e, N.width = t * ft, N.height = e * ft, !1 !== i && (N.style.width = t + "px", N.style.height = e + "px"), this.setViewport(0, 0, t, e))
            }, this.getDrawingBufferSize = function() {
                return {
                    width: dt * ft,
                    height: pt * ft
                }
            }, this.setDrawingBufferSize = function(t, e, i) {
                dt = t, pt = e, ft = i, N.width = t * i, N.height = e * i, this.setViewport(0, 0, t, e)
            }, this.setViewport = function(t, e, i, n) {
                mt.set(t, pt - e - n, i, n), Pt.viewport(lt.copy(mt).multiplyScalar(ft))
            }, this.setScissor = function(t, e, i, n) {
                gt.set(t, pt - e - n, i, n), Pt.scissor(ct.copy(gt).multiplyScalar(ft))
            }, this.setScissorTest = function(t) {
                Pt.setScissorTest(vt = t)
            }, this.getClearColor = function() {
                return zt.getClearColor()
            }, this.setClearColor = function() {
                zt.setClearColor.apply(zt, arguments)
            }, this.getClearAlpha = function() {
                return zt.getClearAlpha()
            }, this.setClearAlpha = function() {
                zt.setClearAlpha.apply(zt, arguments)
            }, this.clear = function(t, e, i) {
                var n = 0;
                (void 0 === t || t) && (n |= Mt.COLOR_BUFFER_BIT), (void 0 === e || e) && (n |= Mt.DEPTH_BUFFER_BIT), (void 0 === i || i) && (n |= Mt.STENCIL_BUFFER_BIT), Mt.clear(n)
            }, this.clearColor = function() {
                this.clear(!0, !1, !1)
            }, this.clearDepth = function() {
                this.clear(!1, !0, !1)
            }, this.clearStencil = function() {
                this.clear(!1, !1, !0)
            }, this.clearTarget = function(t, e, i, n) {
                this.setRenderTarget(t), this.clear(e, i, n)
            }, this.dispose = function() {
                N.removeEventListener("webglcontextlost", r, !1), N.removeEventListener("webglcontextrestored", a, !1), Bt.dispose(), te.dispose()
            }, this.renderBufferImmediate = function(t, e, i) {
                Pt.initAttributes();
                var n = Rt.get(t);
                t.hasPositions && !n.position && (n.position = Mt.createBuffer()), t.hasNormals && !n.normal && (n.normal = Mt.createBuffer()), t.hasUvs && !n.uv && (n.uv = Mt.createBuffer()), t.hasColors && !n.color && (n.color = Mt.createBuffer());
                var r = e.getAttributes();
                if (t.hasPositions && (Mt.bindBuffer(Mt.ARRAY_BUFFER, n.position), Mt.bufferData(Mt.ARRAY_BUFFER, t.positionArray, Mt.DYNAMIC_DRAW), Pt.enableAttribute(r.position), Mt.vertexAttribPointer(r.position, 3, Mt.FLOAT, !1, 0, 0)), t.hasNormals) {
                    if (Mt.bindBuffer(Mt.ARRAY_BUFFER, n.normal), !i.isMeshPhongMaterial && !i.isMeshStandardMaterial && !i.isMeshNormalMaterial && !0 === i.flatShading)
                        for (var o = 0, a = 3 * t.count; o < a; o += 9) {
                            var s = t.normalArray,
                                l = (s[o + 0] + s[o + 3] + s[o + 6]) / 3,
                                c = (s[o + 1] + s[o + 4] + s[o + 7]) / 3,
                                u = (s[o + 2] + s[o + 5] + s[o + 8]) / 3;
                            s[o + 0] = l, s[o + 1] = c, s[o + 2] = u, s[o + 3] = l, s[o + 4] = c, s[o + 5] = u, s[o + 6] = l, s[o + 7] = c, s[o + 8] = u
                        }
                    Mt.bufferData(Mt.ARRAY_BUFFER, t.normalArray, Mt.DYNAMIC_DRAW), Pt.enableAttribute(r.normal), Mt.vertexAttribPointer(r.normal, 3, Mt.FLOAT, !1, 0, 0)
                }
                t.hasUvs && i.map && (Mt.bindBuffer(Mt.ARRAY_BUFFER, n.uv), Mt.bufferData(Mt.ARRAY_BUFFER, t.uvArray, Mt.DYNAMIC_DRAW), Pt.enableAttribute(r.uv), Mt.vertexAttribPointer(r.uv, 2, Mt.FLOAT, !1, 0, 0)), t.hasColors && i.vertexColors !== Qr && (Mt.bindBuffer(Mt.ARRAY_BUFFER, n.color), Mt.bufferData(Mt.ARRAY_BUFFER, t.colorArray, Mt.DYNAMIC_DRAW), Pt.enableAttribute(r.color), Mt.vertexAttribPointer(r.color, 3, Mt.FLOAT, !1, 0, 0)), Pt.disableUnusedAttributes(), Mt.drawArrays(Mt.TRIANGLES, 0, t.count), t.count = 0
            }, this.renderBufferDirect = function(t, i, n, r, o, a) {
                Pt.setMaterial(r);
                var s = x(t, i, r, o),
                    l = n.id + "_" + s.id + "_" + (!0 === r.wireframe),
                    c = !1;
                l !== it && (it = l, c = !0), o.morphTargetInfluences && (Ht.update(o, n, r, s), c = !0);
                var u = n.index,
                    h = n.attributes.position,
                    d = 1;
                !0 === r.wireframe && (u = Dt.getWireframeAttribute(n), d = 2);
                var f, m = qt;
                null !== u && (f = It.get(u), (m = Zt).setIndex(f)), c && (p(r, s, n), null !== u && Mt.bindBuffer(Mt.ELEMENT_ARRAY_BUFFER, f.buffer));
                var g = 0;
                null !== u ? g = u.count : void 0 !== h && (g = h.count);
                var v = n.drawRange.start * d,
                    y = n.drawRange.count * d,
                    _ = null !== a ? a.start * d : 0,
                    b = null !== a ? a.count * d : 1 / 0,
                    w = Math.max(v, _),
                    T = Math.min(g, v + y, _ + b) - 1,
                    S = Math.max(0, T - w + 1);
                if (0 !== S) {
                    if (o.isMesh)
                        if (!0 === r.wireframe) Pt.setLineWidth(r.wireframeLinewidth * e()), m.setMode(Mt.LINES);
                        else switch (o.drawMode) {
                            case Pa:
                                m.setMode(Mt.TRIANGLES);
                                break;
                            case Ra:
                                m.setMode(Mt.TRIANGLE_STRIP);
                                break;
                            case Oa:
                                m.setMode(Mt.TRIANGLE_FAN)
                        } else if (o.isLine) {
                            var E = r.linewidth;
                            void 0 === E && (E = 1), Pt.setLineWidth(E * e()), o.isLineSegments ? m.setMode(Mt.LINES) : o.isLineLoop ? m.setMode(Mt.LINE_LOOP) : m.setMode(Mt.LINE_STRIP)
                        } else o.isPoints && m.setMode(Mt.POINTS);
                    n && n.isInstancedBufferGeometry ? n.maxInstancedCount > 0 && m.renderInstances(n, w, S) : m.render(w, S)
                }
            }, this.compile = function(t, e) {
                G.length = 0, V.length = 0, t.traverse(function(t) {
                    t.isLight && (G.push(t), t.castShadow && V.push(t))
                }), Ft.setup(G, V, e), t.traverse(function(e) {
                    if (e.material)
                        if (Array.isArray(e.material))
                            for (var i = 0; i < e.material.length; i++) _(e.material[i], t.fog, e);
                        else _(e.material, t.fog, e)
                })
            };
            var ie = !1,
                ne = null;
            this.animate = function(t) {
                ne = t, f()
            }, this.render = function(t, e, i, n) {
                if (e && e.isCamera) {
                    if (!$) {
                        it = "", et = -1, nt = null, !0 === t.autoUpdate && t.updateMatrixWorld(), null === e.parent && e.updateMatrixWorld(), te.enabled && (e = te.getCamera(e)), wt.multiplyMatrices(e.projectionMatrix, e.matrixWorldInverse), yt.setFromMatrix(wt), G.length = 0, V.length = 0, q.length = 0, Y.length = 0, bt = this.localClippingEnabled, xt = _t.init(this.clippingPlanes, bt, e), (W = Bt.get(t, e)).init(), g(t, e, Z.sortObjects), !0 === Z.sortObjects && W.sort(), xt && _t.beginShadows(), ee.render(V, t, e), Ft.setup(G, V, e), xt && _t.endShadows(), Et.frame++, Et.calls = 0, Et.vertices = 0, Et.faces = 0, Et.points = 0, void 0 === i && (i = null), this.setRenderTarget(i), zt.render(W, t, e, n);
                        var r = W.opaque,
                            o = W.transparent;
                        if (t.overrideMaterial) {
                            var a = t.overrideMaterial;
                            r.length && v(r, t, e, a), o.length && v(o, t, e, a)
                        } else r.length && v(r, t, e), o.length && v(o, t, e);
                        $t.render(q, t, e), Jt.render(Y, t, e, lt), i && Ot.updateRenderTargetMipmap(i), Pt.buffers.depth.setTest(!0), Pt.buffers.depth.setMask(!0), Pt.buffers.color.setMask(!0), Pt.setPolygonOffset(!1), te.enabled && te.submitFrame()
                    }
                } else console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.")
            }, this.setFaceCulling = function(t, e) {
                Pt.setCullFace(t), Pt.setFlipSided(e === Gr)
            }, this.allocTextureUnit = function() {
                var t = ht;
                return t >= Ct.maxTextures && console.warn("THREE.WebGLRenderer: Trying to use " + t + " texture units while this GPU supports only " + Ct.maxTextures), ht += 1, t
            }, this.setTexture2D = function() {
                var t = !1;
                return function(e, i) {
                    e && e.isWebGLRenderTarget && (t || (console.warn("THREE.WebGLRenderer.setTexture2D: don't use render targets as textures. Use their .texture property instead."), t = !0), e = e.texture), Ot.setTexture2D(e, i)
                }
            }(), this.setTexture = function() {
                var t = !1;
                return function(e, i) {
                    t || (console.warn("THREE.WebGLRenderer: .setTexture is deprecated, use setTexture2D instead."), t = !0), Ot.setTexture2D(e, i)
                }
            }(), this.setTextureCube = function() {
                var t = !1;
                return function(e, i) {
                    e && e.isWebGLRenderTargetCube && (t || (console.warn("THREE.WebGLRenderer.setTextureCube: don't use cube render targets as textures. Use their .texture property instead."), t = !0), e = e.texture), e && e.isCubeTexture || Array.isArray(e.image) && 6 === e.image.length ? Ot.setTextureCube(e, i) : Ot.setTextureCubeDynamic(e, i)
                }
            }(), this.getRenderTarget = function() {
                return K
            }, this.setRenderTarget = function(t) {
                K = t, t && void 0 === Rt.get(t).__webglFramebuffer && Ot.setupRenderTarget(t);
                var e = null,
                    i = !1;
                if (t) {
                    var n = Rt.get(t).__webglFramebuffer;
                    t.isWebGLRenderTargetCube ? (e = n[t.activeCubeFace], i = !0) : e = n, lt.copy(t.viewport), ct.copy(t.scissor), ut = t.scissorTest
                } else lt.copy(mt).multiplyScalar(ft), ct.copy(gt).multiplyScalar(ft), ut = vt;
                if (tt !== e && (Mt.bindFramebuffer(Mt.FRAMEBUFFER, e), tt = e), Pt.viewport(lt), Pt.scissor(ct), Pt.setScissorTest(ut), i) {
                    var r = Rt.get(t.texture);
                    Mt.framebufferTexture2D(Mt.FRAMEBUFFER, Mt.COLOR_ATTACHMENT0, Mt.TEXTURE_CUBE_MAP_POSITIVE_X + t.activeCubeFace, r.__webglTexture, t.activeMipMapLevel)
                }
            }, this.readRenderTargetPixels = function(t, e, i, n, r, o) {
                if (t && t.isWebGLRenderTarget) {
                    var a = Rt.get(t).__webglFramebuffer;
                    if (a) {
                        var s = !1;
                        a !== tt && (Mt.bindFramebuffer(Mt.FRAMEBUFFER, a), s = !0);
                        try {
                            var l = t.texture,
                                c = l.format,
                                u = l.type;
                            if (c !== pa && Kt.convert(c) !== Mt.getParameter(Mt.IMPLEMENTATION_COLOR_READ_FORMAT)) return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
                            if (!(u === Ko || Kt.convert(u) === Mt.getParameter(Mt.IMPLEMENTATION_COLOR_READ_TYPE) || u === oa && (Lt.get("OES_texture_float") || Lt.get("WEBGL_color_buffer_float")) || u === aa && Lt.get("EXT_color_buffer_half_float"))) return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
                            Mt.checkFramebufferStatus(Mt.FRAMEBUFFER) === Mt.FRAMEBUFFER_COMPLETE ? e >= 0 && e <= t.width - n && i >= 0 && i <= t.height - r && Mt.readPixels(e, i, n, r, Kt.convert(c), Kt.convert(u), o) : console.error("THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.")
                        } finally {
                            s && Mt.bindFramebuffer(Mt.FRAMEBUFFER, tt)
                        }
                    }
                } else console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.")
            }
        }

        function we(t, e) {
            this.name = "", this.color = new q(t), this.density = void 0 !== e ? e : 25e-5
        }

        function Te(t, e, i) {
            this.name = "", this.color = new q(t), this.near = void 0 !== e ? e : 1, this.far = void 0 !== i ? i : 1e3
        }

        function Se() {
            ct.call(this), this.type = "Scene", this.background = null, this.fog = null, this.overrideMaterial = null, this.autoUpdate = !0
        }

        function Ee(t, e, i, n, r) {
            ct.call(this), this.lensFlares = [], this.positionScreen = new o, this.customUpdateCallback = void 0, void 0 !== t && this.add(t, e, i, n, r)
        }

        function Me(t) {
            $.call(this), this.type = "SpriteMaterial", this.color = new q(16777215), this.map = null, this.rotation = 0, this.fog = !1, this.lights = !1, this.setValues(t)
        }

        function Ae(t) {
            ct.call(this), this.type = "Sprite", this.material = void 0 !== t ? t : new Me
        }

        function Le() {
            ct.call(this), this.type = "LOD", Object.defineProperties(this, {
                levels: {
                    enumerable: !0,
                    value: []
                }
            })
        }

        function Ce(t, e) {
            if (t = t || [], this.bones = t.slice(0), this.boneMatrices = new Float32Array(16 * this.bones.length), void 0 === e) this.calculateInverses();
            else if (this.bones.length === e.length) this.boneInverses = e.slice(0);
            else {
                console.warn("THREE.Skeleton boneInverses is the wrong length."), this.boneInverses = [];
                for (var i = 0, r = this.bones.length; i < r; i++) this.boneInverses.push(new n)
            }
        }

        function Pe() {
            ct.call(this), this.type = "Bone"
        }

        function Re(t, e) {
            Ft.call(this, t, e), this.type = "SkinnedMesh", this.bindMode = "attached", this.bindMatrix = new n, this.bindMatrixInverse = new n;
            var i = new Ce(this.initBones());
            this.bind(i, this.matrixWorld), this.normalizeSkinWeights()
        }

        function Oe(t) {
            $.call(this), this.type = "LineBasicMaterial", this.color = new q(16777215), this.linewidth = 1, this.linecap = "round", this.linejoin = "round", this.lights = !1, this.setValues(t)
        }

        function Ie(t, e, i) {
            if (1 === i) return console.warn("THREE.Line: parameter THREE.LinePieces no longer supported. Created THREE.LineSegments instead."), new De(t, e);
            ct.call(this), this.type = "Line", this.geometry = void 0 !== t ? t : new Mt, this.material = void 0 !== e ? e : new Oe({
                color: 16777215 * Math.random()
            })
        }

        function De(t, e) {
            Ie.call(this, t, e), this.type = "LineSegments"
        }

        function Ne(t, e) {
            Ie.call(this, t, e), this.type = "LineLoop"
        }

        function Fe(t) {
            $.call(this), this.type = "PointsMaterial", this.color = new q(16777215), this.map = null, this.size = 1, this.sizeAttenuation = !0, this.lights = !1, this.setValues(t)
        }

        function ke(t, e) {
            ct.call(this), this.type = "Points", this.geometry = void 0 !== t ? t : new Mt, this.material = void 0 !== e ? e : new Fe({
                color: 16777215 * Math.random()
            })
        }

        function Ue() {
            ct.call(this), this.type = "Group"
        }

        function Be(t, e, i, n, r, o, a, l, c) {
            function u() {
                var t = h.image;
                t.readyState >= t.HAVE_CURRENT_DATA && (h.needsUpdate = !0), requestAnimationFrame(u)
            }
            s.call(this, t, e, i, n, r, o, a, l, c), this.generateMipmaps = !1;
            var h = this;
            requestAnimationFrame(u)
        }

        function ze(t, e, i, n, r, o, a, l, c, u, h, d) {
            s.call(this, null, o, a, l, c, u, n, r, h, d), this.image = {
                width: e,
                height: i
            }, this.mipmaps = t, this.flipY = !1, this.generateMipmaps = !1
        }

        function je(t, e, i, n, r, o, a, l, c, u) {
            if ((u = void 0 !== u ? u : va) !== va && u !== ya) throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
            void 0 === i && u === va && (i = ia), void 0 === i && u === ya && (i = ua), s.call(this, null, n, r, o, a, l, u, i, c), this.image = {
                width: t,
                height: e
            }, this.magFilter = void 0 !== a ? a : qo, this.minFilter = void 0 !== l ? l : qo, this.flipY = !1, this.generateMipmaps = !1
        }

        function He(t) {
            Mt.call(this), this.type = "WireframeGeometry";
            var e, i, n, r, a, s, l, c, u, h, d = [],
                p = [0, 0],
                f = {},
                m = ["a", "b", "c"];
            if (t && t.isGeometry) {
                var g = t.faces;
                for (e = 0, n = g.length; e < n; e++) {
                    var v = g[e];
                    for (i = 0; i < 3; i++) l = v[m[i]], c = v[m[(i + 1) % 3]], p[0] = Math.min(l, c), p[1] = Math.max(l, c), void 0 === f[u = p[0] + "," + p[1]] && (f[u] = {
                        index1: p[0],
                        index2: p[1]
                    })
                }
                for (u in f) s = f[u], h = t.vertices[s.index1], d.push(h.x, h.y, h.z), h = t.vertices[s.index2], d.push(h.x, h.y, h.z)
            } else if (t && t.isBufferGeometry) {
                var y, _, x, b, w, T, S;
                if (h = new o, null !== t.index) {
                    for (y = t.attributes.position, _ = t.index, 0 === (x = t.groups).length && (x = [{
                            start: 0,
                            count: _.count,
                            materialIndex: 0
                        }]), r = 0, a = x.length; r < a; ++r)
                        for (e = w = (b = x[r]).start, n = w + b.count; e < n; e += 3)
                            for (i = 0; i < 3; i++) l = _.getX(e + i), c = _.getX(e + (i + 1) % 3), p[0] = Math.min(l, c), p[1] = Math.max(l, c), void 0 === f[u = p[0] + "," + p[1]] && (f[u] = {
                                index1: p[0],
                                index2: p[1]
                            });
                    for (u in f) s = f[u], h.fromBufferAttribute(y, s.index1), d.push(h.x, h.y, h.z), h.fromBufferAttribute(y, s.index2), d.push(h.x, h.y, h.z)
                } else
                    for (e = 0, n = (y = t.attributes.position).count / 3; e < n; e++)
                        for (i = 0; i < 3; i++) T = 3 * e + i, h.fromBufferAttribute(y, T), d.push(h.x, h.y, h.z), S = 3 * e + (i + 1) % 3, h.fromBufferAttribute(y, S), d.push(h.x, h.y, h.z)
            }
            this.addAttribute("position", new wt(d, 3))
        }

        function Ge(t, e, i) {
            pt.call(this), this.type = "ParametricGeometry", this.parameters = {
                func: t,
                slices: e,
                stacks: i
            }, this.fromBufferGeometry(new Ve(t, e, i)), this.mergeVertices()
        }

        function Ve(t, e, i) {
            Mt.call(this), this.type = "ParametricBufferGeometry", this.parameters = {
                func: t,
                slices: e,
                stacks: i
            };
            var n, r, a = [],
                s = [],
                l = [],
                c = [],
                u = new o,
                h = new o,
                d = new o,
                p = new o,
                f = new o,
                m = e + 1;
            for (n = 0; n <= i; n++) {
                var g = n / i;
                for (r = 0; r <= e; r++) {
                    var v = r / e;
                    h = t(v, g, h), s.push(h.x, h.y, h.z), v - 1e-5 >= 0 ? (d = t(v - 1e-5, g, d), p.subVectors(h, d)) : (d = t(v + 1e-5, g, d), p.subVectors(d, h)), g - 1e-5 >= 0 ? (d = t(v, g - 1e-5, d), f.subVectors(h, d)) : (d = t(v, g + 1e-5, d), f.subVectors(d, h)), u.crossVectors(p, f).normalize(), l.push(u.x, u.y, u.z), c.push(v, g)
                }
            }
            for (n = 0; n < i; n++)
                for (r = 0; r < e; r++) {
                    var y = n * m + r,
                        _ = n * m + r + 1,
                        x = (n + 1) * m + r + 1,
                        b = (n + 1) * m + r;
                    a.push(y, _, b), a.push(_, x, b)
                }
            this.setIndex(a), this.addAttribute("position", new wt(s, 3)), this.addAttribute("normal", new wt(l, 3)), this.addAttribute("uv", new wt(c, 2))
        }

        function We(t, e, i, n) {
            pt.call(this), this.type = "PolyhedronGeometry", this.parameters = {
                vertices: t,
                indices: e,
                radius: i,
                detail: n
            }, this.fromBufferGeometry(new Xe(t, e, i, n)), this.mergeVertices()
        }

        function Xe(t, e, n, r) {
            function a(t, e, i, n) {
                var r, o, a = Math.pow(2, n),
                    s = [];
                for (r = 0; r <= a; r++) {
                    s[r] = [];
                    var c = t.clone().lerp(i, r / a),
                        u = e.clone().lerp(i, r / a),
                        h = a - r;
                    for (o = 0; o <= h; o++) s[r][o] = 0 === o && r === a ? c : c.clone().lerp(u, o / h)
                }
                for (r = 0; r < a; r++)
                    for (o = 0; o < 2 * (a - r) - 1; o++) {
                        var d = Math.floor(o / 2);
                        o % 2 == 0 ? (l(s[r][d + 1]), l(s[r + 1][d]), l(s[r][d])) : (l(s[r][d + 1]), l(s[r + 1][d + 1]), l(s[r + 1][d]))
                    }
            }

            function s() {
                for (var t = 0; t < m.length; t += 6) {
                    var e = m[t + 0],
                        i = m[t + 2],
                        n = m[t + 4],
                        r = Math.max(e, i, n),
                        o = Math.min(e, i, n);
                    r > .9 && o < .1 && (e < .2 && (m[t + 0] += 1), i < .2 && (m[t + 2] += 1), n < .2 && (m[t + 4] += 1))
                }
            }

            function l(t) {
                f.push(t.x, t.y, t.z)
            }

            function c(e, i) {
                var n = 3 * e;
                i.x = t[n + 0], i.y = t[n + 1], i.z = t[n + 2]
            }

            function u() {
                for (var t = new o, e = new o, n = new o, r = new o, a = new i, s = new i, l = new i, c = 0, u = 0; c < f.length; c += 9, u += 6) {
                    t.set(f[c + 0], f[c + 1], f[c + 2]), e.set(f[c + 3], f[c + 4], f[c + 5]), n.set(f[c + 6], f[c + 7], f[c + 8]), a.set(m[u + 0], m[u + 1]), s.set(m[u + 2], m[u + 3]), l.set(m[u + 4], m[u + 5]), r.copy(t).add(e).add(n).divideScalar(3);
                    var p = d(r);
                    h(a, u + 0, t, p), h(s, u + 2, e, p), h(l, u + 4, n, p)
                }
            }

            function h(t, e, i, n) {
                n < 0 && 1 === t.x && (m[e] = t.x - 1), 0 === i.x && 0 === i.z && (m[e] = n / 2 / Math.PI + .5)
            }

            function d(t) {
                return Math.atan2(t.z, -t.x)
            }

            function p(t) {
                return Math.atan2(-t.y, Math.sqrt(t.x * t.x + t.z * t.z))
            }
            Mt.call(this), this.type = "PolyhedronBufferGeometry", this.parameters = {
                vertices: t,
                indices: e,
                radius: n,
                detail: r
            }, n = n || 1;
            var f = [],
                m = [];
            ! function(t) {
                for (var i = new o, n = new o, r = new o, s = 0; s < e.length; s += 3) c(e[s + 0], i), c(e[s + 1], n), c(e[s + 2], r), a(i, n, r, t)
            }(r = r || 0),
            function(t) {
                for (var e = new o, i = 0; i < f.length; i += 3) e.x = f[i + 0], e.y = f[i + 1], e.z = f[i + 2], e.normalize().multiplyScalar(t), f[i + 0] = e.x, f[i + 1] = e.y, f[i + 2] = e.z
            }(n),
            function() {
                for (var t = new o, e = 0; e < f.length; e += 3) {
                    t.x = f[e + 0], t.y = f[e + 1], t.z = f[e + 2];
                    var i = d(t) / 2 / Math.PI + .5,
                        n = p(t) / Math.PI + .5;
                    m.push(i, 1 - n)
                }
                u(), s()
            }(), this.addAttribute("position", new wt(f, 3)), this.addAttribute("normal", new wt(f.slice(), 3)), this.addAttribute("uv", new wt(m, 2)), 0 === r ? this.computeVertexNormals() : this.normalizeNormals()
        }

        function qe(t, e) {
            pt.call(this), this.type = "TetrahedronGeometry", this.parameters = {
                radius: t,
                detail: e
            }, this.fromBufferGeometry(new Ye(t, e)), this.mergeVertices()
        }

        function Ye(t, e) {
            var i = [1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1],
                n = [2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1];
            Xe.call(this, i, n, t, e), this.type = "TetrahedronBufferGeometry", this.parameters = {
                radius: t,
                detail: e
            }
        }

        function Qe(t, e) {
            pt.call(this), this.type = "OctahedronGeometry", this.parameters = {
                radius: t,
                detail: e
            }, this.fromBufferGeometry(new Ze(t, e)), this.mergeVertices()
        }

        function Ze(t, e) {
            var i = [1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1],
                n = [0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4, 2];
            Xe.call(this, i, n, t, e), this.type = "OctahedronBufferGeometry", this.parameters = {
                radius: t,
                detail: e
            }
        }

        function Je(t, e) {
            pt.call(this), this.type = "IcosahedronGeometry", this.parameters = {
                radius: t,
                detail: e
            }, this.fromBufferGeometry(new $e(t, e)), this.mergeVertices()
        }

        function $e(t, e) {
            var i = (1 + Math.sqrt(5)) / 2,
                n = [-1, i, 0, 1, i, 0, -1, -i, 0, 1, -i, 0, 0, -1, i, 0, 1, i, 0, -1, -i, 0, 1, -i, i, 0, -1, i, 0, 1, -i, 0, -1, -i, 0, 1],
                r = [0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4, 11, 10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9, 4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1];
            Xe.call(this, n, r, t, e), this.type = "IcosahedronBufferGeometry", this.parameters = {
                radius: t,
                detail: e
            }
        }

        function Ke(t, e) {
            pt.call(this), this.type = "DodecahedronGeometry", this.parameters = {
                radius: t,
                detail: e
            }, this.fromBufferGeometry(new ti(t, e)), this.mergeVertices()
        }

        function ti(t, e) {
            var i = (1 + Math.sqrt(5)) / 2,
                n = 1 / i,
                r = [-1, -1, -1, -1, -1, 1, -1, 1, -1, -1, 1, 1, 1, -1, -1, 1, -1, 1, 1, 1, -1, 1, 1, 1, 0, -n, -i, 0, -n, i, 0, n, -i, 0, n, i, -n, -i, 0, -n, i, 0, n, -i, 0, n, i, 0, -i, 0, -n, i, 0, -n, -i, 0, n, i, 0, n],
                o = [3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6, 15, 17, 4, 8, 17, 8, 10, 17, 10, 6, 8, 0, 16, 8, 16, 2, 8, 2, 10, 0, 12, 1, 0, 1, 18, 0, 18, 16, 6, 10, 2, 6, 2, 13, 6, 13, 15, 2, 16, 18, 2, 18, 3, 2, 3, 13, 18, 1, 9, 18, 9, 11, 18, 11, 3, 4, 14, 12, 4, 12, 0, 4, 0, 8, 11, 9, 5, 11, 5, 19, 11, 19, 7, 19, 5, 14, 19, 14, 4, 19, 4, 17, 1, 12, 14, 1, 14, 5, 1, 5, 9];
            Xe.call(this, r, o, t, e), this.type = "DodecahedronBufferGeometry", this.parameters = {
                radius: t,
                detail: e
            }
        }

        function ei(t, e, i, n, r, o) {
            pt.call(this), this.type = "TubeGeometry", this.parameters = {
                path: t,
                tubularSegments: e,
                radius: i,
                radialSegments: n,
                closed: r
            }, void 0 !== o && console.warn("THREE.TubeGeometry: taper has been removed.");
            var a = new ii(t, e, i, n, r);
            this.tangents = a.tangents, this.normals = a.normals, this.binormals = a.binormals, this.fromBufferGeometry(a), this.mergeVertices()
        }

        function ii(t, e, n, r, a) {
            function s(i) {
                g = t.getPointAt(i / e, g);
                var o = u.normals[i],
                    a = u.binormals[i];
                for (d = 0; d <= r; d++) {
                    var s = d / r * Math.PI * 2,
                        l = Math.sin(s),
                        c = -Math.cos(s);
                    f.x = c * o.x + l * a.x, f.y = c * o.y + l * a.y, f.z = c * o.z + l * a.z, f.normalize(), y.push(f.x, f.y, f.z), p.x = g.x + n * f.x, p.y = g.y + n * f.y, p.z = g.z + n * f.z, v.push(p.x, p.y, p.z)
                }
            }

            function l() {
                for (d = 1; d <= e; d++)
                    for (h = 1; h <= r; h++) {
                        var t = (r + 1) * (d - 1) + (h - 1),
                            i = (r + 1) * d + (h - 1),
                            n = (r + 1) * d + h,
                            o = (r + 1) * (d - 1) + h;
                        x.push(t, i, o), x.push(i, n, o)
                    }
            }

            function c() {
                for (h = 0; h <= e; h++)
                    for (d = 0; d <= r; d++) m.x = h / e, m.y = d / r, _.push(m.x, m.y)
            }
            Mt.call(this), this.type = "TubeBufferGeometry", this.parameters = {
                path: t,
                tubularSegments: e,
                radius: n,
                radialSegments: r,
                closed: a
            }, e = e || 64, n = n || 1, r = r || 8, a = a || !1;
            var u = t.computeFrenetFrames(e, a);
            this.tangents = u.tangents, this.normals = u.normals, this.binormals = u.binormals;
            var h, d, p = new o,
                f = new o,
                m = new i,
                g = new o,
                v = [],
                y = [],
                _ = [],
                x = [];
            ! function() {
                for (h = 0; h < e; h++) s(h);
                s(!1 === a ? e : 0), c(), l()
            }(), this.setIndex(x), this.addAttribute("position", new wt(v, 3)), this.addAttribute("normal", new wt(y, 3)), this.addAttribute("uv", new wt(_, 2))
        }

        function ni(t, e, i, n, r, o, a) {
            pt.call(this), this.type = "TorusKnotGeometry", this.parameters = {
                radius: t,
                tube: e,
                tubularSegments: i,
                radialSegments: n,
                p: r,
                q: o
            }, void 0 !== a && console.warn("THREE.TorusKnotGeometry: heightScale has been deprecated. Use .scale( x, y, z ) instead."), this.fromBufferGeometry(new ri(t, e, i, n, r, o)), this.mergeVertices()
        }

        function ri(t, e, i, n, r, a) {
            function s(t, e, i, n, r) {
                var o = Math.cos(t),
                    a = Math.sin(t),
                    s = i / e * t,
                    l = Math.cos(s);
                r.x = n * (2 + l) * .5 * o, r.y = n * (2 + l) * a * .5, r.z = n * Math.sin(s) * .5
            }
            Mt.call(this), this.type = "TorusKnotBufferGeometry", this.parameters = {
                radius: t,
                tube: e,
                tubularSegments: i,
                radialSegments: n,
                p: r,
                q: a
            }, t = t || 1, e = e || .4, i = Math.floor(i) || 64, n = Math.floor(n) || 8, r = r || 2, a = a || 3;
            var l, c, u = [],
                h = [],
                d = [],
                p = [],
                f = new o,
                m = new o,
                g = new o,
                v = new o,
                y = new o,
                _ = new o,
                x = new o;
            for (l = 0; l <= i; ++l) {
                var b = l / i * r * Math.PI * 2;
                for (s(b, r, a, t, g), s(b + .01, r, a, t, v), _.subVectors(v, g), x.addVectors(v, g), y.crossVectors(_, x), x.crossVectors(y, _), y.normalize(), x.normalize(), c = 0; c <= n; ++c) {
                    var w = c / n * Math.PI * 2,
                        T = -e * Math.cos(w),
                        S = e * Math.sin(w);
                    f.x = g.x + (T * x.x + S * y.x), f.y = g.y + (T * x.y + S * y.y), f.z = g.z + (T * x.z + S * y.z), h.push(f.x, f.y, f.z), m.subVectors(f, g).normalize(), d.push(m.x, m.y, m.z), p.push(l / i), p.push(c / n)
                }
            }
            for (c = 1; c <= i; c++)
                for (l = 1; l <= n; l++) {
                    var E = (n + 1) * (c - 1) + (l - 1),
                        M = (n + 1) * c + (l - 1),
                        A = (n + 1) * c + l,
                        L = (n + 1) * (c - 1) + l;
                    u.push(E, M, L), u.push(M, A, L)
                }
            this.setIndex(u), this.addAttribute("position", new wt(h, 3)), this.addAttribute("normal", new wt(d, 3)), this.addAttribute("uv", new wt(p, 2))
        }

        function oi(t, e, i, n, r) {
            pt.call(this), this.type = "TorusGeometry", this.parameters = {
                radius: t,
                tube: e,
                radialSegments: i,
                tubularSegments: n,
                arc: r
            }, this.fromBufferGeometry(new ai(t, e, i, n, r)), this.mergeVertices()
        }

        function ai(t, e, i, n, r) {
            Mt.call(this), this.type = "TorusBufferGeometry", this.parameters = {
                radius: t,
                tube: e,
                radialSegments: i,
                tubularSegments: n,
                arc: r
            }, t = t || 1, e = e || .4, i = Math.floor(i) || 8, n = Math.floor(n) || 6, r = r || 2 * Math.PI;
            var a, s, l = [],
                c = [],
                u = [],
                h = [],
                d = new o,
                p = new o,
                f = new o;
            for (a = 0; a <= i; a++)
                for (s = 0; s <= n; s++) {
                    var m = s / n * r,
                        g = a / i * Math.PI * 2;
                    p.x = (t + e * Math.cos(g)) * Math.cos(m), p.y = (t + e * Math.cos(g)) * Math.sin(m), p.z = e * Math.sin(g), c.push(p.x, p.y, p.z), d.x = t * Math.cos(m), d.y = t * Math.sin(m), f.subVectors(p, d).normalize(), u.push(f.x, f.y, f.z), h.push(s / n), h.push(a / i)
                }
            for (a = 1; a <= i; a++)
                for (s = 1; s <= n; s++) {
                    var v = (n + 1) * a + s - 1,
                        y = (n + 1) * (a - 1) + s - 1,
                        _ = (n + 1) * (a - 1) + s,
                        x = (n + 1) * a + s;
                    l.push(v, y, x), l.push(y, _, x)
                }
            this.setIndex(l), this.addAttribute("position", new wt(c, 3)), this.addAttribute("normal", new wt(u, 3)), this.addAttribute("uv", new wt(h, 2))
        }

        function si(t, e) {
            pt.call(this), this.type = "ExtrudeGeometry", this.parameters = {
                shapes: t,
                options: e
            }, this.fromBufferGeometry(new li(t, e)), this.mergeVertices()
        }

        function li(t, e) {
            void 0 !== t && (Mt.call(this), this.type = "ExtrudeBufferGeometry", t = Array.isArray(t) ? t : [t], this.addShapeList(t, e), this.computeVertexNormals())
        }

        function ci(t, e) {
            pt.call(this), this.type = "TextGeometry", this.parameters = {
                text: t,
                parameters: e
            }, this.fromBufferGeometry(new ui(t, e)), this.mergeVertices()
        }

        function ui(t, e) {
            var i = (e = e || {}).font;
            if (!i || !i.isFont) return console.error("THREE.TextGeometry: font parameter is not an instance of THREE.Font."), new pt;
            var n = i.generateShapes(t, e.size, e.curveSegments);
            e.amount = void 0 !== e.height ? e.height : 50, void 0 === e.bevelThickness && (e.bevelThickness = 10), void 0 === e.bevelSize && (e.bevelSize = 8), void 0 === e.bevelEnabled && (e.bevelEnabled = !1), li.call(this, n, e), this.type = "TextBufferGeometry"
        }

        function hi(t, e, i, n, r, o, a) {
            pt.call(this), this.type = "SphereGeometry", this.parameters = {
                radius: t,
                widthSegments: e,
                heightSegments: i,
                phiStart: n,
                phiLength: r,
                thetaStart: o,
                thetaLength: a
            }, this.fromBufferGeometry(new di(t, e, i, n, r, o, a)), this.mergeVertices()
        }

        function di(t, e, i, n, r, a, s) {
            Mt.call(this), this.type = "SphereBufferGeometry", this.parameters = {
                radius: t,
                widthSegments: e,
                heightSegments: i,
                phiStart: n,
                phiLength: r,
                thetaStart: a,
                thetaLength: s
            }, t = t || 1, e = Math.max(3, Math.floor(e) || 8), i = Math.max(2, Math.floor(i) || 6), n = void 0 !== n ? n : 0, r = void 0 !== r ? r : 2 * Math.PI;
            var l, c, u = (a = void 0 !== a ? a : 0) + (s = void 0 !== s ? s : Math.PI),
                h = 0,
                d = [],
                p = new o,
                f = new o,
                m = [],
                g = [],
                v = [],
                y = [];
            for (c = 0; c <= i; c++) {
                var _ = [],
                    x = c / i;
                for (l = 0; l <= e; l++) {
                    var b = l / e;
                    p.x = -t * Math.cos(n + b * r) * Math.sin(a + x * s), p.y = t * Math.cos(a + x * s), p.z = t * Math.sin(n + b * r) * Math.sin(a + x * s), g.push(p.x, p.y, p.z), f.set(p.x, p.y, p.z).normalize(), v.push(f.x, f.y, f.z), y.push(b, 1 - x), _.push(h++)
                }
                d.push(_)
            }
            for (c = 0; c < i; c++)
                for (l = 0; l < e; l++) {
                    var w = d[c][l + 1],
                        T = d[c][l],
                        S = d[c + 1][l],
                        E = d[c + 1][l + 1];
                    (0 !== c || a > 0) && m.push(w, T, E), (c !== i - 1 || u < Math.PI) && m.push(T, S, E)
                }
            this.setIndex(m), this.addAttribute("position", new wt(g, 3)), this.addAttribute("normal", new wt(v, 3)), this.addAttribute("uv", new wt(y, 2))
        }

        function pi(t, e, i, n, r, o) {
            pt.call(this), this.type = "RingGeometry", this.parameters = {
                innerRadius: t,
                outerRadius: e,
                thetaSegments: i,
                phiSegments: n,
                thetaStart: r,
                thetaLength: o
            }, this.fromBufferGeometry(new fi(t, e, i, n, r, o)), this.mergeVertices()
        }

        function fi(t, e, n, r, a, s) {
            Mt.call(this), this.type = "RingBufferGeometry", this.parameters = {
                innerRadius: t,
                outerRadius: e,
                thetaSegments: n,
                phiSegments: r,
                thetaStart: a,
                thetaLength: s
            }, t = t || .5, e = e || 1, a = void 0 !== a ? a : 0, s = void 0 !== s ? s : 2 * Math.PI, n = void 0 !== n ? Math.max(3, n) : 8;
            var l, c, u, h = [],
                d = [],
                p = [],
                f = [],
                m = t,
                g = (e - t) / (r = void 0 !== r ? Math.max(1, r) : 1),
                v = new o,
                y = new i;
            for (c = 0; c <= r; c++) {
                for (u = 0; u <= n; u++) l = a + u / n * s, v.x = m * Math.cos(l), v.y = m * Math.sin(l), d.push(v.x, v.y, v.z), p.push(0, 0, 1), y.x = (v.x / e + 1) / 2, y.y = (v.y / e + 1) / 2, f.push(y.x, y.y);
                m += g
            }
            for (c = 0; c < r; c++) {
                var _ = c * (n + 1);
                for (u = 0; u < n; u++) {
                    var x = l = u + _,
                        b = l + n + 1,
                        w = l + n + 2,
                        T = l + 1;
                    h.push(x, b, T), h.push(b, w, T)
                }
            }
            this.setIndex(h), this.addAttribute("position", new wt(d, 3)), this.addAttribute("normal", new wt(p, 3)), this.addAttribute("uv", new wt(f, 2))
        }

        function mi(t, e, i, n) {
            pt.call(this), this.type = "LatheGeometry", this.parameters = {
                points: t,
                segments: e,
                phiStart: i,
                phiLength: n
            }, this.fromBufferGeometry(new gi(t, e, i, n)), this.mergeVertices()
        }

        function gi(t, e, n, r) {
            Mt.call(this), this.type = "LatheBufferGeometry", this.parameters = {
                points: t,
                segments: e,
                phiStart: n,
                phiLength: r
            }, e = Math.floor(e) || 12, n = n || 0, r = r || 2 * Math.PI, r = Ha.clamp(r, 0, 2 * Math.PI);
            var a, s, l, c = [],
                u = [],
                h = [],
                d = 1 / e,
                p = new o,
                f = new i;
            for (s = 0; s <= e; s++) {
                var m = n + s * d * r,
                    g = Math.sin(m),
                    v = Math.cos(m);
                for (l = 0; l <= t.length - 1; l++) p.x = t[l].x * g, p.y = t[l].y, p.z = t[l].x * v, u.push(p.x, p.y, p.z), f.x = s / e, f.y = l / (t.length - 1), h.push(f.x, f.y)
            }
            for (s = 0; s < e; s++)
                for (l = 0; l < t.length - 1; l++) {
                    var y = a = l + s * t.length,
                        _ = a + t.length,
                        x = a + t.length + 1,
                        b = a + 1;
                    c.push(y, _, b), c.push(_, x, b)
                }
            if (this.setIndex(c), this.addAttribute("position", new wt(u, 3)), this.addAttribute("uv", new wt(h, 2)), this.computeVertexNormals(), r === 2 * Math.PI) {
                var w = this.attributes.normal.array,
                    T = new o,
                    S = new o,
                    E = new o;
                for (a = e * t.length * 3, s = 0, l = 0; s < t.length; s++, l += 3) T.x = w[l + 0], T.y = w[l + 1], T.z = w[l + 2], S.x = w[a + l + 0], S.y = w[a + l + 1], S.z = w[a + l + 2], E.addVectors(T, S).normalize(), w[l + 0] = w[a + l + 0] = E.x, w[l + 1] = w[a + l + 1] = E.y, w[l + 2] = w[a + l + 2] = E.z
            }
        }

        function vi(t, e) {
            pt.call(this), this.type = "ShapeGeometry", "object" == typeof e && (console.warn("THREE.ShapeGeometry: Options parameter has been removed."), e = e.curveSegments), this.parameters = {
                shapes: t,
                curveSegments: e
            }, this.fromBufferGeometry(new yi(t, e)), this.mergeVertices()
        }

        function yi(t, e) {
            function i(t) {
                var i, s, c, u = r.length / 3,
                    h = t.extractPoints(e),
                    d = h.shape,
                    p = h.holes;
                if (!1 === ss.isClockWise(d))
                    for (d = d.reverse(), i = 0, s = p.length; i < s; i++) c = p[i], !0 === ss.isClockWise(c) && (p[i] = c.reverse());
                var f = ss.triangulateShape(d, p);
                for (i = 0, s = p.length; i < s; i++) c = p[i], d = d.concat(c);
                for (i = 0, s = d.length; i < s; i++) {
                    var m = d[i];
                    r.push(m.x, m.y, 0), o.push(0, 0, 1), a.push(m.x, m.y)
                }
                for (i = 0, s = f.length; i < s; i++) {
                    var g = f[i],
                        v = g[0] + u,
                        y = g[1] + u,
                        _ = g[2] + u;
                    n.push(v, y, _), l += 3
                }
            }
            Mt.call(this), this.type = "ShapeBufferGeometry", this.parameters = {
                shapes: t,
                curveSegments: e
            }, e = e || 12;
            var n = [],
                r = [],
                o = [],
                a = [],
                s = 0,
                l = 0;
            if (!1 === Array.isArray(t)) i(t);
            else
                for (var c = 0; c < t.length; c++) i(t[c]), this.addGroup(s, l, c), s += l, l = 0;
            this.setIndex(n), this.addAttribute("position", new wt(r, 3)), this.addAttribute("normal", new wt(o, 3)), this.addAttribute("uv", new wt(a, 2))
        }

        function _i(t, e) {
            Mt.call(this), this.type = "EdgesGeometry", this.parameters = {
                thresholdAngle: e
            }, e = void 0 !== e ? e : 1;
            var i, n, r, o, a = [],
                s = Math.cos(Ha.DEG2RAD * e),
                l = [0, 0],
                c = {},
                u = ["a", "b", "c"];
            t.isBufferGeometry ? (o = new pt).fromBufferGeometry(t) : o = t.clone(), o.mergeVertices(), o.computeFaceNormals();
            for (var h = o.vertices, d = o.faces, p = 0, f = d.length; p < f; p++)
                for (var m = d[p], g = 0; g < 3; g++) i = m[u[g]], n = m[u[(g + 1) % 3]], l[0] = Math.min(i, n), l[1] = Math.max(i, n), void 0 === c[r = l[0] + "," + l[1]] ? c[r] = {
                    index1: l[0],
                    index2: l[1],
                    face1: p,
                    face2: void 0
                } : c[r].face2 = p;
            for (r in c) {
                var v = c[r];
                if (void 0 === v.face2 || d[v.face1].normal.dot(d[v.face2].normal) <= s) {
                    var y = h[v.index1];
                    a.push(y.x, y.y, y.z), y = h[v.index2], a.push(y.x, y.y, y.z)
                }
            }
            this.addAttribute("position", new wt(a, 3))
        }

        function xi(t, e, i, n, r, o, a, s) {
            pt.call(this), this.type = "CylinderGeometry", this.parameters = {
                radiusTop: t,
                radiusBottom: e,
                height: i,
                radialSegments: n,
                heightSegments: r,
                openEnded: o,
                thetaStart: a,
                thetaLength: s
            }, this.fromBufferGeometry(new bi(t, e, i, n, r, o, a, s)), this.mergeVertices()
        }

        function bi(t, e, n, r, a, s, l, c) {
            function u(n) {
                var a, s, u, v = new i,
                    x = new o,
                    b = 0,
                    w = !0 === n ? t : e,
                    T = !0 === n ? 1 : -1;
                for (s = g, a = 1; a <= r; a++) p.push(0, y * T, 0), f.push(0, T, 0), m.push(.5, .5), g++;
                for (u = g, a = 0; a <= r; a++) {
                    var S = a / r * c + l,
                        E = Math.cos(S),
                        M = Math.sin(S);
                    x.x = w * M, x.y = y * T, x.z = w * E, p.push(x.x, x.y, x.z), f.push(0, T, 0), v.x = .5 * E + .5, v.y = .5 * M * T + .5, m.push(v.x, v.y), g++
                }
                for (a = 0; a < r; a++) {
                    var A = s + a,
                        L = u + a;
                    !0 === n ? d.push(L, L + 1, A) : d.push(L + 1, L, A), b += 3
                }
                h.addGroup(_, b, !0 === n ? 1 : 2), _ += b
            }
            Mt.call(this), this.type = "CylinderBufferGeometry", this.parameters = {
                radiusTop: t,
                radiusBottom: e,
                height: n,
                radialSegments: r,
                heightSegments: a,
                openEnded: s,
                thetaStart: l,
                thetaLength: c
            };
            var h = this;
            t = void 0 !== t ? t : 1, e = void 0 !== e ? e : 1, n = n || 1, r = Math.floor(r) || 8, a = Math.floor(a) || 1, s = void 0 !== s && s, l = void 0 !== l ? l : 0, c = void 0 !== c ? c : 2 * Math.PI;
            var d = [],
                p = [],
                f = [],
                m = [],
                g = 0,
                v = [],
                y = n / 2,
                _ = 0;
            ! function() {
                var i, s, u = new o,
                    x = new o,
                    b = 0,
                    w = (e - t) / n;
                for (s = 0; s <= a; s++) {
                    var T = [],
                        S = s / a,
                        E = S * (e - t) + t;
                    for (i = 0; i <= r; i++) {
                        var M = i / r,
                            A = M * c + l,
                            L = Math.sin(A),
                            C = Math.cos(A);
                        x.x = E * L, x.y = -S * n + y, x.z = E * C, p.push(x.x, x.y, x.z), u.set(L, w, C).normalize(), f.push(u.x, u.y, u.z), m.push(M, 1 - S), T.push(g++)
                    }
                    v.push(T)
                }
                for (i = 0; i < r; i++)
                    for (s = 0; s < a; s++) {
                        var P = v[s][i],
                            R = v[s + 1][i],
                            O = v[s + 1][i + 1],
                            I = v[s][i + 1];
                        d.push(P, R, I), d.push(R, O, I), b += 6
                    }
                h.addGroup(_, b, 0), _ += b
            }(), !1 === s && (t > 0 && u(!0), e > 0 && u(!1)), this.setIndex(d), this.addAttribute("position", new wt(p, 3)), this.addAttribute("normal", new wt(f, 3)), this.addAttribute("uv", new wt(m, 2))
        }

        function wi(t, e, i, n, r, o, a) {
            xi.call(this, 0, t, e, i, n, r, o, a), this.type = "ConeGeometry", this.parameters = {
                radius: t,
                height: e,
                radialSegments: i,
                heightSegments: n,
                openEnded: r,
                thetaStart: o,
                thetaLength: a
            }
        }

        function Ti(t, e, i, n, r, o, a) {
            bi.call(this, 0, t, e, i, n, r, o, a), this.type = "ConeBufferGeometry", this.parameters = {
                radius: t,
                height: e,
                radialSegments: i,
                heightSegments: n,
                openEnded: r,
                thetaStart: o,
                thetaLength: a
            }
        }

        function Si(t, e, i, n) {
            pt.call(this), this.type = "CircleGeometry", this.parameters = {
                radius: t,
                segments: e,
                thetaStart: i,
                thetaLength: n
            }, this.fromBufferGeometry(new Ei(t, e, i, n)), this.mergeVertices()
        }

        function Ei(t, e, n, r) {
            Mt.call(this), this.type = "CircleBufferGeometry", this.parameters = {
                radius: t,
                segments: e,
                thetaStart: n,
                thetaLength: r
            }, t = t || 1, e = void 0 !== e ? Math.max(3, e) : 8, n = void 0 !== n ? n : 0, r = void 0 !== r ? r : 2 * Math.PI;
            var a, s, l = [],
                c = [],
                u = [],
                h = [],
                d = new o,
                p = new i;
            for (c.push(0, 0, 0), u.push(0, 0, 1), h.push(.5, .5), s = 0, a = 3; s <= e; s++, a += 3) {
                var f = n + s / e * r;
                d.x = t * Math.cos(f), d.y = t * Math.sin(f), c.push(d.x, d.y, d.z), u.push(0, 0, 1), p.x = (c[a] / t + 1) / 2, p.y = (c[a + 1] / t + 1) / 2, h.push(p.x, p.y)
            }
            for (a = 1; a <= e; a++) l.push(a, a + 1, 0);
            this.setIndex(l), this.addAttribute("position", new wt(c, 3)), this.addAttribute("normal", new wt(u, 3)), this.addAttribute("uv", new wt(h, 2))
        }

        function Mi(t) {
            $.call(this), this.type = "ShadowMaterial", this.color = new q(0), this.opacity = 1, this.lights = !0, this.transparent = !0, this.setValues(t)
        }

        function Ai(t) {
            Ot.call(this, t), this.type = "RawShaderMaterial"
        }

        function Li(t) {
            $.call(this), this.defines = {
                STANDARD: ""
            }, this.type = "MeshStandardMaterial", this.color = new q(16777215), this.roughness = .5, this.metalness = .5, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new q(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalScale = new i(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.roughnessMap = null, this.metalnessMap = null, this.alphaMap = null, this.envMap = null, this.envMapIntensity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.setValues(t)
        }

        function Ci(t) {
            Li.call(this), this.defines = {
                PHYSICAL: ""
            }, this.type = "MeshPhysicalMaterial", this.reflectivity = .5, this.clearCoat = 0, this.clearCoatRoughness = 0, this.setValues(t)
        }

        function Pi(t) {
            $.call(this), this.type = "MeshPhongMaterial", this.color = new q(16777215), this.specular = new q(1118481), this.shininess = 30, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new q(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalScale = new i(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = Co, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.setValues(t)
        }

        function Ri(t) {
            Pi.call(this), this.defines = {
                TOON: ""
            }, this.type = "MeshToonMaterial", this.gradientMap = null, this.setValues(t)
        }

        function Oi(t) {
            $.call(this), this.type = "MeshNormalMaterial", this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalScale = new i(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.lights = !1, this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.setValues(t)
        }

        function Ii(t) {
            $.call(this), this.type = "MeshLambertMaterial", this.color = new q(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new q(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = Co, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.setValues(t)
        }

        function Di(t) {
            Oe.call(this), this.type = "LineDashedMaterial", this.scale = 1, this.dashSize = 3, this.gapSize = 1, this.setValues(t)
        }

        function Ni(t, e, i) {
            var n = this,
                r = !1,
                o = 0,
                a = 0,
                s = void 0;
            this.onStart = void 0, this.onLoad = t, this.onProgress = e, this.onError = i, this.itemStart = function(t) {
                a++, !1 === r && void 0 !== n.onStart && n.onStart(t, o, a), r = !0
            }, this.itemEnd = function(t) {
                o++, void 0 !== n.onProgress && n.onProgress(t, o, a), o === a && (r = !1, void 0 !== n.onLoad && n.onLoad())
            }, this.itemError = function(t) {
                void 0 !== n.onError && n.onError(t)
            }, this.resolveURL = function(t) {
                return s ? s(t) : t
            }, this.setURLModifier = function(t) {
                s = t
            }
        }

        function Fi(t) {
            this.manager = void 0 !== t ? t : hs
        }

        function ki(t) {
            this.manager = void 0 !== t ? t : hs, this._parser = null
        }

        function Ui(t) {
            this.manager = void 0 !== t ? t : hs, this._parser = null
        }

        function Bi(t) {
            this.manager = void 0 !== t ? t : hs
        }

        function zi(t) {
            this.manager = void 0 !== t ? t : hs
        }

        function ji(t) {
            this.manager = void 0 !== t ? t : hs
        }

        function Hi(t, e) {
            ct.call(this), this.type = "Light", this.color = new q(t), this.intensity = void 0 !== e ? e : 1, this.receiveShadow = void 0
        }

        function Gi(t, e, i) {
            Hi.call(this, t, i), this.type = "HemisphereLight", this.castShadow = void 0, this.position.copy(ct.DefaultUp), this.updateMatrix(), this.groundColor = new q(e)
        }

        function Vi(t) {
            this.camera = t, this.bias = 0, this.radius = 1, this.mapSize = new i(512, 512), this.map = null, this.matrix = new n
        }

        function Wi() {
            Vi.call(this, new me(50, 1, .5, 500))
        }

        function Xi(t, e, i, n, r, o) {
            Hi.call(this, t, e), this.type = "SpotLight", this.position.copy(ct.DefaultUp), this.updateMatrix(), this.target = new ct, Object.defineProperty(this, "power", {
                get: function() {
                    return this.intensity * Math.PI
                },
                set: function(t) {
                    this.intensity = t / Math.PI
                }
            }), this.distance = void 0 !== i ? i : 0, this.angle = void 0 !== n ? n : Math.PI / 3, this.penumbra = void 0 !== r ? r : 0, this.decay = void 0 !== o ? o : 1, this.shadow = new Wi
        }

        function qi(t, e, i, n) {
            Hi.call(this, t, e), this.type = "PointLight", Object.defineProperty(this, "power", {
                get: function() {
                    return 4 * this.intensity * Math.PI
                },
                set: function(t) {
                    this.intensity = t / (4 * Math.PI)
                }
            }), this.distance = void 0 !== i ? i : 0, this.decay = void 0 !== n ? n : 1, this.shadow = new Vi(new me(90, 1, .5, 500))
        }

        function Yi() {
            Vi.call(this, new ht(-5, 5, 5, -5, .5, 500))
        }

        function Qi(t, e) {
            Hi.call(this, t, e), this.type = "DirectionalLight", this.position.copy(ct.DefaultUp), this.updateMatrix(), this.target = new ct, this.shadow = new Yi
        }

        function Zi(t, e) {
            Hi.call(this, t, e), this.type = "AmbientLight", this.castShadow = void 0
        }

        function Ji(t, e, i, n) {
            Hi.call(this, t, e), this.type = "RectAreaLight", this.position.set(0, 1, 0), this.updateMatrix(), this.width = void 0 !== i ? i : 10, this.height = void 0 !== n ? n : 10
        }

        function $i(t, e, i, n) {
            this.parameterPositions = t, this._cachedIndex = 0, this.resultBuffer = void 0 !== n ? n : new e.constructor(i), this.sampleValues = e, this.valueSize = i
        }

        function Ki(t, e, i, n) {
            $i.call(this, t, e, i, n), this._weightPrev = -0, this._offsetPrev = -0, this._weightNext = -0, this._offsetNext = -0
        }

        function tn(t, e, i, n) {
            $i.call(this, t, e, i, n)
        }

        function en(t, e, i, n) {
            $i.call(this, t, e, i, n)
        }

        function nn(t, e, i, n) {
            if (void 0 === t) throw new Error("track name is undefined");
            if (void 0 === e || 0 === e.length) throw new Error("no keyframes in track named " + t);
            this.name = t, this.times = ps.convertArray(e, this.TimeBufferType), this.values = ps.convertArray(i, this.ValueBufferType), this.setInterpolation(n || this.DefaultInterpolation), this.validate(), this.optimize()
        }

        function rn(t, e, i, n) {
            nn.call(this, t, e, i, n)
        }

        function on(t, e, i, n) {
            $i.call(this, t, e, i, n)
        }

        function an(t, e, i, n) {
            nn.call(this, t, e, i, n)
        }

        function sn(t, e, i, n) {
            nn.call(this, t, e, i, n)
        }

        function ln(t, e, i, n) {
            nn.call(this, t, e, i, n)
        }

        function cn(t, e, i) {
            nn.call(this, t, e, i)
        }

        function un(t, e, i, n) {
            nn.call(this, t, e, i, n)
        }

        function hn(t, e, i, n) {
            nn.apply(this, t, e, i, n)
        }

        function dn(t, e, i) {
            this.name = t, this.tracks = i, this.duration = void 0 !== e ? e : -1, this.uuid = Ha.generateUUID(), this.duration < 0 && this.resetDuration(), this.optimize()
        }

        function pn(t) {
            this.manager = void 0 !== t ? t : hs, this.textures = {}
        }

        function fn(t) {
            this.manager = void 0 !== t ? t : hs
        }

        function mn() {
            this.onLoadStart = function() {}, this.onLoadProgress = function() {}, this.onLoadComplete = function() {}
        }

        function gn(t) {
            "boolean" == typeof t && (console.warn("THREE.JSONLoader: showStatus parameter has been removed from constructor."), t = void 0), this.manager = void 0 !== t ? t : hs, this.withCredentials = !1
        }

        function vn(t) {
            this.manager = void 0 !== t ? t : hs, this.texturePath = ""
        }

        function yn(t, e, i, n, r) {
            var o = .5 * (n - e),
                a = .5 * (r - i),
                s = t * t;
            return (2 * i - 2 * n + o + a) * (t * s) + (-3 * i + 3 * n - 2 * o - a) * s + o * t + i
        }

        function _n(t, e) {
            var i = 1 - t;
            return i * i * e
        }

        function xn(t, e) {
            return 2 * (1 - t) * t * e
        }

        function bn(t, e) {
            return t * t * e
        }

        function wn(t, e, i, n) {
            return _n(t, e) + xn(t, i) + bn(t, n)
        }

        function Tn(t, e) {
            var i = 1 - t;
            return i * i * i * e
        }

        function Sn(t, e) {
            var i = 1 - t;
            return 3 * i * i * t * e
        }

        function En(t, e) {
            return 3 * (1 - t) * t * t * e
        }

        function Mn(t, e) {
            return t * t * t * e
        }

        function An(t, e, i, n, r) {
            return Tn(t, e) + Sn(t, i) + En(t, n) + Mn(t, r)
        }

        function Ln() {
            this.type = "Curve", this.arcLengthDivisions = 200
        }

        function Cn(t, e) {
            Ln.call(this), this.type = "LineCurve", this.v1 = t || new i, this.v2 = e || new i
        }

        function Pn() {
            Ln.call(this), this.type = "CurvePath", this.curves = [], this.autoClose = !1
        }

        function Rn(t, e, i, n, r, o, a, s) {
            Ln.call(this), this.type = "EllipseCurve", this.aX = t || 0, this.aY = e || 0, this.xRadius = i || 1, this.yRadius = n || 1, this.aStartAngle = r || 0, this.aEndAngle = o || 2 * Math.PI, this.aClockwise = a || !1, this.aRotation = s || 0
        }

        function On(t) {
            Ln.call(this), this.type = "SplineCurve", this.points = t || []
        }

        function In(t, e, n, r) {
            Ln.call(this), this.type = "CubicBezierCurve", this.v0 = t || new i, this.v1 = e || new i, this.v2 = n || new i, this.v3 = r || new i
        }

        function Dn(t, e, n) {
            Ln.call(this), this.type = "QuadraticBezierCurve", this.v0 = t || new i, this.v1 = e || new i, this.v2 = n || new i
        }

        function Nn(t) {
            Pn.call(this), this.type = "Path", this.currentPoint = new i, t && this.setFromPoints(t)
        }

        function Fn(t) {
            Nn.call(this, t), this.type = "Shape", this.holes = []
        }

        function kn() {
            this.type = "ShapePath", this.subPaths = [], this.currentPath = null
        }

        function Un(t) {
            this.type = "Font", this.data = t
        }

        function Bn(t) {
            this.manager = void 0 !== t ? t : hs
        }

        function zn(t) {
            this.manager = void 0 !== t ? t : hs
        }

        function jn() {
            this.type = "StereoCamera", this.aspect = 1, this.eyeSep = .064, this.cameraL = new me, this.cameraL.layers.enable(1), this.cameraL.matrixAutoUpdate = !1, this.cameraR = new me, this.cameraR.layers.enable(2), this.cameraR.matrixAutoUpdate = !1
        }

        function Hn(t, e, i) {
            ct.call(this), this.type = "CubeCamera";
            var n = new me(90, 1, t, e);
            n.up.set(0, -1, 0), n.lookAt(new o(1, 0, 0)), this.add(n);
            var r = new me(90, 1, t, e);
            r.up.set(0, -1, 0), r.lookAt(new o(-1, 0, 0)), this.add(r);
            var a = new me(90, 1, t, e);
            a.up.set(0, 0, 1), a.lookAt(new o(0, 1, 0)), this.add(a);
            var s = new me(90, 1, t, e);
            s.up.set(0, 0, -1), s.lookAt(new o(0, -1, 0)), this.add(s);
            var l = new me(90, 1, t, e);
            l.up.set(0, -1, 0), l.lookAt(new o(0, 0, 1)), this.add(l);
            var c = new me(90, 1, t, e);
            c.up.set(0, -1, 0), c.lookAt(new o(0, 0, -1)), this.add(c);
            var h = {
                format: da,
                magFilter: Zo,
                minFilter: Zo
            };
            this.renderTarget = new u(i, i, h), this.renderTarget.texture.name = "CubeCamera", this.update = function(t, e) {
                null === this.parent && this.updateMatrixWorld();
                var i = this.renderTarget,
                    o = i.texture.generateMipmaps;
                i.texture.generateMipmaps = !1, i.activeCubeFace = 0, t.render(e, n, i), i.activeCubeFace = 1, t.render(e, r, i), i.activeCubeFace = 2, t.render(e, a, i), i.activeCubeFace = 3, t.render(e, s, i), i.activeCubeFace = 4, t.render(e, l, i), i.texture.generateMipmaps = o, i.activeCubeFace = 5, t.render(e, c, i), t.setRenderTarget(null)
            }, this.clear = function(t, e, i, n) {
                for (var r = this.renderTarget, o = 0; o < 6; o++) r.activeCubeFace = o, t.setRenderTarget(r), t.clear(e, i, n);
                t.setRenderTarget(null)
            }
        }

        function Gn() {
            ct.call(this), this.type = "AudioListener", this.context = bs.getContext(), this.gain = this.context.createGain(), this.gain.connect(this.context.destination), this.filter = null
        }

        function Vn(t) {
            ct.call(this), this.type = "Audio", this.context = t.context, this.gain = this.context.createGain(), this.gain.connect(t.getInput()), this.autoplay = !1, this.buffer = null, this.loop = !1, this.startTime = 0, this.offset = 0, this.playbackRate = 1, this.isPlaying = !1, this.hasPlaybackControl = !0, this.sourceType = "empty", this.filters = []
        }

        function Wn(t) {
            Vn.call(this, t), this.panner = this.context.createPanner(), this.panner.connect(this.gain)
        }

        function Xn(t, e) {
            this.analyser = t.context.createAnalyser(), this.analyser.fftSize = void 0 !== e ? e : 2048, this.data = new Uint8Array(this.analyser.frequencyBinCount), t.getOutput().connect(this.analyser)
        }

        function qn(t, e, i) {
            this.binding = t, this.valueSize = i;
            var n, r = Float64Array;
            switch (e) {
                case "quaternion":
                    n = this._slerp;
                    break;
                case "string":
                case "bool":
                    r = Array, n = this._select;
                    break;
                default:
                    n = this._lerp
            }
            this.buffer = new r(4 * i), this._mixBufferRegion = n, this.cumulativeWeight = 0, this.useCount = 0, this.referenceCount = 0
        }

        function Yn(t, e, i) {
            var n = i || Qn.parseTrackName(e);
            this._targetGroup = t, this._bindings = t.subscribe_(e, n)
        }

        function Qn(t, e, i) {
            this.path = e, this.parsedPath = i || Qn.parseTrackName(e), this.node = Qn.findNode(t, this.parsedPath.nodeName) || t, this.rootNode = t
        }

        function Zn() {
            this.uuid = Ha.generateUUID(), this._objects = Array.prototype.slice.call(arguments), this.nCachedObjects_ = 0;
            var t = {};
            this._indicesByUUID = t;
            for (var e = 0, i = arguments.length; e !== i; ++e) t[arguments[e].uuid] = e;
            this._paths = [], this._parsedPaths = [], this._bindings = [], this._bindingsIndicesByPath = {};
            var n = this;
            this.stats = {
                objects: {
                    get total() {
                        return n._objects.length
                    },
                    get inUse() {
                        return this.total - n.nCachedObjects_
                    }
                },
                get bindingsPerObject() {
                    return n._bindings.length
                }
            }
        }

        function Jn(t, e, i) {
            this._mixer = t, this._clip = e, this._localRoot = i || null;
            for (var n = e.tracks, r = n.length, o = new Array(r), a = {
                    endingStart: Ca,
                    endingEnd: Ca
                }, s = 0; s !== r; ++s) {
                var l = n[s].createInterpolant(null);
                o[s] = l, l.settings = a
            }
            this._interpolantSettings = a, this._interpolants = o, this._propertyBindings = new Array(r), this._cacheIndex = null, this._byClipCacheIndex = null, this._timeScaleInterpolant = null, this._weightInterpolant = null, this.loop = La, this._loopCount = -1, this._startTime = null, this.time = 0, this.timeScale = 1, this._effectiveTimeScale = 1, this.weight = 1, this._effectiveWeight = 1, this.repetitions = 1 / 0, this.paused = !1, this.enabled = !0, this.clampWhenFinished = !1, this.zeroSlopeAtStart = !0, this.zeroSlopeAtEnd = !0
        }

        function $n(t) {
            this._root = t, this._initMemoryManager(), this._accuIndex = 0, this.time = 0, this.timeScale = 1
        }

        function Kn(t) {
            "string" == typeof t && (console.warn("THREE.Uniform: Type parameter is no longer needed."), t = arguments[1]), this.value = t
        }

        function tr() {
            Mt.call(this), this.type = "InstancedBufferGeometry", this.maxInstancedCount = void 0
        }

        function er(t, e, i, n) {
            this.uuid = Ha.generateUUID(), this.data = t, this.itemSize = e, this.offset = i, this.normalized = !0 === n
        }

        function ir(t, e) {
            this.uuid = Ha.generateUUID(), this.array = t, this.stride = e, this.count = void 0 !== t ? t.length / e : 0, this.dynamic = !1, this.updateRange = {
                offset: 0,
                count: -1
            }, this.onUploadCallback = function() {}, this.version = 0
        }

        function nr(t, e, i) {
            ir.call(this, t, e), this.meshPerAttribute = i || 1
        }

        function rr(t, e, i) {
            ft.call(this, t, e), this.meshPerAttribute = i || 1
        }

        function or(t, e, i, n) {
            this.ray = new It(t, e), this.near = i || 0, this.far = n || 1 / 0, this.params = {
                Mesh: {},
                Line: {},
                LOD: {},
                Points: {
                    threshold: 1
                },
                Sprite: {}
            }, Object.defineProperties(this.params, {
                PointCloud: {
                    get: function() {
                        return console.warn("THREE.Raycaster: params.PointCloud has been renamed to params.Points."), this.Points
                    }
                }
            })
        }

        function ar(t, e) {
            return t.distance - e.distance
        }

        function sr(t, e, i, n) {
            if (!1 !== t.visible && (t.raycast(e, i), !0 === n))
                for (var r = t.children, o = 0, a = r.length; o < a; o++) sr(r[o], e, i, !0)
        }

        function lr(t) {
            this.autoStart = void 0 === t || t, this.startTime = 0, this.oldTime = 0, this.elapsedTime = 0, this.running = !1
        }

        function cr(t, e, i) {
            return this.radius = void 0 !== t ? t : 1, this.phi = void 0 !== e ? e : 0, this.theta = void 0 !== i ? i : 0, this
        }

        function ur(t, e, i) {
            return this.radius = void 0 !== t ? t : 1, this.theta = void 0 !== e ? e : 0, this.y = void 0 !== i ? i : 0, this
        }

        function hr(t) {
            ct.call(this), this.material = t, this.render = function() {}
        }

        function dr(t, e, i, n) {
            this.object = t, this.size = void 0 !== e ? e : 1;
            var r = void 0 !== i ? i : 16711680,
                o = void 0 !== n ? n : 1,
                a = 0,
                s = this.object.geometry;
            s && s.isGeometry ? a = 3 * s.faces.length : s && s.isBufferGeometry && (a = s.attributes.normal.count);
            var l = new Mt,
                c = new wt(2 * a * 3, 3);
            l.addAttribute("position", c), De.call(this, l, new Oe({
                color: r,
                linewidth: o
            })), this.matrixAutoUpdate = !1, this.update()
        }

        function pr(t, e) {
            ct.call(this), this.light = t, this.light.updateMatrixWorld(), this.matrix = t.matrixWorld, this.matrixAutoUpdate = !1, this.color = e;
            for (var i = new Mt, n = [0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, -1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, -1, 1], r = 0, o = 1; r < 32; r++, o++) {
                var a = r / 32 * Math.PI * 2,
                    s = o / 32 * Math.PI * 2;
                n.push(Math.cos(a), Math.sin(a), 1, Math.cos(s), Math.sin(s), 1)
            }
            i.addAttribute("position", new wt(n, 3));
            var l = new Oe({
                fog: !1
            });
            this.cone = new De(i, l), this.add(this.cone), this.update()
        }

        function fr(t) {
            var e = [];
            t && t.isBone && e.push(t);
            for (var i = 0; i < t.children.length; i++) e.push.apply(e, fr(t.children[i]));
            return e
        }

        function mr(t) {
            for (var e = fr(t), i = new Mt, n = [], r = [], o = new q(0, 0, 1), a = new q(0, 1, 0), s = 0; s < e.length; s++) {
                var l = e[s];
                l.parent && l.parent.isBone && (n.push(0, 0, 0), n.push(0, 0, 0), r.push(o.r, o.g, o.b), r.push(a.r, a.g, a.b))
            }
            i.addAttribute("position", new wt(n, 3)), i.addAttribute("color", new wt(r, 3));
            var c = new Oe({
                vertexColors: Jr,
                depthTest: !1,
                depthWrite: !1,
                transparent: !0
            });
            De.call(this, i, c), this.root = t, this.bones = e, this.matrix = t.matrixWorld, this.matrixAutoUpdate = !1
        }

        function gr(t, e, i) {
            this.light = t, this.light.updateMatrixWorld(), this.color = i;
            var n = new di(e, 4, 2),
                r = new Rt({
                    wireframe: !0,
                    fog: !1
                });
            Ft.call(this, n, r), this.matrix = this.light.matrixWorld, this.matrixAutoUpdate = !1, this.update()
        }

        function vr(t, e) {
            ct.call(this), this.light = t, this.light.updateMatrixWorld(), this.matrix = t.matrixWorld, this.matrixAutoUpdate = !1, this.color = e;
            var i = new Oe({
                    fog: !1
                }),
                n = new Mt;
            n.addAttribute("position", new ft(new Float32Array(15), 3)), this.line = new Ie(n, i), this.add(this.line), this.update()
        }

        function yr(t, e, i) {
            ct.call(this), this.light = t, this.light.updateMatrixWorld(), this.matrix = t.matrixWorld, this.matrixAutoUpdate = !1, this.color = i;
            var n = new Ze(e);
            n.rotateY(.5 * Math.PI), this.material = new Rt({
                wireframe: !0,
                fog: !1
            }), void 0 === this.color && (this.material.vertexColors = Jr);
            var r = n.getAttribute("position"),
                o = new Float32Array(3 * r.count);
            n.addAttribute("color", new ft(o, 3)), this.add(new Ft(n, this.material)), this.update()
        }

        function _r(t, e, i, n) {
            t = t || 10, e = e || 10, i = new q(void 0 !== i ? i : 4473924), n = new q(void 0 !== n ? n : 8947848);
            for (var r = e / 2, o = t / e, a = t / 2, s = [], l = [], c = 0, u = 0, h = -a; c <= e; c++, h += o) {
                s.push(-a, 0, h, a, 0, h), s.push(h, 0, -a, h, 0, a);
                var d = c === r ? i : n;
                d.toArray(l, u), u += 3, d.toArray(l, u), u += 3, d.toArray(l, u), u += 3, d.toArray(l, u), u += 3
            }
            var p = new Mt;
            p.addAttribute("position", new wt(s, 3)), p.addAttribute("color", new wt(l, 3));
            var f = new Oe({
                vertexColors: Jr
            });
            De.call(this, p, f)
        }

        function xr(t, e, i, n, r, o) {
            t = t || 10, e = e || 16, i = i || 8, n = n || 64, r = new q(void 0 !== r ? r : 4473924), o = new q(void 0 !== o ? o : 8947848);
            var a, s, l, c, u, h, d, p = [],
                f = [];
            for (c = 0; c <= e; c++) l = c / e * (2 * Math.PI), a = Math.sin(l) * t, s = Math.cos(l) * t, p.push(0, 0, 0), p.push(a, 0, s), d = 1 & c ? r : o, f.push(d.r, d.g, d.b), f.push(d.r, d.g, d.b);
            for (c = 0; c <= i; c++)
                for (d = 1 & c ? r : o, h = t - t / i * c, u = 0; u < n; u++) l = u / n * (2 * Math.PI), a = Math.sin(l) * h, s = Math.cos(l) * h, p.push(a, 0, s), f.push(d.r, d.g, d.b), l = (u + 1) / n * (2 * Math.PI), a = Math.sin(l) * h, s = Math.cos(l) * h, p.push(a, 0, s), f.push(d.r, d.g, d.b);
            var m = new Mt;
            m.addAttribute("position", new wt(p, 3)), m.addAttribute("color", new wt(f, 3));
            var g = new Oe({
                vertexColors: Jr
            });
            De.call(this, m, g)
        }

        function br(t, e, i, n) {
            this.object = t, this.size = void 0 !== e ? e : 1;
            var r = void 0 !== i ? i : 16776960,
                o = void 0 !== n ? n : 1,
                a = 0,
                s = this.object.geometry;
            s && s.isGeometry ? a = s.faces.length : console.warn("THREE.FaceNormalsHelper: only THREE.Geometry is supported. Use THREE.VertexNormalsHelper, instead.");
            var l = new Mt,
                c = new wt(2 * a * 3, 3);
            l.addAttribute("position", c), De.call(this, l, new Oe({
                color: r,
                linewidth: o
            })), this.matrixAutoUpdate = !1, this.update()
        }

        function wr(t, e, i) {
            ct.call(this), this.light = t, this.light.updateMatrixWorld(), this.matrix = t.matrixWorld, this.matrixAutoUpdate = !1, this.color = i, void 0 === e && (e = 1);
            var n = new Mt;
            n.addAttribute("position", new wt([-e, e, 0, e, e, 0, e, -e, 0, -e, -e, 0, -e, e, 0], 3));
            var r = new Oe({
                fog: !1
            });
            this.lightPlane = new Ie(n, r), this.add(this.lightPlane), (n = new Mt).addAttribute("position", new wt([0, 0, 0, 0, 0, 1], 3)), this.targetLine = new Ie(n, r), this.add(this.targetLine), this.update()
        }

        function Tr(t) {
            function e(t, e, n) {
                i(t, n), i(e, n)
            }

            function i(t, e) {
                o.push(0, 0, 0), a.push(e.r, e.g, e.b), void 0 === s[t] && (s[t] = []), s[t].push(o.length / 3 - 1)
            }
            var n = new Mt,
                r = new Oe({
                    color: 16777215,
                    vertexColors: Zr
                }),
                o = [],
                a = [],
                s = {},
                l = new q(16755200),
                c = new q(16711680),
                u = new q(43775),
                h = new q(16777215),
                d = new q(3355443);
            e("n1", "n2", l), e("n2", "n4", l), e("n4", "n3", l), e("n3", "n1", l), e("f1", "f2", l), e("f2", "f4", l), e("f4", "f3", l), e("f3", "f1", l), e("n1", "f1", l), e("n2", "f2", l), e("n3", "f3", l), e("n4", "f4", l), e("p", "n1", c), e("p", "n2", c), e("p", "n3", c), e("p", "n4", c), e("u1", "u2", u), e("u2", "u3", u), e("u3", "u1", u), e("c", "t", h), e("p", "c", d), e("cn1", "cn2", d), e("cn3", "cn4", d), e("cf1", "cf2", d), e("cf3", "cf4", d), n.addAttribute("position", new wt(o, 3)), n.addAttribute("color", new wt(a, 3)), De.call(this, n, r), this.camera = t, this.camera.updateProjectionMatrix && this.camera.updateProjectionMatrix(), this.matrix = t.matrixWorld, this.matrixAutoUpdate = !1, this.pointMap = s, this.update()
        }

        function Sr(t, e) {
            this.object = t, void 0 === e && (e = 16776960);
            var i = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]),
                n = new Float32Array(24),
                r = new Mt;
            r.setIndex(new ft(i, 1)), r.addAttribute("position", new ft(n, 3)), De.call(this, r, new Oe({
                color: e
            })), this.matrixAutoUpdate = !1, this.update()
        }

        function Er(t, e) {
            this.type = "Box3Helper", this.box = t;
            var i = void 0 !== e ? e : 16776960,
                n = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]),
                r = [1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1],
                o = new Mt;
            o.setIndex(new ft(n, 1)), o.addAttribute("position", new wt(r, 3)), De.call(this, o, new Oe({
                color: i
            })), this.geometry.computeBoundingSphere()
        }

        function Mr(t, e, i) {
            this.type = "PlaneHelper", this.plane = t, this.size = void 0 === e ? 1 : e;
            var n = void 0 !== i ? i : 16776960,
                r = [1, -1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0],
                o = new Mt;
            o.addAttribute("position", new wt(r, 3)), o.computeBoundingSphere(), Ie.call(this, o, new Oe({
                color: n
            }));
            var a = [1, 1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, -1, 1, 1, -1, 1],
                s = new Mt;
            s.addAttribute("position", new wt(a, 3)), s.computeBoundingSphere(), this.add(new Ft(s, new Rt({
                color: n,
                opacity: .2,
                transparent: !0,
                depthWrite: !1
            })))
        }

        function Ar(t, e, i, n, r, o) {
            ct.call(this), void 0 === n && (n = 16776960), void 0 === i && (i = 1), void 0 === r && (r = .2 * i), void 0 === o && (o = .2 * r), void 0 === ws && ((ws = new Mt).addAttribute("position", new wt([0, 0, 0, 0, 1, 0], 3)), (Ts = new bi(0, .5, 1, 5, 1)).translate(0, -.5, 0)), this.position.copy(e), this.line = new Ie(ws, new Oe({
                color: n
            })), this.line.matrixAutoUpdate = !1, this.add(this.line), this.cone = new Ft(Ts, new Rt({
                color: n
            })), this.cone.matrixAutoUpdate = !1, this.add(this.cone), this.setDirection(t), this.setLength(i, r, o)
        }

        function Lr(t) {
            var e = [0, 0, 0, t = t || 1, 0, 0, 0, 0, 0, 0, t, 0, 0, 0, 0, 0, 0, t],
                i = [1, 0, 0, 1, .6, 0, 0, 1, 0, .6, 1, 0, 0, 0, 1, 0, .6, 1],
                n = new Mt;
            n.addAttribute("position", new wt(e, 3)), n.addAttribute("color", new wt(i, 3));
            var r = new Oe({
                vertexColors: Jr
            });
            De.call(this, n, r)
        }

        function Cr() {
            function t(t, o, a, s) {
                e = t, i = a, n = -3 * t + 3 * o - 2 * a - s, r = 2 * t - 2 * o + a + s
            }
            var e = 0,
                i = 0,
                n = 0,
                r = 0;
            return {
                initCatmullRom: function(e, i, n, r, o) {
                    t(i, n, o * (n - e), o * (r - i))
                },
                initNonuniformCatmullRom: function(e, i, n, r, o, a, s) {
                    var l = (i - e) / o - (n - e) / (o + a) + (n - i) / a,
                        c = (n - i) / a - (r - i) / (a + s) + (r - n) / s;
                    t(i, n, l *= a, c *= a)
                },
                calc: function(t) {
                    var o = t * t;
                    return e + i * t + n * o + r * (o * t)
                }
            }
        }

        function Pr(t, e, i, n) {
            Ln.call(this), this.type = "CatmullRomCurve3", this.points = t || [], this.closed = e || !1, this.curveType = i || "centripetal", this.tension = n || .5
        }

        function Rr(t, e, i, n) {
            Ln.call(this), this.type = "CubicBezierCurve3", this.v0 = t || new o, this.v1 = e || new o, this.v2 = i || new o, this.v3 = n || new o
        }

        function Or(t, e, i) {
            Ln.call(this), this.type = "QuadraticBezierCurve3", this.v0 = t || new o, this.v1 = e || new o, this.v2 = i || new o
        }

        function Ir(t, e) {
            Ln.call(this), this.type = "LineCurve3", this.v1 = t || new o, this.v2 = e || new o
        }

        function Dr(t, e, i, n, r, o) {
            Rn.call(this, t, e, i, i, n, r, o), this.type = "ArcCurve"
        }

        function Nr(t) {
            console.warn("THREE.ClosedSplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead."), Pr.call(this, t), this.type = "catmullrom", this.closed = !0
        }

        function Fr(t) {
            console.warn("THREE.SplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead."), Pr.call(this, t), this.type = "catmullrom"
        }

        function kr(t) {
            console.warn("THREE.Spline has been removed. Use THREE.CatmullRomCurve3 instead."), Pr.call(this, t), this.type = "catmullrom"
        }
        void 0 === Number.EPSILON && (Number.EPSILON = Math.pow(2, -52)), void 0 === Number.isInteger && (Number.isInteger = function(t) {
            return "number" == typeof t && isFinite(t) && Math.floor(t) === t
        }), void 0 === Math.sign && (Math.sign = function(t) {
            return t < 0 ? -1 : t > 0 ? 1 : +t
        }), "name" in Function.prototype == !1 && Object.defineProperty(Function.prototype, "name", {
            get: function() {
                return this.toString().match(/^\s*function\s*([^\(\s]*)/)[1]
            }
        }), void 0 === Object.assign && (Object.assign = function(t) {
            if (void 0 === t || null === t) throw new TypeError("Cannot convert undefined or null to object");
            for (var e = Object(t), i = 1; i < arguments.length; i++) {
                var n = arguments[i];
                if (void 0 !== n && null !== n)
                    for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r])
            }
            return e
        }), Object.assign(e.prototype, {
            addEventListener: function(t, e) {
                void 0 === this._listeners && (this._listeners = {});
                var i = this._listeners;
                void 0 === i[t] && (i[t] = []), -1 === i[t].indexOf(e) && i[t].push(e)
            },
            hasEventListener: function(t, e) {
                if (void 0 === this._listeners) return !1;
                var i = this._listeners;
                return void 0 !== i[t] && -1 !== i[t].indexOf(e)
            },
            removeEventListener: function(t, e) {
                if (void 0 !== this._listeners) {
                    var i = this._listeners[t];
                    if (void 0 !== i) {
                        var n = i.indexOf(e); - 1 !== n && i.splice(n, 1)
                    }
                }
            },
            dispatchEvent: function(t) {
                if (void 0 !== this._listeners) {
                    var e = this._listeners[t.type];
                    if (void 0 !== e) {
                        t.target = this;
                        for (var i = e.slice(0), n = 0, r = i.length; n < r; n++) i[n].call(this, t)
                    }
                }
            }
        });
        var Ur = "88",
            Br = {
                LEFT: 0,
                MIDDLE: 1,
                RIGHT: 2
            },
            zr = 0,
            jr = 1,
            Hr = 2,
            Gr = 0,
            Vr = 1,
            Wr = 2,
            Xr = 0,
            qr = 1,
            Yr = 2,
            Qr = 0,
            Zr = 1,
            Jr = 2,
            $r = 0,
            Kr = 1,
            to = 2,
            eo = 3,
            io = 4,
            no = 5,
            ro = 100,
            oo = 101,
            ao = 102,
            so = 103,
            lo = 104,
            co = 200,
            uo = 201,
            ho = 202,
            po = 203,
            fo = 204,
            mo = 205,
            go = 206,
            vo = 207,
            yo = 208,
            _o = 209,
            xo = 210,
            bo = 0,
            wo = 1,
            To = 2,
            So = 3,
            Eo = 4,
            Mo = 5,
            Ao = 6,
            Lo = 7,
            Co = 0,
            Po = 1,
            Ro = 2,
            Oo = 0,
            Io = 1,
            Do = 2,
            No = 3,
            Fo = 4,
            ko = 301,
            Uo = 302,
            Bo = 303,
            zo = 304,
            jo = 305,
            Ho = 306,
            Go = 307,
            Vo = 1e3,
            Wo = 1001,
            Xo = 1002,
            qo = 1003,
            Yo = 1004,
            Qo = 1005,
            Zo = 1006,
            Jo = 1007,
            $o = 1008,
            Ko = 1009,
            ta = 1010,
            ea = 1011,
            ia = 1012,
            na = 1013,
            ra = 1014,
            oa = 1015,
            aa = 1016,
            sa = 1017,
            la = 1018,
            ca = 1019,
            ua = 1020,
            ha = 1021,
            da = 1022,
            pa = 1023,
            fa = 1024,
            ma = 1025,
            ga = pa,
            va = 1026,
            ya = 1027,
            _a = 2001,
            xa = 2002,
            ba = 2003,
            wa = 2004,
            Ta = 2100,
            Sa = 2101,
            Ea = 2102,
            Ma = 2103,
            Aa = 2151,
            La = 2201,
            Ca = 2400,
            Pa = 0,
            Ra = 1,
            Oa = 2,
            Ia = 3e3,
            Da = 3001,
            Na = 3007,
            Fa = 3002,
            ka = 3004,
            Ua = 3005,
            Ba = 3006,
            za = 3200,
            ja = 3201,
            Ha = {
                DEG2RAD: Math.PI / 180,
                RAD2DEG: 180 / Math.PI,
                generateUUID: function() {
                    var t, e = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz".split(""),
                        i = 0;
                    return function() {
                        for (var n = "", r = 0; r < 36; r++) 8 === r || 13 === r || 18 === r || 23 === r ? n += "-" : 14 === r ? n += "4" : (i <= 2 && (i = 33554432 + 16777216 * Math.random() | 0), t = 15 & i, i >>= 4, n += e[19 === r ? 3 & t | 8 : t]);
                        return n
                    }
                }(),
                clamp: function(t, e, i) {
                    return Math.max(e, Math.min(i, t))
                },
                euclideanModulo: function(t, e) {
                    return (t % e + e) % e
                },
                mapLinear: function(t, e, i, n, r) {
                    return n + (t - e) * (r - n) / (i - e)
                },
                lerp: function(t, e, i) {
                    return (1 - i) * t + i * e
                },
                smoothstep: function(t, e, i) {
                    return t <= e ? 0 : t >= i ? 1 : (t = (t - e) / (i - e)) * t * (3 - 2 * t)
                },
                smootherstep: function(t, e, i) {
                    return t <= e ? 0 : t >= i ? 1 : (t = (t - e) / (i - e)) * t * t * (t * (6 * t - 15) + 10)
                },
                randInt: function(t, e) {
                    return t + Math.floor(Math.random() * (e - t + 1))
                },
                randFloat: function(t, e) {
                    return t + Math.random() * (e - t)
                },
                randFloatSpread: function(t) {
                    return t * (.5 - Math.random())
                },
                degToRad: function(t) {
                    return t * Ha.DEG2RAD
                },
                radToDeg: function(t) {
                    return t * Ha.RAD2DEG
                },
                isPowerOfTwo: function(t) {
                    return 0 == (t & t - 1) && 0 !== t
                },
                ceilPowerOfTwo: function(t) {
                    return Math.pow(2, Math.ceil(Math.log(t) / Math.LN2))
                },
                floorPowerOfTwo: function(t) {
                    return Math.pow(2, Math.floor(Math.log(t) / Math.LN2))
                }
            };
        Object.defineProperties(i.prototype, {
            width: {
                get: function() {
                    return this.x
                },
                set: function(t) {
                    this.x = t
                }
            },
            height: {
                get: function() {
                    return this.y
                },
                set: function(t) {
                    this.y = t
                }
            }
        }), Object.assign(i.prototype, {
            isVector2: !0,
            set: function(t, e) {
                return this.x = t, this.y = e, this
            },
            setScalar: function(t) {
                return this.x = t, this.y = t, this
            },
            setX: function(t) {
                return this.x = t, this
            },
            setY: function(t) {
                return this.y = t, this
            },
            setComponent: function(t, e) {
                switch (t) {
                    case 0:
                        this.x = e;
                        break;
                    case 1:
                        this.y = e;
                        break;
                    default:
                        throw new Error("index is out of range: " + t)
                }
                return this
            },
            getComponent: function(t) {
                switch (t) {
                    case 0:
                        return this.x;
                    case 1:
                        return this.y;
                    default:
                        throw new Error("index is out of range: " + t)
                }
            },
            clone: function() {
                return new this.constructor(this.x, this.y)
            },
            copy: function(t) {
                return this.x = t.x, this.y = t.y, this
            },
            add: function(t, e) {
                return void 0 !== e ? (console.warn("THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(t, e)) : (this.x += t.x, this.y += t.y, this)
            },
            addScalar: function(t) {
                return this.x += t, this.y += t, this
            },
            addVectors: function(t, e) {
                return this.x = t.x + e.x, this.y = t.y + e.y, this
            },
            addScaledVector: function(t, e) {
                return this.x += t.x * e, this.y += t.y * e, this
            },
            sub: function(t, e) {
                return void 0 !== e ? (console.warn("THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(t, e)) : (this.x -= t.x, this.y -= t.y, this)
            },
            subScalar: function(t) {
                return this.x -= t, this.y -= t, this
            },
            subVectors: function(t, e) {
                return this.x = t.x - e.x, this.y = t.y - e.y, this
            },
            multiply: function(t) {
                return this.x *= t.x, this.y *= t.y, this
            },
            multiplyScalar: function(t) {
                return this.x *= t, this.y *= t, this
            },
            divide: function(t) {
                return this.x /= t.x, this.y /= t.y, this
            },
            divideScalar: function(t) {
                return this.multiplyScalar(1 / t)
            },
            applyMatrix3: function(t) {
                var e = this.x,
                    i = this.y,
                    n = t.elements;
                return this.x = n[0] * e + n[3] * i + n[6], this.y = n[1] * e + n[4] * i + n[7], this
            },
            min: function(t) {
                return this.x = Math.min(this.x, t.x), this.y = Math.min(this.y, t.y), this
            },
            max: function(t) {
                return this.x = Math.max(this.x, t.x), this.y = Math.max(this.y, t.y), this
            },
            clamp: function(t, e) {
                return this.x = Math.max(t.x, Math.min(e.x, this.x)), this.y = Math.max(t.y, Math.min(e.y, this.y)), this
            },
            clampScalar: function() {
                var t = new i,
                    e = new i;
                return function(i, n) {
                    return t.set(i, i), e.set(n, n), this.clamp(t, e)
                }
            }(),
            clampLength: function(t, e) {
                var i = this.length();
                return this.divideScalar(i || 1).multiplyScalar(Math.max(t, Math.min(e, i)))
            },
            floor: function() {
                return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this
            },
            ceil: function() {
                return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this
            },
            round: function() {
                return this.x = Math.round(this.x), this.y = Math.round(this.y), this
            },
            roundToZero: function() {
                return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this
            },
            negate: function() {
                return this.x = -this.x, this.y = -this.y, this
            },
            dot: function(t) {
                return this.x * t.x + this.y * t.y
            },
            lengthSq: function() {
                return this.x * this.x + this.y * this.y
            },
            length: function() {
                return Math.sqrt(this.x * this.x + this.y * this.y)
            },
            manhattanLength: function() {
                return Math.abs(this.x) + Math.abs(this.y)
            },
            normalize: function() {
                return this.divideScalar(this.length() || 1)
            },
            angle: function() {
                var t = Math.atan2(this.y, this.x);
                return t < 0 && (t += 2 * Math.PI), t
            },
            distanceTo: function(t) {
                return Math.sqrt(this.distanceToSquared(t))
            },
            distanceToSquared: function(t) {
                var e = this.x - t.x,
                    i = this.y - t.y;
                return e * e + i * i
            },
            manhattanDistanceTo: function(t) {
                return Math.abs(this.x - t.x) + Math.abs(this.y - t.y)
            },
            setLength: function(t) {
                return this.normalize().multiplyScalar(t)
            },
            lerp: function(t, e) {
                return this.x += (t.x - this.x) * e, this.y += (t.y - this.y) * e, this
            },
            lerpVectors: function(t, e, i) {
                return this.subVectors(e, t).multiplyScalar(i).add(t)
            },
            equals: function(t) {
                return t.x === this.x && t.y === this.y
            },
            fromArray: function(t, e) {
                return void 0 === e && (e = 0), this.x = t[e], this.y = t[e + 1], this
            },
            toArray: function(t, e) {
                return void 0 === t && (t = []), void 0 === e && (e = 0), t[e] = this.x, t[e + 1] = this.y, t
            },
            fromBufferAttribute: function(t, e, i) {
                return void 0 !== i && console.warn("THREE.Vector2: offset has been removed from .fromBufferAttribute()."), this.x = t.getX(e), this.y = t.getY(e), this
            },
            rotateAround: function(t, e) {
                var i = Math.cos(e),
                    n = Math.sin(e),
                    r = this.x - t.x,
                    o = this.y - t.y;
                return this.x = r * i - o * n + t.x, this.y = r * n + o * i + t.y, this
            }
        }), Object.assign(n.prototype, {
            isMatrix4: !0,
            set: function(t, e, i, n, r, o, a, s, l, c, u, h, d, p, f, m) {
                var g = this.elements;
                return g[0] = t, g[4] = e, g[8] = i, g[12] = n, g[1] = r, g[5] = o, g[9] = a, g[13] = s, g[2] = l, g[6] = c, g[10] = u, g[14] = h, g[3] = d, g[7] = p, g[11] = f, g[15] = m, this
            },
            identity: function() {
                return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
            },
            clone: function() {
                return (new n).fromArray(this.elements)
            },
            copy: function(t) {
                var e = this.elements,
                    i = t.elements;
                return e[0] = i[0], e[1] = i[1], e[2] = i[2], e[3] = i[3], e[4] = i[4], e[5] = i[5], e[6] = i[6], e[7] = i[7], e[8] = i[8], e[9] = i[9], e[10] = i[10], e[11] = i[11], e[12] = i[12], e[13] = i[13], e[14] = i[14], e[15] = i[15], this
            },
            copyPosition: function(t) {
                var e = this.elements,
                    i = t.elements;
                return e[12] = i[12], e[13] = i[13], e[14] = i[14], this
            },
            extractBasis: function(t, e, i) {
                return t.setFromMatrixColumn(this, 0), e.setFromMatrixColumn(this, 1), i.setFromMatrixColumn(this, 2), this
            },
            makeBasis: function(t, e, i) {
                return this.set(t.x, e.x, i.x, 0, t.y, e.y, i.y, 0, t.z, e.z, i.z, 0, 0, 0, 0, 1), this
            },
            extractRotation: function() {
                var t = new o;
                return function(e) {
                    var i = this.elements,
                        n = e.elements,
                        r = 1 / t.setFromMatrixColumn(e, 0).length(),
                        o = 1 / t.setFromMatrixColumn(e, 1).length(),
                        a = 1 / t.setFromMatrixColumn(e, 2).length();
                    return i[0] = n[0] * r, i[1] = n[1] * r, i[2] = n[2] * r, i[4] = n[4] * o, i[5] = n[5] * o, i[6] = n[6] * o, i[8] = n[8] * a, i[9] = n[9] * a, i[10] = n[10] * a, this
                }
            }(),
            makeRotationFromEuler: function(t) {
                t && t.isEuler || console.error("THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.");
                var e = this.elements,
                    i = t.x,
                    n = t.y,
                    r = t.z,
                    o = Math.cos(i),
                    a = Math.sin(i),
                    s = Math.cos(n),
                    l = Math.sin(n),
                    c = Math.cos(r),
                    u = Math.sin(r);
                if ("XYZ" === t.order) {
                    var h = o * c,
                        d = o * u,
                        p = a * c,
                        f = a * u;
                    e[0] = s * c, e[4] = -s * u, e[8] = l, e[1] = d + p * l, e[5] = h - f * l, e[9] = -a * s, e[2] = f - h * l, e[6] = p + d * l, e[10] = o * s
                } else if ("YXZ" === t.order) {
                    var m = s * c,
                        g = s * u,
                        v = l * c,
                        y = l * u;
                    e[0] = m + y * a, e[4] = v * a - g, e[8] = o * l, e[1] = o * u, e[5] = o * c, e[9] = -a, e[2] = g * a - v, e[6] = y + m * a, e[10] = o * s
                } else if ("ZXY" === t.order) {
                    var m = s * c,
                        g = s * u,
                        v = l * c,
                        y = l * u;
                    e[0] = m - y * a, e[4] = -o * u, e[8] = v + g * a, e[1] = g + v * a, e[5] = o * c, e[9] = y - m * a, e[2] = -o * l, e[6] = a, e[10] = o * s
                } else if ("ZYX" === t.order) {
                    var h = o * c,
                        d = o * u,
                        p = a * c,
                        f = a * u;
                    e[0] = s * c, e[4] = p * l - d, e[8] = h * l + f, e[1] = s * u, e[5] = f * l + h, e[9] = d * l - p, e[2] = -l, e[6] = a * s, e[10] = o * s
                } else if ("YZX" === t.order) {
                    var _ = o * s,
                        x = o * l,
                        b = a * s,
                        w = a * l;
                    e[0] = s * c, e[4] = w - _ * u, e[8] = b * u + x, e[1] = u, e[5] = o * c, e[9] = -a * c, e[2] = -l * c, e[6] = x * u + b, e[10] = _ - w * u
                } else if ("XZY" === t.order) {
                    var _ = o * s,
                        x = o * l,
                        b = a * s,
                        w = a * l;
                    e[0] = s * c, e[4] = -u, e[8] = l * c, e[1] = _ * u + w, e[5] = o * c, e[9] = x * u - b, e[2] = b * u - x, e[6] = a * c, e[10] = w * u + _
                }
                return e[3] = 0, e[7] = 0, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, this
            },
            makeRotationFromQuaternion: function(t) {
                var e = this.elements,
                    i = t._x,
                    n = t._y,
                    r = t._z,
                    o = t._w,
                    a = i + i,
                    s = n + n,
                    l = r + r,
                    c = i * a,
                    u = i * s,
                    h = i * l,
                    d = n * s,
                    p = n * l,
                    f = r * l,
                    m = o * a,
                    g = o * s,
                    v = o * l;
                return e[0] = 1 - (d + f), e[4] = u - v, e[8] = h + g, e[1] = u + v, e[5] = 1 - (c + f), e[9] = p - m, e[2] = h - g, e[6] = p + m, e[10] = 1 - (c + d), e[3] = 0, e[7] = 0, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, this
            },
            lookAt: function() {
                var t = new o,
                    e = new o,
                    i = new o;
                return function(n, r, o) {
                    var a = this.elements;
                    return i.subVectors(n, r), 0 === i.lengthSq() && (i.z = 1), i.normalize(), t.crossVectors(o, i), 0 === t.lengthSq() && (1 === Math.abs(o.z) ? i.x += 1e-4 : i.z += 1e-4, i.normalize(), t.crossVectors(o, i)), t.normalize(), e.crossVectors(i, t), a[0] = t.x, a[4] = e.x, a[8] = i.x, a[1] = t.y, a[5] = e.y, a[9] = i.y, a[2] = t.z, a[6] = e.z, a[10] = i.z, this
                }
            }(),
            multiply: function(t, e) {
                return void 0 !== e ? (console.warn("THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."), this.multiplyMatrices(t, e)) : this.multiplyMatrices(this, t)
            },
            premultiply: function(t) {
                return this.multiplyMatrices(t, this)
            },
            multiplyMatrices: function(t, e) {
                var i = t.elements,
                    n = e.elements,
                    r = this.elements,
                    o = i[0],
                    a = i[4],
                    s = i[8],
                    l = i[12],
                    c = i[1],
                    u = i[5],
                    h = i[9],
                    d = i[13],
                    p = i[2],
                    f = i[6],
                    m = i[10],
                    g = i[14],
                    v = i[3],
                    y = i[7],
                    _ = i[11],
                    x = i[15],
                    b = n[0],
                    w = n[4],
                    T = n[8],
                    S = n[12],
                    E = n[1],
                    M = n[5],
                    A = n[9],
                    L = n[13],
                    C = n[2],
                    P = n[6],
                    R = n[10],
                    O = n[14],
                    I = n[3],
                    D = n[7],
                    N = n[11],
                    F = n[15];
                return r[0] = o * b + a * E + s * C + l * I, r[4] = o * w + a * M + s * P + l * D, r[8] = o * T + a * A + s * R + l * N, r[12] = o * S + a * L + s * O + l * F, r[1] = c * b + u * E + h * C + d * I, r[5] = c * w + u * M + h * P + d * D, r[9] = c * T + u * A + h * R + d * N, r[13] = c * S + u * L + h * O + d * F, r[2] = p * b + f * E + m * C + g * I, r[6] = p * w + f * M + m * P + g * D, r[10] = p * T + f * A + m * R + g * N, r[14] = p * S + f * L + m * O + g * F, r[3] = v * b + y * E + _ * C + x * I, r[7] = v * w + y * M + _ * P + x * D, r[11] = v * T + y * A + _ * R + x * N, r[15] = v * S + y * L + _ * O + x * F, this
            },
            multiplyScalar: function(t) {
                var e = this.elements;
                return e[0] *= t, e[4] *= t, e[8] *= t, e[12] *= t, e[1] *= t, e[5] *= t, e[9] *= t, e[13] *= t, e[2] *= t, e[6] *= t, e[10] *= t, e[14] *= t, e[3] *= t, e[7] *= t, e[11] *= t, e[15] *= t, this
            },
            applyToBufferAttribute: function() {
                var t = new o;
                return function(e) {
                    for (var i = 0, n = e.count; i < n; i++) t.x = e.getX(i), t.y = e.getY(i), t.z = e.getZ(i), t.applyMatrix4(this), e.setXYZ(i, t.x, t.y, t.z);
                    return e
                }
            }(),
            determinant: function() {
                var t = this.elements,
                    e = t[0],
                    i = t[4],
                    n = t[8],
                    r = t[12],
                    o = t[1],
                    a = t[5],
                    s = t[9],
                    l = t[13],
                    c = t[2],
                    u = t[6],
                    h = t[10],
                    d = t[14];
                return t[3] * (+r * s * u - n * l * u - r * a * h + i * l * h + n * a * d - i * s * d) + t[7] * (+e * s * d - e * l * h + r * o * h - n * o * d + n * l * c - r * s * c) + t[11] * (+e * l * u - e * a * d - r * o * u + i * o * d + r * a * c - i * l * c) + t[15] * (-n * a * c - e * s * u + e * a * h + n * o * u - i * o * h + i * s * c)
            },
            transpose: function() {
                var t, e = this.elements;
                return t = e[1], e[1] = e[4], e[4] = t, t = e[2], e[2] = e[8], e[8] = t, t = e[6], e[6] = e[9], e[9] = t, t = e[3], e[3] = e[12], e[12] = t, t = e[7], e[7] = e[13], e[13] = t, t = e[11], e[11] = e[14], e[14] = t, this
            },
            setPosition: function(t) {
                var e = this.elements;
                return e[12] = t.x, e[13] = t.y, e[14] = t.z, this
            },
            getInverse: function(t, e) {
                var i = this.elements,
                    n = t.elements,
                    r = n[0],
                    o = n[1],
                    a = n[2],
                    s = n[3],
                    l = n[4],
                    c = n[5],
                    u = n[6],
                    h = n[7],
                    d = n[8],
                    p = n[9],
                    f = n[10],
                    m = n[11],
                    g = n[12],
                    v = n[13],
                    y = n[14],
                    _ = n[15],
                    x = p * y * h - v * f * h + v * u * m - c * y * m - p * u * _ + c * f * _,
                    b = g * f * h - d * y * h - g * u * m + l * y * m + d * u * _ - l * f * _,
                    w = d * v * h - g * p * h + g * c * m - l * v * m - d * c * _ + l * p * _,
                    T = g * p * u - d * v * u - g * c * f + l * v * f + d * c * y - l * p * y,
                    S = r * x + o * b + a * w + s * T;
                if (0 === S) {
                    var E = "THREE.Matrix4: .getInverse() can't invert matrix, determinant is 0";
                    if (!0 === e) throw new Error(E);
                    return console.warn(E), this.identity()
                }
                var M = 1 / S;
                return i[0] = x * M, i[1] = (v * f * s - p * y * s - v * a * m + o * y * m + p * a * _ - o * f * _) * M, i[2] = (c * y * s - v * u * s + v * a * h - o * y * h - c * a * _ + o * u * _) * M, i[3] = (p * u * s - c * f * s - p * a * h + o * f * h + c * a * m - o * u * m) * M, i[4] = b * M, i[5] = (d * y * s - g * f * s + g * a * m - r * y * m - d * a * _ + r * f * _) * M, i[6] = (g * u * s - l * y * s - g * a * h + r * y * h + l * a * _ - r * u * _) * M, i[7] = (l * f * s - d * u * s + d * a * h - r * f * h - l * a * m + r * u * m) * M, i[8] = w * M, i[9] = (g * p * s - d * v * s - g * o * m + r * v * m + d * o * _ - r * p * _) * M, i[10] = (l * v * s - g * c * s + g * o * h - r * v * h - l * o * _ + r * c * _) * M, i[11] = (d * c * s - l * p * s - d * o * h + r * p * h + l * o * m - r * c * m) * M, i[12] = T * M, i[13] = (d * v * a - g * p * a + g * o * f - r * v * f - d * o * y + r * p * y) * M, i[14] = (g * c * a - l * v * a - g * o * u + r * v * u + l * o * y - r * c * y) * M, i[15] = (l * p * a - d * c * a + d * o * u - r * p * u - l * o * f + r * c * f) * M, this
            },
            scale: function(t) {
                var e = this.elements,
                    i = t.x,
                    n = t.y,
                    r = t.z;
                return e[0] *= i, e[4] *= n, e[8] *= r, e[1] *= i, e[5] *= n, e[9] *= r, e[2] *= i, e[6] *= n, e[10] *= r, e[3] *= i, e[7] *= n, e[11] *= r, this
            },
            getMaxScaleOnAxis: function() {
                var t = this.elements,
                    e = t[0] * t[0] + t[1] * t[1] + t[2] * t[2],
                    i = t[4] * t[4] + t[5] * t[5] + t[6] * t[6],
                    n = t[8] * t[8] + t[9] * t[9] + t[10] * t[10];
                return Math.sqrt(Math.max(e, i, n))
            },
            makeTranslation: function(t, e, i) {
                return this.set(1, 0, 0, t, 0, 1, 0, e, 0, 0, 1, i, 0, 0, 0, 1), this
            },
            makeRotationX: function(t) {
                var e = Math.cos(t),
                    i = Math.sin(t);
                return this.set(1, 0, 0, 0, 0, e, -i, 0, 0, i, e, 0, 0, 0, 0, 1), this
            },
            makeRotationY: function(t) {
                var e = Math.cos(t),
                    i = Math.sin(t);
                return this.set(e, 0, i, 0, 0, 1, 0, 0, -i, 0, e, 0, 0, 0, 0, 1), this
            },
            makeRotationZ: function(t) {
                var e = Math.cos(t),
                    i = Math.sin(t);
                return this.set(e, -i, 0, 0, i, e, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
            },
            makeRotationAxis: function(t, e) {
                var i = Math.cos(e),
                    n = Math.sin(e),
                    r = 1 - i,
                    o = t.x,
                    a = t.y,
                    s = t.z,
                    l = r * o,
                    c = r * a;
                return this.set(l * o + i, l * a - n * s, l * s + n * a, 0, l * a + n * s, c * a + i, c * s - n * o, 0, l * s - n * a, c * s + n * o, r * s * s + i, 0, 0, 0, 0, 1), this
            },
            makeScale: function(t, e, i) {
                return this.set(t, 0, 0, 0, 0, e, 0, 0, 0, 0, i, 0, 0, 0, 0, 1), this
            },
            makeShear: function(t, e, i) {
                return this.set(1, e, i, 0, t, 1, i, 0, t, e, 1, 0, 0, 0, 0, 1), this
            },
            compose: function(t, e, i) {
                return this.makeRotationFromQuaternion(e), this.scale(i), this.setPosition(t), this
            },
            decompose: function() {
                var t = new o,
                    e = new n;
                return function(i, n, r) {
                    var o = this.elements,
                        a = t.set(o[0], o[1], o[2]).length(),
                        s = t.set(o[4], o[5], o[6]).length(),
                        l = t.set(o[8], o[9], o[10]).length();
                    this.determinant() < 0 && (a = -a), i.x = o[12], i.y = o[13], i.z = o[14], e.copy(this);
                    var c = 1 / a,
                        u = 1 / s,
                        h = 1 / l;
                    return e.elements[0] *= c, e.elements[1] *= c, e.elements[2] *= c, e.elements[4] *= u, e.elements[5] *= u, e.elements[6] *= u, e.elements[8] *= h, e.elements[9] *= h, e.elements[10] *= h, n.setFromRotationMatrix(e), r.x = a, r.y = s, r.z = l, this
                }
            }(),
            makePerspective: function(t, e, i, n, r, o) {
                void 0 === o && console.warn("THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.");
                var a = this.elements,
                    s = 2 * r / (e - t),
                    l = 2 * r / (i - n),
                    c = (e + t) / (e - t),
                    u = (i + n) / (i - n),
                    h = -(o + r) / (o - r),
                    d = -2 * o * r / (o - r);
                return a[0] = s, a[4] = 0, a[8] = c, a[12] = 0, a[1] = 0, a[5] = l, a[9] = u, a[13] = 0, a[2] = 0, a[6] = 0, a[10] = h, a[14] = d, a[3] = 0, a[7] = 0, a[11] = -1, a[15] = 0, this
            },
            makeOrthographic: function(t, e, i, n, r, o) {
                var a = this.elements,
                    s = 1 / (e - t),
                    l = 1 / (i - n),
                    c = 1 / (o - r),
                    u = (e + t) * s,
                    h = (i + n) * l,
                    d = (o + r) * c;
                return a[0] = 2 * s, a[4] = 0, a[8] = 0, a[12] = -u, a[1] = 0, a[5] = 2 * l, a[9] = 0, a[13] = -h, a[2] = 0, a[6] = 0, a[10] = -2 * c, a[14] = -d, a[3] = 0, a[7] = 0, a[11] = 0, a[15] = 1, this
            },
            equals: function(t) {
                for (var e = this.elements, i = t.elements, n = 0; n < 16; n++)
                    if (e[n] !== i[n]) return !1;
                return !0
            },
            fromArray: function(t, e) {
                void 0 === e && (e = 0);
                for (var i = 0; i < 16; i++) this.elements[i] = t[i + e];
                return this
            },
            toArray: function(t, e) {
                void 0 === t && (t = []), void 0 === e && (e = 0);
                var i = this.elements;
                return t[e] = i[0], t[e + 1] = i[1], t[e + 2] = i[2], t[e + 3] = i[3], t[e + 4] = i[4], t[e + 5] = i[5], t[e + 6] = i[6], t[e + 7] = i[7], t[e + 8] = i[8], t[e + 9] = i[9], t[e + 10] = i[10], t[e + 11] = i[11], t[e + 12] = i[12], t[e + 13] = i[13], t[e + 14] = i[14], t[e + 15] = i[15], t
            }
        }), Object.assign(r, {
            slerp: function(t, e, i, n) {
                return i.copy(t).slerp(e, n)
            },
            slerpFlat: function(t, e, i, n, r, o, a) {
                var s = i[n + 0],
                    l = i[n + 1],
                    c = i[n + 2],
                    u = i[n + 3],
                    h = r[o + 0],
                    d = r[o + 1],
                    p = r[o + 2],
                    f = r[o + 3];
                if (u !== f || s !== h || l !== d || c !== p) {
                    var m = 1 - a,
                        g = s * h + l * d + c * p + u * f,
                        v = g >= 0 ? 1 : -1,
                        y = 1 - g * g;
                    if (y > Number.EPSILON) {
                        var _ = Math.sqrt(y),
                            x = Math.atan2(_, g * v);
                        m = Math.sin(m * x) / _, a = Math.sin(a * x) / _
                    }
                    var b = a * v;
                    if (s = s * m + h * b, l = l * m + d * b, c = c * m + p * b, u = u * m + f * b, m === 1 - a) {
                        var w = 1 / Math.sqrt(s * s + l * l + c * c + u * u);
                        s *= w, l *= w, c *= w, u *= w
                    }
                }
                t[e] = s, t[e + 1] = l, t[e + 2] = c, t[e + 3] = u
            }
        }), Object.defineProperties(r.prototype, {
            x: {
                get: function() {
                    return this._x
                },
                set: function(t) {
                    this._x = t, this.onChangeCallback()
                }
            },
            y: {
                get: function() {
                    return this._y
                },
                set: function(t) {
                    this._y = t, this.onChangeCallback()
                }
            },
            z: {
                get: function() {
                    return this._z
                },
                set: function(t) {
                    this._z = t, this.onChangeCallback()
                }
            },
            w: {
                get: function() {
                    return this._w
                },
                set: function(t) {
                    this._w = t, this.onChangeCallback()
                }
            }
        }), Object.assign(r.prototype, {
            set: function(t, e, i, n) {
                return this._x = t, this._y = e, this._z = i, this._w = n, this.onChangeCallback(), this
            },
            clone: function() {
                return new this.constructor(this._x, this._y, this._z, this._w)
            },
            copy: function(t) {
                return this._x = t.x, this._y = t.y, this._z = t.z, this._w = t.w, this.onChangeCallback(), this
            },
            setFromEuler: function(t, e) {
                if (!t || !t.isEuler) throw new Error("THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.");
                var i = t._x,
                    n = t._y,
                    r = t._z,
                    o = t.order,
                    a = Math.cos,
                    s = Math.sin,
                    l = a(i / 2),
                    c = a(n / 2),
                    u = a(r / 2),
                    h = s(i / 2),
                    d = s(n / 2),
                    p = s(r / 2);
                return "XYZ" === o ? (this._x = h * c * u + l * d * p, this._y = l * d * u - h * c * p, this._z = l * c * p + h * d * u, this._w = l * c * u - h * d * p) : "YXZ" === o ? (this._x = h * c * u + l * d * p, this._y = l * d * u - h * c * p, this._z = l * c * p - h * d * u, this._w = l * c * u + h * d * p) : "ZXY" === o ? (this._x = h * c * u - l * d * p, this._y = l * d * u + h * c * p, this._z = l * c * p + h * d * u, this._w = l * c * u - h * d * p) : "ZYX" === o ? (this._x = h * c * u - l * d * p, this._y = l * d * u + h * c * p, this._z = l * c * p - h * d * u, this._w = l * c * u + h * d * p) : "YZX" === o ? (this._x = h * c * u + l * d * p, this._y = l * d * u + h * c * p, this._z = l * c * p - h * d * u, this._w = l * c * u - h * d * p) : "XZY" === o && (this._x = h * c * u - l * d * p, this._y = l * d * u - h * c * p, this._z = l * c * p + h * d * u, this._w = l * c * u + h * d * p), !1 !== e && this.onChangeCallback(), this
            },
            setFromAxisAngle: function(t, e) {
                var i = e / 2,
                    n = Math.sin(i);
                return this._x = t.x * n, this._y = t.y * n, this._z = t.z * n, this._w = Math.cos(i), this.onChangeCallback(), this
            },
            setFromRotationMatrix: function(t) {
                var e, i = t.elements,
                    n = i[0],
                    r = i[4],
                    o = i[8],
                    a = i[1],
                    s = i[5],
                    l = i[9],
                    c = i[2],
                    u = i[6],
                    h = i[10],
                    d = n + s + h;
                return d > 0 ? (e = .5 / Math.sqrt(d + 1), this._w = .25 / e, this._x = (u - l) * e, this._y = (o - c) * e, this._z = (a - r) * e) : n > s && n > h ? (e = 2 * Math.sqrt(1 + n - s - h), this._w = (u - l) / e, this._x = .25 * e, this._y = (r + a) / e, this._z = (o + c) / e) : s > h ? (e = 2 * Math.sqrt(1 + s - n - h), this._w = (o - c) / e, this._x = (r + a) / e, this._y = .25 * e, this._z = (l + u) / e) : (e = 2 * Math.sqrt(1 + h - n - s), this._w = (a - r) / e, this._x = (o + c) / e, this._y = (l + u) / e, this._z = .25 * e), this.onChangeCallback(), this
            },
            setFromUnitVectors: function() {
                var t, e = new o;
                return function(i, n) {
                    return void 0 === e && (e = new o), t = i.dot(n) + 1, t < 1e-6 ? (t = 0, Math.abs(i.x) > Math.abs(i.z) ? e.set(-i.y, i.x, 0) : e.set(0, -i.z, i.y)) : e.crossVectors(i, n), this._x = e.x, this._y = e.y, this._z = e.z, this._w = t, this.normalize()
                }
            }(),
            inverse: function() {
                return this.conjugate().normalize()
            },
            conjugate: function() {
                return this._x *= -1, this._y *= -1, this._z *= -1, this.onChangeCallback(), this
            },
            dot: function(t) {
                return this._x * t._x + this._y * t._y + this._z * t._z + this._w * t._w
            },
            lengthSq: function() {
                return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w
            },
            length: function() {
                return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w)
            },
            normalize: function() {
                var t = this.length();
                return 0 === t ? (this._x = 0, this._y = 0, this._z = 0, this._w = 1) : (t = 1 / t, this._x = this._x * t, this._y = this._y * t, this._z = this._z * t, this._w = this._w * t), this.onChangeCallback(), this
            },
            multiply: function(t, e) {
                return void 0 !== e ? (console.warn("THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."), this.multiplyQuaternions(t, e)) : this.multiplyQuaternions(this, t)
            },
            premultiply: function(t) {
                return this.multiplyQuaternions(t, this)
            },
            multiplyQuaternions: function(t, e) {
                var i = t._x,
                    n = t._y,
                    r = t._z,
                    o = t._w,
                    a = e._x,
                    s = e._y,
                    l = e._z,
                    c = e._w;
                return this._x = i * c + o * a + n * l - r * s, this._y = n * c + o * s + r * a - i * l, this._z = r * c + o * l + i * s - n * a, this._w = o * c - i * a - n * s - r * l, this.onChangeCallback(), this
            },
            slerp: function(t, e) {
                if (0 === e) return this;
                if (1 === e) return this.copy(t);
                var i = this._x,
                    n = this._y,
                    r = this._z,
                    o = this._w,
                    a = o * t._w + i * t._x + n * t._y + r * t._z;
                if (a < 0 ? (this._w = -t._w, this._x = -t._x, this._y = -t._y, this._z = -t._z, a = -a) : this.copy(t), a >= 1) return this._w = o, this._x = i, this._y = n, this._z = r, this;
                var s = Math.sqrt(1 - a * a);
                if (Math.abs(s) < .001) return this._w = .5 * (o + this._w), this._x = .5 * (i + this._x), this._y = .5 * (n + this._y), this._z = .5 * (r + this._z), this;
                var l = Math.atan2(s, a),
                    c = Math.sin((1 - e) * l) / s,
                    u = Math.sin(e * l) / s;
                return this._w = o * c + this._w * u, this._x = i * c + this._x * u, this._y = n * c + this._y * u, this._z = r * c + this._z * u, this.onChangeCallback(), this
            },
            equals: function(t) {
                return t._x === this._x && t._y === this._y && t._z === this._z && t._w === this._w
            },
            fromArray: function(t, e) {
                return void 0 === e && (e = 0), this._x = t[e], this._y = t[e + 1], this._z = t[e + 2], this._w = t[e + 3], this.onChangeCallback(), this
            },
            toArray: function(t, e) {
                return void 0 === t && (t = []), void 0 === e && (e = 0), t[e] = this._x, t[e + 1] = this._y, t[e + 2] = this._z, t[e + 3] = this._w, t
            },
            onChange: function(t) {
                return this.onChangeCallback = t, this
            },
            onChangeCallback: function() {}
        }), Object.assign(o.prototype, {
            isVector3: !0,
            set: function(t, e, i) {
                return this.x = t, this.y = e, this.z = i, this
            },
            setScalar: function(t) {
                return this.x = t, this.y = t, this.z = t, this
            },
            setX: function(t) {
                return this.x = t, this
            },
            setY: function(t) {
                return this.y = t, this
            },
            setZ: function(t) {
                return this.z = t, this
            },
            setComponent: function(t, e) {
                switch (t) {
                    case 0:
                        this.x = e;
                        break;
                    case 1:
                        this.y = e;
                        break;
                    case 2:
                        this.z = e;
                        break;
                    default:
                        throw new Error("index is out of range: " + t)
                }
                return this
            },
            getComponent: function(t) {
                switch (t) {
                    case 0:
                        return this.x;
                    case 1:
                        return this.y;
                    case 2:
                        return this.z;
                    default:
                        throw new Error("index is out of range: " + t)
                }
            },
            clone: function() {
                return new this.constructor(this.x, this.y, this.z)
            },
            copy: function(t) {
                return this.x = t.x, this.y = t.y, this.z = t.z, this
            },
            add: function(t, e) {
                return void 0 !== e ? (console.warn("THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(t, e)) : (this.x += t.x, this.y += t.y, this.z += t.z, this)
            },
            addScalar: function(t) {
                return this.x += t, this.y += t, this.z += t, this
            },
            addVectors: function(t, e) {
                return this.x = t.x + e.x, this.y = t.y + e.y, this.z = t.z + e.z, this
            },
            addScaledVector: function(t, e) {
                return this.x += t.x * e, this.y += t.y * e, this.z += t.z * e, this
            },
            sub: function(t, e) {
                return void 0 !== e ? (console.warn("THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(t, e)) : (this.x -= t.x, this.y -= t.y, this.z -= t.z, this)
            },
            subScalar: function(t) {
                return this.x -= t, this.y -= t, this.z -= t, this
            },
            subVectors: function(t, e) {
                return this.x = t.x - e.x, this.y = t.y - e.y, this.z = t.z - e.z, this
            },
            multiply: function(t, e) {
                return void 0 !== e ? (console.warn("THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."), this.multiplyVectors(t, e)) : (this.x *= t.x, this.y *= t.y, this.z *= t.z, this)
            },
            multiplyScalar: function(t) {
                return this.x *= t, this.y *= t, this.z *= t, this
            },
            multiplyVectors: function(t, e) {
                return this.x = t.x * e.x, this.y = t.y * e.y, this.z = t.z * e.z, this
            },
            applyEuler: function() {
                var t = new r;
                return function(e) {
                    return e && e.isEuler || console.error("THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order."), this.applyQuaternion(t.setFromEuler(e))
                }
            }(),
            applyAxisAngle: function() {
                var t = new r;
                return function(e, i) {
                    return this.applyQuaternion(t.setFromAxisAngle(e, i))
                }
            }(),
            applyMatrix3: function(t) {
                var e = this.x,
                    i = this.y,
                    n = this.z,
                    r = t.elements;
                return this.x = r[0] * e + r[3] * i + r[6] * n, this.y = r[1] * e + r[4] * i + r[7] * n, this.z = r[2] * e + r[5] * i + r[8] * n, this
            },
            applyMatrix4: function(t) {
                var e = this.x,
                    i = this.y,
                    n = this.z,
                    r = t.elements,
                    o = 1 / (r[3] * e + r[7] * i + r[11] * n + r[15]);
                return this.x = (r[0] * e + r[4] * i + r[8] * n + r[12]) * o, this.y = (r[1] * e + r[5] * i + r[9] * n + r[13]) * o, this.z = (r[2] * e + r[6] * i + r[10] * n + r[14]) * o, this
            },
            applyQuaternion: function(t) {
                var e = this.x,
                    i = this.y,
                    n = this.z,
                    r = t.x,
                    o = t.y,
                    a = t.z,
                    s = t.w,
                    l = s * e + o * n - a * i,
                    c = s * i + a * e - r * n,
                    u = s * n + r * i - o * e,
                    h = -r * e - o * i - a * n;
                return this.x = l * s + h * -r + c * -a - u * -o, this.y = c * s + h * -o + u * -r - l * -a, this.z = u * s + h * -a + l * -o - c * -r, this
            },
            project: function() {
                var t = new n;
                return function(e) {
                    return t.multiplyMatrices(e.projectionMatrix, t.getInverse(e.matrixWorld)), this.applyMatrix4(t)
                }
            }(),
            unproject: function() {
                var t = new n;
                return function(e) {
                    return t.multiplyMatrices(e.matrixWorld, t.getInverse(e.projectionMatrix)), this.applyMatrix4(t)
                }
            }(),
            transformDirection: function(t) {
                var e = this.x,
                    i = this.y,
                    n = this.z,
                    r = t.elements;
                return this.x = r[0] * e + r[4] * i + r[8] * n, this.y = r[1] * e + r[5] * i + r[9] * n, this.z = r[2] * e + r[6] * i + r[10] * n, this.normalize()
            },
            divide: function(t) {
                return this.x /= t.x, this.y /= t.y, this.z /= t.z, this
            },
            divideScalar: function(t) {
                return this.multiplyScalar(1 / t)
            },
            min: function(t) {
                return this.x = Math.min(this.x, t.x), this.y = Math.min(this.y, t.y), this.z = Math.min(this.z, t.z), this
            },
            max: function(t) {
                return this.x = Math.max(this.x, t.x), this.y = Math.max(this.y, t.y), this.z = Math.max(this.z, t.z), this
            },
            clamp: function(t, e) {
                return this.x = Math.max(t.x, Math.min(e.x, this.x)), this.y = Math.max(t.y, Math.min(e.y, this.y)), this.z = Math.max(t.z, Math.min(e.z, this.z)), this
            },
            clampScalar: function() {
                var t = new o,
                    e = new o;
                return function(i, n) {
                    return t.set(i, i, i), e.set(n, n, n), this.clamp(t, e)
                }
            }(),
            clampLength: function(t, e) {
                var i = this.length();
                return this.divideScalar(i || 1).multiplyScalar(Math.max(t, Math.min(e, i)))
            },
            floor: function() {
                return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this
            },
            ceil: function() {
                return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this
            },
            round: function() {
                return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this
            },
            roundToZero: function() {
                return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this
            },
            negate: function() {
                return this.x = -this.x, this.y = -this.y, this.z = -this.z, this
            },
            dot: function(t) {
                return this.x * t.x + this.y * t.y + this.z * t.z
            },
            lengthSq: function() {
                return this.x * this.x + this.y * this.y + this.z * this.z
            },
            length: function() {
                return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z)
            },
            manhattanLength: function() {
                return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z)
            },
            normalize: function() {
                return this.divideScalar(this.length() || 1)
            },
            setLength: function(t) {
                return this.normalize().multiplyScalar(t)
            },
            lerp: function(t, e) {
                return this.x += (t.x - this.x) * e, this.y += (t.y - this.y) * e, this.z += (t.z - this.z) * e, this
            },
            lerpVectors: function(t, e, i) {
                return this.subVectors(e, t).multiplyScalar(i).add(t)
            },
            cross: function(t, e) {
                return void 0 !== e ? (console.warn("THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."), this.crossVectors(t, e)) : this.crossVectors(this, t)
            },
            crossVectors: function(t, e) {
                var i = t.x,
                    n = t.y,
                    r = t.z,
                    o = e.x,
                    a = e.y,
                    s = e.z;
                return this.x = n * s - r * a, this.y = r * o - i * s, this.z = i * a - n * o, this
            },
            projectOnVector: function(t) {
                var e = t.dot(this) / t.lengthSq();
                return this.copy(t).multiplyScalar(e)
            },
            projectOnPlane: function() {
                var t = new o;
                return function(e) {
                    return t.copy(this).projectOnVector(e), this.sub(t)
                }
            }(),
            reflect: function() {
                var t = new o;
                return function(e) {
                    return this.sub(t.copy(e).multiplyScalar(2 * this.dot(e)))
                }
            }(),
            angleTo: function(t) {
                var e = this.dot(t) / Math.sqrt(this.lengthSq() * t.lengthSq());
                return Math.acos(Ha.clamp(e, -1, 1))
            },
            distanceTo: function(t) {
                return Math.sqrt(this.distanceToSquared(t))
            },
            distanceToSquared: function(t) {
                var e = this.x - t.x,
                    i = this.y - t.y,
                    n = this.z - t.z;
                return e * e + i * i + n * n
            },
            manhattanDistanceTo: function(t) {
                return Math.abs(this.x - t.x) + Math.abs(this.y - t.y) + Math.abs(this.z - t.z)
            },
            setFromSpherical: function(t) {
                var e = Math.sin(t.phi) * t.radius;
                return this.x = e * Math.sin(t.theta), this.y = Math.cos(t.phi) * t.radius, this.z = e * Math.cos(t.theta), this
            },
            setFromCylindrical: function(t) {
                return this.x = t.radius * Math.sin(t.theta), this.y = t.y, this.z = t.radius * Math.cos(t.theta), this
            },
            setFromMatrixPosition: function(t) {
                var e = t.elements;
                return this.x = e[12], this.y = e[13], this.z = e[14], this
            },
            setFromMatrixScale: function(t) {
                var e = this.setFromMatrixColumn(t, 0).length(),
                    i = this.setFromMatrixColumn(t, 1).length(),
                    n = this.setFromMatrixColumn(t, 2).length();
                return this.x = e, this.y = i, this.z = n, this
            },
            setFromMatrixColumn: function(t, e) {
                return this.fromArray(t.elements, 4 * e)
            },
            equals: function(t) {
                return t.x === this.x && t.y === this.y && t.z === this.z
            },
            fromArray: function(t, e) {
                return void 0 === e && (e = 0), this.x = t[e], this.y = t[e + 1], this.z = t[e + 2], this
            },
            toArray: function(t, e) {
                return void 0 === t && (t = []), void 0 === e && (e = 0), t[e] = this.x, t[e + 1] = this.y, t[e + 2] = this.z, t
            },
            fromBufferAttribute: function(t, e, i) {
                return void 0 !== i && console.warn("THREE.Vector3: offset has been removed from .fromBufferAttribute()."), this.x = t.getX(e), this.y = t.getY(e), this.z = t.getZ(e), this
            }
        }), Object.assign(a.prototype, {
            isMatrix3: !0,
            set: function(t, e, i, n, r, o, a, s, l) {
                var c = this.elements;
                return c[0] = t, c[1] = n, c[2] = a, c[3] = e, c[4] = r, c[5] = s, c[6] = i, c[7] = o, c[8] = l, this
            },
            identity: function() {
                return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this
            },
            clone: function() {
                return (new this.constructor).fromArray(this.elements)
            },
            copy: function(t) {
                var e = this.elements,
                    i = t.elements;
                return e[0] = i[0], e[1] = i[1], e[2] = i[2], e[3] = i[3], e[4] = i[4], e[5] = i[5], e[6] = i[6], e[7] = i[7], e[8] = i[8], this
            },
            setFromMatrix4: function(t) {
                var e = t.elements;
                return this.set(e[0], e[4], e[8], e[1], e[5], e[9], e[2], e[6], e[10]), this
            },
            applyToBufferAttribute: function() {
                var t = new o;
                return function(e) {
                    for (var i = 0, n = e.count; i < n; i++) t.x = e.getX(i), t.y = e.getY(i), t.z = e.getZ(i), t.applyMatrix3(this), e.setXYZ(i, t.x, t.y, t.z);
                    return e
                }
            }(),
            multiply: function(t) {
                return this.multiplyMatrices(this, t)
            },
            premultiply: function(t) {
                return this.multiplyMatrices(t, this)
            },
            multiplyMatrices: function(t, e) {
                var i = t.elements,
                    n = e.elements,
                    r = this.elements,
                    o = i[0],
                    a = i[3],
                    s = i[6],
                    l = i[1],
                    c = i[4],
                    u = i[7],
                    h = i[2],
                    d = i[5],
                    p = i[8],
                    f = n[0],
                    m = n[3],
                    g = n[6],
                    v = n[1],
                    y = n[4],
                    _ = n[7],
                    x = n[2],
                    b = n[5],
                    w = n[8];
                return r[0] = o * f + a * v + s * x, r[3] = o * m + a * y + s * b, r[6] = o * g + a * _ + s * w, r[1] = l * f + c * v + u * x, r[4] = l * m + c * y + u * b, r[7] = l * g + c * _ + u * w, r[2] = h * f + d * v + p * x, r[5] = h * m + d * y + p * b, r[8] = h * g + d * _ + p * w, this
            },
            multiplyScalar: function(t) {
                var e = this.elements;
                return e[0] *= t, e[3] *= t, e[6] *= t, e[1] *= t, e[4] *= t, e[7] *= t, e[2] *= t, e[5] *= t, e[8] *= t, this
            },
            determinant: function() {
                var t = this.elements,
                    e = t[0],
                    i = t[1],
                    n = t[2],
                    r = t[3],
                    o = t[4],
                    a = t[5],
                    s = t[6],
                    l = t[7],
                    c = t[8];
                return e * o * c - e * a * l - i * r * c + i * a * s + n * r * l - n * o * s
            },
            getInverse: function(t, e) {
                t && t.isMatrix4 && console.error("THREE.Matrix3: .getInverse() no longer takes a Matrix4 argument.");
                var i = t.elements,
                    n = this.elements,
                    r = i[0],
                    o = i[1],
                    a = i[2],
                    s = i[3],
                    l = i[4],
                    c = i[5],
                    u = i[6],
                    h = i[7],
                    d = i[8],
                    p = d * l - c * h,
                    f = c * u - d * s,
                    m = h * s - l * u,
                    g = r * p + o * f + a * m;
                if (0 === g) {
                    var v = "THREE.Matrix3: .getInverse() can't invert matrix, determinant is 0";
                    if (!0 === e) throw new Error(v);
                    return console.warn(v), this.identity()
                }
                var y = 1 / g;
                return n[0] = p * y, n[1] = (a * h - d * o) * y, n[2] = (c * o - a * l) * y, n[3] = f * y, n[4] = (d * r - a * u) * y, n[5] = (a * s - c * r) * y, n[6] = m * y, n[7] = (o * u - h * r) * y, n[8] = (l * r - o * s) * y, this
            },
            transpose: function() {
                var t, e = this.elements;
                return t = e[1], e[1] = e[3], e[3] = t, t = e[2], e[2] = e[6], e[6] = t, t = e[5], e[5] = e[7], e[7] = t, this
            },
            getNormalMatrix: function(t) {
                return this.setFromMatrix4(t).getInverse(this).transpose()
            },
            transposeIntoArray: function(t) {
                var e = this.elements;
                return t[0] = e[0], t[1] = e[3], t[2] = e[6], t[3] = e[1], t[4] = e[4], t[5] = e[7], t[6] = e[2], t[7] = e[5], t[8] = e[8], this
            },
            setUvTransform: function(t, e, i, n, r, o, a) {
                var s = Math.cos(r),
                    l = Math.sin(r);
                this.set(i * s, i * l, -i * (s * o + l * a) + o + t, -n * l, n * s, -n * (-l * o + s * a) + a + e, 0, 0, 1)
            },
            scale: function(t, e) {
                var i = this.elements;
                return i[0] *= t, i[3] *= t, i[6] *= t, i[1] *= e, i[4] *= e, i[7] *= e, this
            },
            rotate: function(t) {
                var e = Math.cos(t),
                    i = Math.sin(t),
                    n = this.elements,
                    r = n[0],
                    o = n[3],
                    a = n[6],
                    s = n[1],
                    l = n[4],
                    c = n[7];
                return n[0] = e * r + i * s, n[3] = e * o + i * l, n[6] = e * a + i * c, n[1] = -i * r + e * s, n[4] = -i * o + e * l, n[7] = -i * a + e * c, this
            },
            translate: function(t, e) {
                var i = this.elements;
                return i[0] += t * i[2], i[3] += t * i[5], i[6] += t * i[8], i[1] += e * i[2], i[4] += e * i[5], i[7] += e * i[8], this
            },
            equals: function(t) {
                for (var e = this.elements, i = t.elements, n = 0; n < 9; n++)
                    if (e[n] !== i[n]) return !1;
                return !0
            },
            fromArray: function(t, e) {
                void 0 === e && (e = 0);
                for (var i = 0; i < 9; i++) this.elements[i] = t[i + e];
                return this
            },
            toArray: function(t, e) {
                void 0 === t && (t = []), void 0 === e && (e = 0);
                var i = this.elements;
                return t[e] = i[0], t[e + 1] = i[1], t[e + 2] = i[2], t[e + 3] = i[3], t[e + 4] = i[4], t[e + 5] = i[5], t[e + 6] = i[6], t[e + 7] = i[7], t[e + 8] = i[8], t
            }
        });
        var Ga = 0;
        s.DEFAULT_IMAGE = void 0, s.DEFAULT_MAPPING = 300, Object.defineProperty(s.prototype, "needsUpdate", {
            set: function(t) {
                !0 === t && this.version++
            }
        }), Object.assign(s.prototype, e.prototype, {
            constructor: s,
            isTexture: !0,
            clone: function() {
                return (new this.constructor).copy(this)
            },
            copy: function(t) {
                return this.name = t.name, this.image = t.image, this.mipmaps = t.mipmaps.slice(0), this.mapping = t.mapping, this.wrapS = t.wrapS, this.wrapT = t.wrapT, this.magFilter = t.magFilter, this.minFilter = t.minFilter, this.anisotropy = t.anisotropy, this.format = t.format, this.type = t.type, this.offset.copy(t.offset), this.repeat.copy(t.repeat), this.center.copy(t.center), this.rotation = t.rotation, this.matrixAutoUpdate = t.matrixAutoUpdate, this.matrix.copy(t.matrix), this.generateMipmaps = t.generateMipmaps, this.premultiplyAlpha = t.premultiplyAlpha, this.flipY = t.flipY, this.unpackAlignment = t.unpackAlignment, this.encoding = t.encoding, this
            },
            toJSON: function(t) {
                var e = void 0 === t || "string" == typeof t;
                if (!e && void 0 !== t.textures[this.uuid]) return t.textures[this.uuid];
                var i = {
                    metadata: {
                        version: 4.5,
                        type: "Texture",
                        generator: "Texture.toJSON"
                    },
                    uuid: this.uuid,
                    name: this.name,
                    mapping: this.mapping,
                    repeat: [this.repeat.x, this.repeat.y],
                    offset: [this.offset.x, this.offset.y],
                    center: [this.center.x, this.center.y],
                    rotation: this.rotation,
                    wrap: [this.wrapS, this.wrapT],
                    minFilter: this.minFilter,
                    magFilter: this.magFilter,
                    anisotropy: this.anisotropy,
                    flipY: this.flipY
                };
                if (void 0 !== this.image) {
                    var n = this.image;
                    void 0 === n.uuid && (n.uuid = Ha.generateUUID()), e || void 0 !== t.images[n.uuid] || (t.images[n.uuid] = {
                        uuid: n.uuid,
                        url: function(t) {
                            var e;
                            if (t instanceof HTMLCanvasElement) e = t;
                            else {
                                (e = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas")).width = t.width, e.height = t.height;
                                var i = e.getContext("2d");
                                t instanceof ImageData ? i.putImageData(t, 0, 0) : i.drawImage(t, 0, 0, t.width, t.height)
                            }
                            return e.width > 2048 || e.height > 2048 ? e.toDataURL("image/jpeg", .6) : e.toDataURL("image/png")
                        }(n)
                    }), i.image = n.uuid
                }
                return e || (t.textures[this.uuid] = i), i
            },
            dispose: function() {
                this.dispatchEvent({
                    type: "dispose"
                })
            },
            transformUv: function(t) {
                if (300 === this.mapping) {
                    if (t.applyMatrix3(this.matrix), t.x < 0 || t.x > 1) switch (this.wrapS) {
                        case Vo:
                            t.x = t.x - Math.floor(t.x);
                            break;
                        case Wo:
                            t.x = t.x < 0 ? 0 : 1;
                            break;
                        case Xo:
                            1 === Math.abs(Math.floor(t.x) % 2) ? t.x = Math.ceil(t.x) - t.x : t.x = t.x - Math.floor(t.x)
                    }
                    if (t.y < 0 || t.y > 1) switch (this.wrapT) {
                        case Vo:
                            t.y = t.y - Math.floor(t.y);
                            break;
                        case Wo:
                            t.y = t.y < 0 ? 0 : 1;
                            break;
                        case Xo:
                            1 === Math.abs(Math.floor(t.y) % 2) ? t.y = Math.ceil(t.y) - t.y : t.y = t.y - Math.floor(t.y)
                    }
                    this.flipY && (t.y = 1 - t.y)
                }
            }
        }), Object.assign(l.prototype, {
            isVector4: !0,
            set: function(t, e, i, n) {
                return this.x = t, this.y = e, this.z = i, this.w = n, this
            },
            setScalar: function(t) {
                return this.x = t, this.y = t, this.z = t, this.w = t, this
            },
            setX: function(t) {
                return this.x = t, this
            },
            setY: function(t) {
                return this.y = t, this
            },
            setZ: function(t) {
                return this.z = t, this
            },
            setW: function(t) {
                return this.w = t, this
            },
            setComponent: function(t, e) {
                switch (t) {
                    case 0:
                        this.x = e;
                        break;
                    case 1:
                        this.y = e;
                        break;
                    case 2:
                        this.z = e;
                        break;
                    case 3:
                        this.w = e;
                        break;
                    default:
                        throw new Error("index is out of range: " + t)
                }
                return this
            },
            getComponent: function(t) {
                switch (t) {
                    case 0:
                        return this.x;
                    case 1:
                        return this.y;
                    case 2:
                        return this.z;
                    case 3:
                        return this.w;
                    default:
                        throw new Error("index is out of range: " + t)
                }
            },
            clone: function() {
                return new this.constructor(this.x, this.y, this.z, this.w)
            },
            copy: function(t) {
                return this.x = t.x, this.y = t.y, this.z = t.z, this.w = void 0 !== t.w ? t.w : 1, this
            },
            add: function(t, e) {
                return void 0 !== e ? (console.warn("THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(t, e)) : (this.x += t.x, this.y += t.y, this.z += t.z, this.w += t.w, this)
            },
            addScalar: function(t) {
                return this.x += t, this.y += t, this.z += t, this.w += t, this
            },
            addVectors: function(t, e) {
                return this.x = t.x + e.x, this.y = t.y + e.y, this.z = t.z + e.z, this.w = t.w + e.w, this
            },
            addScaledVector: function(t, e) {
                return this.x += t.x * e, this.y += t.y * e, this.z += t.z * e, this.w += t.w * e, this
            },
            sub: function(t, e) {
                return void 0 !== e ? (console.warn("THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(t, e)) : (this.x -= t.x, this.y -= t.y, this.z -= t.z, this.w -= t.w, this)
            },
            subScalar: function(t) {
                return this.x -= t, this.y -= t, this.z -= t, this.w -= t, this
            },
            subVectors: function(t, e) {
                return this.x = t.x - e.x, this.y = t.y - e.y, this.z = t.z - e.z, this.w = t.w - e.w, this
            },
            multiplyScalar: function(t) {
                return this.x *= t, this.y *= t, this.z *= t, this.w *= t, this
            },
            applyMatrix4: function(t) {
                var e = this.x,
                    i = this.y,
                    n = this.z,
                    r = this.w,
                    o = t.elements;
                return this.x = o[0] * e + o[4] * i + o[8] * n + o[12] * r, this.y = o[1] * e + o[5] * i + o[9] * n + o[13] * r, this.z = o[2] * e + o[6] * i + o[10] * n + o[14] * r, this.w = o[3] * e + o[7] * i + o[11] * n + o[15] * r, this
            },
            divideScalar: function(t) {
                return this.multiplyScalar(1 / t)
            },
            setAxisAngleFromQuaternion: function(t) {
                this.w = 2 * Math.acos(t.w);
                var e = Math.sqrt(1 - t.w * t.w);
                return e < 1e-4 ? (this.x = 1, this.y = 0, this.z = 0) : (this.x = t.x / e, this.y = t.y / e, this.z = t.z / e), this
            },
            setAxisAngleFromRotationMatrix: function(t) {
                var e, i, n, r, o = t.elements,
                    a = o[0],
                    s = o[4],
                    l = o[8],
                    c = o[1],
                    u = o[5],
                    h = o[9],
                    d = o[2],
                    p = o[6],
                    f = o[10];
                if (Math.abs(s - c) < .01 && Math.abs(l - d) < .01 && Math.abs(h - p) < .01) {
                    if (Math.abs(s + c) < .1 && Math.abs(l + d) < .1 && Math.abs(h + p) < .1 && Math.abs(a + u + f - 3) < .1) return this.set(1, 0, 0, 0), this;
                    e = Math.PI;
                    var m = (a + 1) / 2,
                        g = (u + 1) / 2,
                        v = (f + 1) / 2,
                        y = (s + c) / 4,
                        _ = (l + d) / 4,
                        x = (h + p) / 4;
                    return m > g && m > v ? m < .01 ? (i = 0, n = .707106781, r = .707106781) : (n = y / (i = Math.sqrt(m)), r = _ / i) : g > v ? g < .01 ? (i = .707106781, n = 0, r = .707106781) : (i = y / (n = Math.sqrt(g)), r = x / n) : v < .01 ? (i = .707106781, n = .707106781, r = 0) : (i = _ / (r = Math.sqrt(v)), n = x / r), this.set(i, n, r, e), this
                }
                var b = Math.sqrt((p - h) * (p - h) + (l - d) * (l - d) + (c - s) * (c - s));
                return Math.abs(b) < .001 && (b = 1), this.x = (p - h) / b, this.y = (l - d) / b, this.z = (c - s) / b, this.w = Math.acos((a + u + f - 1) / 2), this
            },
            min: function(t) {
                return this.x = Math.min(this.x, t.x), this.y = Math.min(this.y, t.y), this.z = Math.min(this.z, t.z), this.w = Math.min(this.w, t.w), this
            },
            max: function(t) {
                return this.x = Math.max(this.x, t.x), this.y = Math.max(this.y, t.y), this.z = Math.max(this.z, t.z), this.w = Math.max(this.w, t.w), this
            },
            clamp: function(t, e) {
                return this.x = Math.max(t.x, Math.min(e.x, this.x)), this.y = Math.max(t.y, Math.min(e.y, this.y)), this.z = Math.max(t.z, Math.min(e.z, this.z)), this.w = Math.max(t.w, Math.min(e.w, this.w)), this
            },
            clampScalar: function() {
                var t, e;
                return function(i, n) {
                    return void 0 === t && (t = new l, e = new l), t.set(i, i, i, i), e.set(n, n, n, n), this.clamp(t, e)
                }
            }(),
            clampLength: function(t, e) {
                var i = this.length();
                return this.divideScalar(i || 1).multiplyScalar(Math.max(t, Math.min(e, i)))
            },
            floor: function() {
                return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this.w = Math.floor(this.w), this
            },
            ceil: function() {
                return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this.w = Math.ceil(this.w), this
            },
            round: function() {
                return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this.w = Math.round(this.w), this
            },
            roundToZero: function() {
                return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w), this
            },
            negate: function() {
                return this.x = -this.x, this.y = -this.y, this.z = -this.z, this.w = -this.w, this
            },
            dot: function(t) {
                return this.x * t.x + this.y * t.y + this.z * t.z + this.w * t.w
            },
            lengthSq: function() {
                return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
            },
            length: function() {
                return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w)
            },
            manhattanLength: function() {
                return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w)
            },
            normalize: function() {
                return this.divideScalar(this.length() || 1)
            },
            setLength: function(t) {
                return this.normalize().multiplyScalar(t)
            },
            lerp: function(t, e) {
                return this.x += (t.x - this.x) * e, this.y += (t.y - this.y) * e, this.z += (t.z - this.z) * e, this.w += (t.w - this.w) * e, this
            },
            lerpVectors: function(t, e, i) {
                return this.subVectors(e, t).multiplyScalar(i).add(t)
            },
            equals: function(t) {
                return t.x === this.x && t.y === this.y && t.z === this.z && t.w === this.w
            },
            fromArray: function(t, e) {
                return void 0 === e && (e = 0), this.x = t[e], this.y = t[e + 1], this.z = t[e + 2], this.w = t[e + 3], this
            },
            toArray: function(t, e) {
                return void 0 === t && (t = []), void 0 === e && (e = 0), t[e] = this.x, t[e + 1] = this.y, t[e + 2] = this.z, t[e + 3] = this.w, t
            },
            fromBufferAttribute: function(t, e, i) {
                return void 0 !== i && console.warn("THREE.Vector4: offset has been removed from .fromBufferAttribute()."), this.x = t.getX(e), this.y = t.getY(e), this.z = t.getZ(e), this.w = t.getW(e), this
            }
        }), Object.assign(c.prototype, e.prototype, {
            isWebGLRenderTarget: !0,
            setSize: function(t, e) {
                this.width === t && this.height === e || (this.width = t, this.height = e, this.dispose()), this.viewport.set(0, 0, t, e), this.scissor.set(0, 0, t, e)
            },
            clone: function() {
                return (new this.constructor).copy(this)
            },
            copy: function(t) {
                return this.width = t.width, this.height = t.height, this.viewport.copy(t.viewport), this.texture = t.texture.clone(), this.depthBuffer = t.depthBuffer, this.stencilBuffer = t.stencilBuffer, this.depthTexture = t.depthTexture, this
            },
            dispose: function() {
                this.dispatchEvent({
                    type: "dispose"
                })
            }
        }), u.prototype = Object.create(c.prototype), u.prototype.constructor = u, u.prototype.isWebGLRenderTargetCube = !0, h.prototype = Object.create(s.prototype), h.prototype.constructor = h, h.prototype.isDataTexture = !0, (d.prototype = Object.create(s.prototype)).constructor = d, d.prototype.isCubeTexture = !0, Object.defineProperty(d.prototype, "images", {
            get: function() {
                return this.image
            },
            set: function(t) {
                this.image = t
            }
        });
        var Va = new s,
            Wa = new d,
            Xa = [],
            qa = [],
            Ya = new Float32Array(16),
            Qa = new Float32Array(9);
        G.prototype.setValue = function(t, e) {
            for (var i = this.seq, n = 0, r = i.length; n !== r; ++n) {
                var o = i[n];
                o.setValue(t, e[o.id])
            }
        };
        var Za = /([\w\d_]+)(\])?(\[|\.)?/g;
        X.prototype.setValue = function(t, e, i) {
            var n = this.map[e];
            void 0 !== n && n.setValue(t, i, this.renderer)
        }, X.prototype.setOptional = function(t, e, i) {
            var n = e[i];
            void 0 !== n && this.setValue(t, i, n)
        }, X.upload = function(t, e, i, n) {
            for (var r = 0, o = e.length; r !== o; ++r) {
                var a = e[r],
                    s = i[a.id];
                !1 !== s.needsUpdate && a.setValue(t, s.value, n)
            }
        }, X.seqWithValue = function(t, e) {
            for (var i = [], n = 0, r = t.length; n !== r; ++n) {
                var o = t[n];
                o.id in e && i.push(o)
            }
            return i
        };
        var Ja = {
            aliceblue: 15792383,
            antiquewhite: 16444375,
            aqua: 65535,
            aquamarine: 8388564,
            azure: 15794175,
            beige: 16119260,
            bisque: 16770244,
            black: 0,
            blanchedalmond: 16772045,
            blue: 255,
            blueviolet: 9055202,
            brown: 10824234,
            burlywood: 14596231,
            cadetblue: 6266528,
            chartreuse: 8388352,
            chocolate: 13789470,
            coral: 16744272,
            cornflowerblue: 6591981,
            cornsilk: 16775388,
            crimson: 14423100,
            cyan: 65535,
            darkblue: 139,
            darkcyan: 35723,
            darkgoldenrod: 12092939,
            darkgray: 11119017,
            darkgreen: 25600,
            darkgrey: 11119017,
            darkkhaki: 12433259,
            darkmagenta: 9109643,
            darkolivegreen: 5597999,
            darkorange: 16747520,
            darkorchid: 10040012,
            darkred: 9109504,
            darksalmon: 15308410,
            darkseagreen: 9419919,
            darkslateblue: 4734347,
            darkslategray: 3100495,
            darkslategrey: 3100495,
            darkturquoise: 52945,
            darkviolet: 9699539,
            deeppink: 16716947,
            deepskyblue: 49151,
            dimgray: 6908265,
            dimgrey: 6908265,
            dodgerblue: 2003199,
            firebrick: 11674146,
            floralwhite: 16775920,
            forestgreen: 2263842,
            fuchsia: 16711935,
            gainsboro: 14474460,
            ghostwhite: 16316671,
            gold: 16766720,
            goldenrod: 14329120,
            gray: 8421504,
            green: 32768,
            greenyellow: 11403055,
            grey: 8421504,
            honeydew: 15794160,
            hotpink: 16738740,
            indianred: 13458524,
            indigo: 4915330,
            ivory: 16777200,
            khaki: 15787660,
            lavender: 15132410,
            lavenderblush: 16773365,
            lawngreen: 8190976,
            lemonchiffon: 16775885,
            lightblue: 11393254,
            lightcoral: 15761536,
            lightcyan: 14745599,
            lightgoldenrodyellow: 16448210,
            lightgray: 13882323,
            lightgreen: 9498256,
            lightgrey: 13882323,
            lightpink: 16758465,
            lightsalmon: 16752762,
            lightseagreen: 2142890,
            lightskyblue: 8900346,
            lightslategray: 7833753,
            lightslategrey: 7833753,
            lightsteelblue: 11584734,
            lightyellow: 16777184,
            lime: 65280,
            limegreen: 3329330,
            linen: 16445670,
            magenta: 16711935,
            maroon: 8388608,
            mediumaquamarine: 6737322,
            mediumblue: 205,
            mediumorchid: 12211667,
            mediumpurple: 9662683,
            mediumseagreen: 3978097,
            mediumslateblue: 8087790,
            mediumspringgreen: 64154,
            mediumturquoise: 4772300,
            mediumvioletred: 13047173,
            midnightblue: 1644912,
            mintcream: 16121850,
            mistyrose: 16770273,
            moccasin: 16770229,
            navajowhite: 16768685,
            navy: 128,
            oldlace: 16643558,
            olive: 8421376,
            olivedrab: 7048739,
            orange: 16753920,
            orangered: 16729344,
            orchid: 14315734,
            palegoldenrod: 15657130,
            palegreen: 10025880,
            paleturquoise: 11529966,
            palevioletred: 14381203,
            papayawhip: 16773077,
            peachpuff: 16767673,
            peru: 13468991,
            pink: 16761035,
            plum: 14524637,
            powderblue: 11591910,
            purple: 8388736,
            rebeccapurple: 6697881,
            red: 16711680,
            rosybrown: 12357519,
            royalblue: 4286945,
            saddlebrown: 9127187,
            salmon: 16416882,
            sandybrown: 16032864,
            seagreen: 3050327,
            seashell: 16774638,
            sienna: 10506797,
            silver: 12632256,
            skyblue: 8900331,
            slateblue: 6970061,
            slategray: 7372944,
            slategrey: 7372944,
            snow: 16775930,
            springgreen: 65407,
            steelblue: 4620980,
            tan: 13808780,
            teal: 32896,
            thistle: 14204888,
            tomato: 16737095,
            turquoise: 4251856,
            violet: 15631086,
            wheat: 16113331,
            white: 16777215,
            whitesmoke: 16119285,
            yellow: 16776960,
            yellowgreen: 10145074
        };
        Object.assign(q.prototype, {
            isColor: !0,
            r: 1,
            g: 1,
            b: 1,
            set: function(t) {
                return t && t.isColor ? this.copy(t) : "number" == typeof t ? this.setHex(t) : "string" == typeof t && this.setStyle(t), this
            },
            setScalar: function(t) {
                return this.r = t, this.g = t, this.b = t, this
            },
            setHex: function(t) {
                return t = Math.floor(t), this.r = (t >> 16 & 255) / 255, this.g = (t >> 8 & 255) / 255, this.b = (255 & t) / 255, this
            },
            setRGB: function(t, e, i) {
                return this.r = t, this.g = e, this.b = i, this
            },
            setHSL: function() {
                function t(t, e, i) {
                    return i < 0 && (i += 1), i > 1 && (i -= 1), i < 1 / 6 ? t + 6 * (e - t) * i : i < .5 ? e : i < 2 / 3 ? t + 6 * (e - t) * (2 / 3 - i) : t
                }
                return function(e, i, n) {
                    if (e = Ha.euclideanModulo(e, 1), i = Ha.clamp(i, 0, 1), n = Ha.clamp(n, 0, 1), 0 === i) this.r = this.g = this.b = n;
                    else {
                        var r = n <= .5 ? n * (1 + i) : n + i - n * i,
                            o = 2 * n - r;
                        this.r = t(o, r, e + 1 / 3), this.g = t(o, r, e), this.b = t(o, r, e - 1 / 3)
                    }
                    return this
                }
            }(),
            setStyle: function(t) {
                function e(e) {
                    void 0 !== e && parseFloat(e) < 1 && console.warn("THREE.Color: Alpha component of " + t + " will be ignored.")
                }
                var i;
                if (i = /^((?:rgb|hsl)a?)\(\s*([^\)]*)\)/.exec(t)) {
                    var n, r = i[1],
                        o = i[2];
                    switch (r) {
                        case "rgb":
                        case "rgba":
                            if (n = /^(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(o)) return this.r = Math.min(255, parseInt(n[1], 10)) / 255, this.g = Math.min(255, parseInt(n[2], 10)) / 255, this.b = Math.min(255, parseInt(n[3], 10)) / 255, e(n[5]), this;
                            if (n = /^(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(o)) return this.r = Math.min(100, parseInt(n[1], 10)) / 100, this.g = Math.min(100, parseInt(n[2], 10)) / 100, this.b = Math.min(100, parseInt(n[3], 10)) / 100, e(n[5]), this;
                            break;
                        case "hsl":
                        case "hsla":
                            if (n = /^([0-9]*\.?[0-9]+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(o)) {
                                var a = parseFloat(n[1]) / 360,
                                    s = parseInt(n[2], 10) / 100,
                                    l = parseInt(n[3], 10) / 100;
                                return e(n[5]), this.setHSL(a, s, l)
                            }
                    }
                } else if (i = /^\#([A-Fa-f0-9]+)$/.exec(t)) {
                    var c = (u = i[1]).length;
                    if (3 === c) return this.r = parseInt(u.charAt(0) + u.charAt(0), 16) / 255, this.g = parseInt(u.charAt(1) + u.charAt(1), 16) / 255, this.b = parseInt(u.charAt(2) + u.charAt(2), 16) / 255, this;
                    if (6 === c) return this.r = parseInt(u.charAt(0) + u.charAt(1), 16) / 255, this.g = parseInt(u.charAt(2) + u.charAt(3), 16) / 255, this.b = parseInt(u.charAt(4) + u.charAt(5), 16) / 255, this
                }
                if (t && t.length > 0) {
                    var u = Ja[t];
                    void 0 !== u ? this.setHex(u) : console.warn("THREE.Color: Unknown color " + t)
                }
                return this
            },
            clone: function() {
                return new this.constructor(this.r, this.g, this.b)
            },
            copy: function(t) {
                return this.r = t.r, this.g = t.g, this.b = t.b, this
            },
            copyGammaToLinear: function(t, e) {
                return void 0 === e && (e = 2), this.r = Math.pow(t.r, e), this.g = Math.pow(t.g, e), this.b = Math.pow(t.b, e), this
            },
            copyLinearToGamma: function(t, e) {
                void 0 === e && (e = 2);
                var i = e > 0 ? 1 / e : 1;
                return this.r = Math.pow(t.r, i), this.g = Math.pow(t.g, i), this.b = Math.pow(t.b, i), this
            },
            convertGammaToLinear: function() {
                var t = this.r,
                    e = this.g,
                    i = this.b;
                return this.r = t * t, this.g = e * e, this.b = i * i, this
            },
            convertLinearToGamma: function() {
                return this.r = Math.sqrt(this.r), this.g = Math.sqrt(this.g), this.b = Math.sqrt(this.b), this
            },
            getHex: function() {
                return 255 * this.r << 16 ^ 255 * this.g << 8 ^ 255 * this.b << 0
            },
            getHexString: function() {
                return ("000000" + this.getHex().toString(16)).slice(-6)
            },
            getHSL: function(t) {
                var e, i, n = t || {
                        h: 0,
                        s: 0,
                        l: 0
                    },
                    r = this.r,
                    o = this.g,
                    a = this.b,
                    s = Math.max(r, o, a),
                    l = Math.min(r, o, a),
                    c = (l + s) / 2;
                if (l === s) e = 0, i = 0;
                else {
                    var u = s - l;
                    switch (i = c <= .5 ? u / (s + l) : u / (2 - s - l), s) {
                        case r:
                            e = (o - a) / u + (o < a ? 6 : 0);
                            break;
                        case o:
                            e = (a - r) / u + 2;
                            break;
                        case a:
                            e = (r - o) / u + 4
                    }
                    e /= 6
                }
                return n.h = e, n.s = i, n.l = c, n
            },
            getStyle: function() {
                return "rgb(" + (255 * this.r | 0) + "," + (255 * this.g | 0) + "," + (255 * this.b | 0) + ")"
            },
            offsetHSL: function(t, e, i) {
                var n = this.getHSL();
                return n.h += t, n.s += e, n.l += i, this.setHSL(n.h, n.s, n.l), this
            },
            add: function(t) {
                return this.r += t.r, this.g += t.g, this.b += t.b, this
            },
            addColors: function(t, e) {
                return this.r = t.r + e.r, this.g = t.g + e.g, this.b = t.b + e.b, this
            },
            addScalar: function(t) {
                return this.r += t, this.g += t, this.b += t, this
            },
            sub: function(t) {
                return this.r = Math.max(0, this.r - t.r), this.g = Math.max(0, this.g - t.g), this.b = Math.max(0, this.b - t.b), this
            },
            multiply: function(t) {
                return this.r *= t.r, this.g *= t.g, this.b *= t.b, this
            },
            multiplyScalar: function(t) {
                return this.r *= t, this.g *= t, this.b *= t, this
            },
            lerp: function(t, e) {
                return this.r += (t.r - this.r) * e, this.g += (t.g - this.g) * e, this.b += (t.b - this.b) * e, this
            },
            equals: function(t) {
                return t.r === this.r && t.g === this.g && t.b === this.b
            },
            fromArray: function(t, e) {
                return void 0 === e && (e = 0), this.r = t[e], this.g = t[e + 1], this.b = t[e + 2], this
            },
            toArray: function(t, e) {
                return void 0 === t && (t = []), void 0 === e && (e = 0), t[e] = this.r, t[e + 1] = this.g, t[e + 2] = this.b, t
            },
            toJSON: function() {
                return this.getHex()
            }
        });
        var $a = {
                common: {
                    diffuse: {
                        value: new q(15658734)
                    },
                    opacity: {
                        value: 1
                    },
                    map: {
                        value: null
                    },
                    uvTransform: {
                        value: new a
                    },
                    alphaMap: {
                        value: null
                    }
                },
                specularmap: {
                    specularMap: {
                        value: null
                    }
                },
                envmap: {
                    envMap: {
                        value: null
                    },
                    flipEnvMap: {
                        value: -1
                    },
                    reflectivity: {
                        value: 1
                    },
                    refractionRatio: {
                        value: .98
                    }
                },
                aomap: {
                    aoMap: {
                        value: null
                    },
                    aoMapIntensity: {
                        value: 1
                    }
                },
                lightmap: {
                    lightMap: {
                        value: null
                    },
                    lightMapIntensity: {
                        value: 1
                    }
                },
                emissivemap: {
                    emissiveMap: {
                        value: null
                    }
                },
                bumpmap: {
                    bumpMap: {
                        value: null
                    },
                    bumpScale: {
                        value: 1
                    }
                },
                normalmap: {
                    normalMap: {
                        value: null
                    },
                    normalScale: {
                        value: new i(1, 1)
                    }
                },
                displacementmap: {
                    displacementMap: {
                        value: null
                    },
                    displacementScale: {
                        value: 1
                    },
                    displacementBias: {
                        value: 0
                    }
                },
                roughnessmap: {
                    roughnessMap: {
                        value: null
                    }
                },
                metalnessmap: {
                    metalnessMap: {
                        value: null
                    }
                },
                gradientmap: {
                    gradientMap: {
                        value: null
                    }
                },
                fog: {
                    fogDensity: {
                        value: 25e-5
                    },
                    fogNear: {
                        value: 1
                    },
                    fogFar: {
                        value: 2e3
                    },
                    fogColor: {
                        value: new q(16777215)
                    }
                },
                lights: {
                    ambientLightColor: {
                        value: []
                    },
                    directionalLights: {
                        value: [],
                        properties: {
                            direction: {},
                            color: {},
                            shadow: {},
                            shadowBias: {},
                            shadowRadius: {},
                            shadowMapSize: {}
                        }
                    },
                    directionalShadowMap: {
                        value: []
                    },
                    directionalShadowMatrix: {
                        value: []
                    },
                    spotLights: {
                        value: [],
                        properties: {
                            color: {},
                            position: {},
                            direction: {},
                            distance: {},
                            coneCos: {},
                            penumbraCos: {},
                            decay: {},
                            shadow: {},
                            shadowBias: {},
                            shadowRadius: {},
                            shadowMapSize: {}
                        }
                    },
                    spotShadowMap: {
                        value: []
                    },
                    spotShadowMatrix: {
                        value: []
                    },
                    pointLights: {
                        value: [],
                        properties: {
                            color: {},
                            position: {},
                            decay: {},
                            distance: {},
                            shadow: {},
                            shadowBias: {},
                            shadowRadius: {},
                            shadowMapSize: {},
                            shadowCameraNear: {},
                            shadowCameraFar: {}
                        }
                    },
                    pointShadowMap: {
                        value: []
                    },
                    pointShadowMatrix: {
                        value: []
                    },
                    hemisphereLights: {
                        value: [],
                        properties: {
                            direction: {},
                            skyColor: {},
                            groundColor: {}
                        }
                    },
                    rectAreaLights: {
                        value: [],
                        properties: {
                            color: {},
                            position: {},
                            width: {},
                            height: {}
                        }
                    }
                },
                points: {
                    diffuse: {
                        value: new q(15658734)
                    },
                    opacity: {
                        value: 1
                    },
                    size: {
                        value: 1
                    },
                    scale: {
                        value: 1
                    },
                    map: {
                        value: null
                    },
                    uvTransform: {
                        value: new a
                    }
                }
            },
            Ka = {
                merge: function(t) {
                    for (var e = {}, i = 0; i < t.length; i++) {
                        var n = this.clone(t[i]);
                        for (var r in n) e[r] = n[r]
                    }
                    return e
                },
                clone: function(t) {
                    var e = {};
                    for (var i in t) {
                        e[i] = {};
                        for (var n in t[i]) {
                            var r = t[i][n];
                            r && (r.isColor || r.isMatrix3 || r.isMatrix4 || r.isVector2 || r.isVector3 || r.isVector4 || r.isTexture) ? e[i][n] = r.clone() : Array.isArray(r) ? e[i][n] = r.slice() : e[i][n] = r
                        }
                    }
                    return e
                }
            },
            ts = {
                alphamap_fragment: "#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif\n",
                alphamap_pars_fragment: "#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif\n",
                alphatest_fragment: "#ifdef ALPHATEST\n\tif ( diffuseColor.a < ALPHATEST ) discard;\n#endif\n",
                aomap_fragment: "#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( PHYSICAL )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\n\t#endif\n#endif\n",
                aomap_pars_fragment: "#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif",
                begin_vertex: "\nvec3 transformed = vec3( position );\n",
                beginnormal_vertex: "\nvec3 objectNormal = vec3( normal );\n",
                bsdfs: "float punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n\tif( decayExponent > 0.0 ) {\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\t\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\t\tfloat maxDistanceCutoffFactor = pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t\treturn distanceFalloff * maxDistanceCutoffFactor;\n#else\n\t\treturn pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n#endif\n\t}\n\treturn 1.0;\n}\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\n\treturn ( 1.0 - specularColor ) * fresnel + specularColor;\n}\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\tfloat gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\treturn 1.0 / ( gl * gv );\n}\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNL = saturate( dot( geometry.normal, incidentLight.direction ) );\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( G * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE  = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS  = 0.5 / LUT_SIZE;\n\tfloat theta = acos( dot( N, V ) );\n\tvec2 uv = vec2(\n\t\tsqrt( saturate( roughness ) ),\n\t\tsaturate( theta / ( 0.5 * PI ) ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.86267 + (0.49788 + 0.01436 * y ) * y;\n\tfloat b = 3.45068 + (4.18814 + y) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = (x > 0.0) ? v : 0.5 * inversesqrt( 1.0 - x * x ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tvec3 result = vec3( LTC_ClippedSphereFormFactor( vectorFormFactor ) );\n\treturn result;\n}\nvec3 BRDF_Specular_GGX_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\tvec2 AB = vec2( -1.04, 1.04 ) * a004 + r.zw;\n\treturn specularColor * AB.x + AB.y;\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\n\treturn ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\n}\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\n\treturn sqrt( 2.0 / ( blinnExponent + 2.0 ) );\n}\n",
                bumpmap_pars_fragment: "#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\n\t\tvec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n\t\tvec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 );\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif\n",
                clipping_planes_fragment: "#if NUM_CLIPPING_PLANES > 0\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; ++ i ) {\n\t\tvec4 plane = clippingPlanes[ i ];\n\t\tif ( dot( vViewPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t\t\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; ++ i ) {\n\t\t\tvec4 plane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vViewPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\tif ( clipped ) discard;\n\t\n\t#endif\n#endif\n",
                clipping_planes_pars_fragment: "#if NUM_CLIPPING_PLANES > 0\n\t#if ! defined( PHYSICAL ) && ! defined( PHONG )\n\t\tvarying vec3 vViewPosition;\n\t#endif\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif\n",
                clipping_planes_pars_vertex: "#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG )\n\tvarying vec3 vViewPosition;\n#endif\n",
                clipping_planes_vertex: "#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n",
                color_fragment: "#ifdef USE_COLOR\n\tdiffuseColor.rgb *= vColor;\n#endif",
                color_pars_fragment: "#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif\n",
                color_pars_vertex: "#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif",
                color_vertex: "#ifdef USE_COLOR\n\tvColor.xyz = color.xyz;\n#endif",
                common: "#define PI 3.14159265359\n#define PI2 6.28318530718\n#define PI_HALF 1.5707963267949\n#define RECIPROCAL_PI 0.31830988618\n#define RECIPROCAL_PI2 0.15915494\n#define LOG2 1.442695\n#define EPSILON 1e-6\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#define whiteCompliment(a) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract(sin(sn) * c);\n}\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\tfloat distance = dot( planeNormal, point - pointOnPlane );\n\treturn - distance * planeNormal + point;\n}\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn sign( dot( point - pointOnPlane, planeNormal ) );\n}\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat linearToRelativeLuminance( const in vec3 color ) {\n\tvec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n\treturn dot( weights, color.rgb );\n}\n",
                cube_uv_reflection_fragment: "#ifdef ENVMAP_TYPE_CUBE_UV\n#define cubeUV_textureSize (1024.0)\nint getFaceFromDirection(vec3 direction) {\n\tvec3 absDirection = abs(direction);\n\tint face = -1;\n\tif( absDirection.x > absDirection.z ) {\n\t\tif(absDirection.x > absDirection.y )\n\t\t\tface = direction.x > 0.0 ? 0 : 3;\n\t\telse\n\t\t\tface = direction.y > 0.0 ? 1 : 4;\n\t}\n\telse {\n\t\tif(absDirection.z > absDirection.y )\n\t\t\tface = direction.z > 0.0 ? 2 : 5;\n\t\telse\n\t\t\tface = direction.y > 0.0 ? 1 : 4;\n\t}\n\treturn face;\n}\n#define cubeUV_maxLods1  (log2(cubeUV_textureSize*0.25) - 1.0)\n#define cubeUV_rangeClamp (exp2((6.0 - 1.0) * 2.0))\nvec2 MipLevelInfo( vec3 vec, float roughnessLevel, float roughness ) {\n\tfloat scale = exp2(cubeUV_maxLods1 - roughnessLevel);\n\tfloat dxRoughness = dFdx(roughness);\n\tfloat dyRoughness = dFdy(roughness);\n\tvec3 dx = dFdx( vec * scale * dxRoughness );\n\tvec3 dy = dFdy( vec * scale * dyRoughness );\n\tfloat d = max( dot( dx, dx ), dot( dy, dy ) );\n\td = clamp(d, 1.0, cubeUV_rangeClamp);\n\tfloat mipLevel = 0.5 * log2(d);\n\treturn vec2(floor(mipLevel), fract(mipLevel));\n}\n#define cubeUV_maxLods2 (log2(cubeUV_textureSize*0.25) - 2.0)\n#define cubeUV_rcpTextureSize (1.0 / cubeUV_textureSize)\nvec2 getCubeUV(vec3 direction, float roughnessLevel, float mipLevel) {\n\tmipLevel = roughnessLevel > cubeUV_maxLods2 - 3.0 ? 0.0 : mipLevel;\n\tfloat a = 16.0 * cubeUV_rcpTextureSize;\n\tvec2 exp2_packed = exp2( vec2( roughnessLevel, mipLevel ) );\n\tvec2 rcp_exp2_packed = vec2( 1.0 ) / exp2_packed;\n\tfloat powScale = exp2_packed.x * exp2_packed.y;\n\tfloat scale = rcp_exp2_packed.x * rcp_exp2_packed.y * 0.25;\n\tfloat mipOffset = 0.75*(1.0 - rcp_exp2_packed.y) * rcp_exp2_packed.x;\n\tbool bRes = mipLevel == 0.0;\n\tscale =  bRes && (scale < a) ? a : scale;\n\tvec3 r;\n\tvec2 offset;\n\tint face = getFaceFromDirection(direction);\n\tfloat rcpPowScale = 1.0 / powScale;\n\tif( face == 0) {\n\t\tr = vec3(direction.x, -direction.z, direction.y);\n\t\toffset = vec2(0.0+mipOffset,0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 1) {\n\t\tr = vec3(direction.y, direction.x, direction.z);\n\t\toffset = vec2(scale+mipOffset, 0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 2) {\n\t\tr = vec3(direction.z, direction.x, direction.y);\n\t\toffset = vec2(2.0*scale+mipOffset, 0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 3) {\n\t\tr = vec3(direction.x, direction.z, direction.y);\n\t\toffset = vec2(0.0+mipOffset,0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\telse if( face == 4) {\n\t\tr = vec3(direction.y, direction.x, -direction.z);\n\t\toffset = vec2(scale+mipOffset, 0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\telse {\n\t\tr = vec3(direction.z, -direction.x, direction.y);\n\t\toffset = vec2(2.0*scale+mipOffset, 0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\tr = normalize(r);\n\tfloat texelOffset = 0.5 * cubeUV_rcpTextureSize;\n\tvec2 s = ( r.yz / abs( r.x ) + vec2( 1.0 ) ) * 0.5;\n\tvec2 base = offset + vec2( texelOffset );\n\treturn base + s * ( scale - 2.0 * texelOffset );\n}\n#define cubeUV_maxLods3 (log2(cubeUV_textureSize*0.25) - 3.0)\nvec4 textureCubeUV(vec3 reflectedDirection, float roughness ) {\n\tfloat roughnessVal = roughness* cubeUV_maxLods3;\n\tfloat r1 = floor(roughnessVal);\n\tfloat r2 = r1 + 1.0;\n\tfloat t = fract(roughnessVal);\n\tvec2 mipInfo = MipLevelInfo(reflectedDirection, r1, roughness);\n\tfloat s = mipInfo.y;\n\tfloat level0 = mipInfo.x;\n\tfloat level1 = level0 + 1.0;\n\tlevel1 = level1 > 5.0 ? 5.0 : level1;\n\tlevel0 += min( floor( s + 0.5 ), 5.0 );\n\tvec2 uv_10 = getCubeUV(reflectedDirection, r1, level0);\n\tvec4 color10 = envMapTexelToLinear(texture2D(envMap, uv_10));\n\tvec2 uv_20 = getCubeUV(reflectedDirection, r2, level0);\n\tvec4 color20 = envMapTexelToLinear(texture2D(envMap, uv_20));\n\tvec4 result = mix(color10, color20, t);\n\treturn vec4(result.rgb, 1.0);\n}\n#endif\n",
                defaultnormal_vertex: "vec3 transformedNormal = normalMatrix * objectNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n",
                displacementmap_pars_vertex: "#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif\n",
                displacementmap_vertex: "#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, uv ).x * displacementScale + displacementBias );\n#endif\n",
                emissivemap_fragment: "#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif\n",
                emissivemap_pars_fragment: "#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif\n",
                encodings_fragment: "  gl_FragColor = linearToOutputTexel( gl_FragColor );\n",
                encodings_pars_fragment: "\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.xyz, vec3( gammaFactor ) ), value.w );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.xyz, vec3( 1.0 / gammaFactor ) ), value.w );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.w );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.w );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n\treturn vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n\tfloat maxComponent = max( max( value.r, value.g ), value.b );\n\tfloat fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n\treturn vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.xyz * value.w * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.x, max( value.g, value.b ) );\n\tfloat M      = clamp( maxRGB / maxRange, 0.0, 1.0 );\n\tM            = ceil( M * 255.0 ) / 255.0;\n\treturn vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.x, max( value.g, value.b ) );\n\tfloat D      = max( maxRange / maxRGB, 1.0 );\n\tD            = min( floor( D ) / 255.0, 1.0 );\n\treturn vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value )  {\n\tvec3 Xp_Y_XYZp = value.rgb * cLogLuvM;\n\tXp_Y_XYZp = max(Xp_Y_XYZp, vec3(1e-6, 1e-6, 1e-6));\n\tvec4 vResult;\n\tvResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n\tfloat Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n\tvResult.w = fract(Le);\n\tvResult.z = (Le - (floor(vResult.w*255.0))/255.0)/255.0;\n\treturn vResult;\n}\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n\tfloat Le = value.z * 255.0 + value.w;\n\tvec3 Xp_Y_XYZp;\n\tXp_Y_XYZp.y = exp2((Le - 127.0) / 2.0);\n\tXp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n\tXp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n\tvec3 vRGB = Xp_Y_XYZp.rgb * cLogLuvInverseM;\n\treturn vec4( max(vRGB, 0.0), 1.0 );\n}\n",
                envmap_fragment: "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\tvec2 sampleUV;\n\t\treflectVec = normalize( reflectVec );\n\t\tsampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\t\tsampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\t\tvec4 envColor = texture2D( envMap, sampleUV );\n\t#elif defined( ENVMAP_TYPE_SPHERE )\n\t\treflectVec = normalize( reflectVec );\n\t\tvec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0, 0.0, 1.0 ) );\n\t\tvec4 envColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5 );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\tenvColor = envMapTexelToLinear( envColor );\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif\n",
                envmap_pars_fragment: "#if defined( USE_ENVMAP ) || defined( PHYSICAL )\n\tuniform float reflectivity;\n\tuniform float envMapIntensity;\n#endif\n#ifdef USE_ENVMAP\n\t#if ! defined( PHYSICAL ) && ( defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) )\n\t\tvarying vec3 vWorldPosition;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\tuniform float flipEnvMap;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( PHYSICAL )\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif\n",
                envmap_pars_vertex: "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif\n",
                envmap_vertex: "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif\n",
                fog_vertex: "\n#ifdef USE_FOG\nfogDepth = -mvPosition.z;\n#endif",
                fog_pars_vertex: "#ifdef USE_FOG\n  varying float fogDepth;\n#endif\n",
                fog_fragment: "#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = whiteCompliment( exp2( - fogDensity * fogDensity * fogDepth * fogDepth * LOG2 ) );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, fogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif\n",
                fog_pars_fragment: "#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float fogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif\n",
                gradientmap_pars_fragment: "#ifdef TOON\n\tuniform sampler2D gradientMap;\n\tvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\t\tfloat dotNL = dot( normal, lightDirection );\n\t\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t\t#ifdef USE_GRADIENTMAP\n\t\t\treturn texture2D( gradientMap, coord ).rgb;\n\t\t#else\n\t\t\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n\t\t#endif\n\t}\n#endif\n",
                lightmap_fragment: "#ifdef USE_LIGHTMAP\n\treflectedLight.indirectDiffuse += PI * texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n#endif\n",
                lightmap_pars_fragment: "#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif",
                lights_lambert_vertex: "vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\n#if NUM_POINT_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tgetPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tgetSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_DIR_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tgetDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\tvLightFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\n\t\t#endif\n\t}\n#endif\n",
                lights_pars: "uniform vec3 ambientLightColor;\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treturn irradiance;\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tdirectLight.color = directionalLight.color;\n\t\tdirectLight.direction = directionalLight.direction;\n\t\tdirectLight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t\tfloat shadowCameraNear;\n\t\tfloat shadowCameraFar;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tdirectLight.color = pointLight.color;\n\t\tdirectLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\n\t\tdirectLight.visible = ( directLight.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight  ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tfloat angleCos = dot( directLight.direction, spotLight.direction );\n\t\tif ( angleCos > spotLight.coneCos ) {\n\t\t\tfloat spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\t\tdirectLight.color = spotLight.color;\n\t\t\tdirectLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tdirectLight.visible = true;\n\t\t} else {\n\t\t\tdirectLight.color = vec3( 0.0 );\n\t\t\tdirectLight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltcMat;\tuniform sampler2D ltcMag;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n\t\tfloat dotNL = dot( geometry.normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tirradiance *= PI;\n\t\t#endif\n\t\treturn irradiance;\n\t}\n#endif\n#if defined( USE_ENVMAP ) && defined( PHYSICAL )\n\tvec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\n\t\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\tvec4 envMapColor = textureCubeUV( queryVec, 1.0 );\n\t\t#else\n\t\t\tvec4 envMapColor = vec4( 0.0 );\n\t\t#endif\n\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t}\n\tfloat getSpecularMIPLevel( const in float blinnShininessExponent, const in int maxMIPLevel ) {\n\t\tfloat maxMIPLevelScalar = float( maxMIPLevel );\n\t\tfloat desiredMIPLevel = maxMIPLevelScalar + 0.79248 - 0.5 * log2( pow2( blinnShininessExponent ) + 1.0 );\n\t\treturn clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n\t}\n\tvec3 getLightProbeIndirectRadiance( const in GeometricContext geometry, const in float blinnShininessExponent, const in int maxMIPLevel ) {\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( -geometry.viewDir, geometry.normal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( -geometry.viewDir, geometry.normal, refractionRatio );\n\t\t#endif\n\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\tfloat specularMIPLevel = getSpecularMIPLevel( blinnShininessExponent, maxMIPLevel );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\tvec4 envMapColor = textureCubeUV(queryReflectVec, BlinnExponentToGGXRoughness(blinnShininessExponent));\n\t\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\t\tvec2 sampleUV;\n\t\t\tsampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\t\t\tsampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, sampleUV, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, sampleUV, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_SPHERE )\n\t\t\tvec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0,0.0,1.0 ) );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#endif\n\t\treturn envMapColor.rgb * envMapIntensity;\n\t}\n#endif\n",
                lights_phong_fragment: "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;\n",
                lights_phong_pars_fragment: "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct BlinnPhongMaterial {\n\tvec3\tdiffuseColor;\n\tvec3\tspecularColor;\n\tfloat\tspecularShininess;\n\tfloat\tspecularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\t#ifdef TOON\n\t\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\t#else\n\t\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\t\tvec3 irradiance = dotNL * directLight.color;\n\t#endif\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)\n",
                lights_physical_fragment: "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nmaterial.specularRoughness = clamp( roughnessFactor, 0.04, 1.0 );\n#ifdef STANDARD\n\tmaterial.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\n\tmaterial.clearCoat = saturate( clearCoat );\tmaterial.clearCoatRoughness = clamp( clearCoatRoughness, 0.04, 1.0 );\n#endif\n",
                lights_physical_pars_fragment: "struct PhysicalMaterial {\n\tvec3\tdiffuseColor;\n\tfloat\tspecularRoughness;\n\tvec3\tspecularColor;\n\t#ifndef STANDARD\n\t\tfloat clearCoat;\n\t\tfloat clearCoatRoughness;\n\t#endif\n};\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\nfloat clearCoatDHRApprox( const in float roughness, const in float dotNL ) {\n\treturn DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.specularRoughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos - halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos + halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos + halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos - halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tfloat norm = texture2D( ltcMag, uv ).a;\n\t\tvec4 t = texture2D( ltcMat, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3(   1,   0, t.y ),\n\t\t\tvec3(   0, t.z,   0 ),\n\t\t\tvec3( t.w,   0, t.x )\n\t\t);\n\t\treflectedLight.directSpecular += lightColor * material.specularColor * norm * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\t#ifndef STANDARD\n\t\tfloat clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\n\t#else\n\t\tfloat clearCoatDHR = 0.0;\n\t#endif\n\treflectedLight.directSpecular += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry, material.specularColor, material.specularRoughness );\n\treflectedLight.directDiffuse += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\t#ifndef STANDARD\n\t\treflectedLight.directSpecular += irradiance * material.clearCoat * BRDF_Specular_GGX( directLight, geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\n\t#endif\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 clearCoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t#ifndef STANDARD\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\tfloat dotNL = dotNV;\n\t\tfloat clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\n\t#else\n\t\tfloat clearCoatDHR = 0.0;\n\t#endif\n\treflectedLight.indirectSpecular += ( 1.0 - clearCoatDHR ) * radiance * BRDF_Specular_GGX_Environment( geometry, material.specularColor, material.specularRoughness );\n\t#ifndef STANDARD\n\t\treflectedLight.indirectSpecular += clearCoatRadiance * material.clearCoat * BRDF_Specular_GGX_Environment( geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\n\t#endif\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\n#define Material_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.specularRoughness )\n#define Material_ClearCoat_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.clearCoatRoughness )\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}\n",
                lights_template: "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = normalize( vViewPosition );\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointDirectLightIrradiance( pointLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( pointLight.shadow, directLight.visible ) ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotDirectLightIrradiance( spotLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( spotLight.shadow, directLight.visible ) ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( directionalLight.shadow, directLight.visible ) ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\t#ifdef USE_LIGHTMAP\n\t\tvec3 lightMapIrradiance = texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tlightMapIrradiance *= PI;\n\t\t#endif\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t}\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( PHYSICAL ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tirradiance += getLightProbeIndirectIrradiance( geometry, 8 );\n\t#endif\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tvec3 radiance = getLightProbeIndirectRadiance( geometry, Material_BlinnShininessExponent( material ), 8 );\n\t#ifndef STANDARD\n\t\tvec3 clearCoatRadiance = getLightProbeIndirectRadiance( geometry, Material_ClearCoat_BlinnShininessExponent( material ), 8 );\n\t#else\n\t\tvec3 clearCoatRadiance = vec3( 0.0 );\n\t#endif\n\tRE_IndirectSpecular( radiance, clearCoatRadiance, geometry, material, reflectedLight );\n#endif\n",
                logdepthbuf_fragment: "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif",
                logdepthbuf_pars_fragment: "#ifdef USE_LOGDEPTHBUF\n\tuniform float logDepthBufFC;\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t#endif\n#endif\n",
                logdepthbuf_pars_vertex: "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t#endif\n\tuniform float logDepthBufFC;\n#endif",
                logdepthbuf_vertex: "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t#else\n\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\tgl_Position.z *= gl_Position.w;\n\t#endif\n#endif\n",
                map_fragment: "#ifdef USE_MAP\n\tvec4 texelColor = texture2D( map, vUv );\n\ttexelColor = mapTexelToLinear( texelColor );\n\tdiffuseColor *= texelColor;\n#endif\n",
                map_pars_fragment: "#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n",
                map_particle_fragment: "#ifdef USE_MAP\n\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n\tvec4 mapTexel = texture2D( map, uv );\n\tdiffuseColor *= mapTexelToLinear( mapTexel );\n#endif\n",
                map_particle_pars_fragment: "#ifdef USE_MAP\n\tuniform mat3 uvTransform;\n\tuniform sampler2D map;\n#endif\n",
                metalnessmap_fragment: "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif\n",
                metalnessmap_pars_fragment: "#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif",
                morphnormal_vertex: "#ifdef USE_MORPHNORMALS\n\tobjectNormal += ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];\n\tobjectNormal += ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];\n\tobjectNormal += ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];\n\tobjectNormal += ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];\n#endif\n",
                morphtarget_pars_vertex: "#ifdef USE_MORPHTARGETS\n\t#ifndef USE_MORPHNORMALS\n\tuniform float morphTargetInfluences[ 8 ];\n\t#else\n\tuniform float morphTargetInfluences[ 4 ];\n\t#endif\n#endif",
                morphtarget_vertex: "#ifdef USE_MORPHTARGETS\n\ttransformed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];\n\ttransformed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];\n\ttransformed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];\n\ttransformed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];\n\t#ifndef USE_MORPHNORMALS\n\ttransformed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];\n\ttransformed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];\n\ttransformed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];\n\ttransformed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];\n\t#endif\n#endif\n",
                normal_fragment: "#ifdef FLAT_SHADED\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t#endif\n#endif\n#ifdef USE_NORMALMAP\n\tnormal = perturbNormal2Arb( -vViewPosition, normal );\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\n#endif\n",
                normalmap_pars_fragment: "#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {\n\t\tvec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n\t\tvec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n\t\tvec2 st0 = dFdx( vUv.st );\n\t\tvec2 st1 = dFdy( vUv.st );\n\t\tvec3 S = normalize( q0 * st1.t - q1 * st0.t );\n\t\tvec3 T = normalize( -q0 * st1.s + q1 * st0.s );\n\t\tvec3 N = normalize( surf_norm );\n\t\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t\tmapN.xy = normalScale * mapN.xy;\n\t\tmat3 tsn = mat3( S, T, N );\n\t\treturn normalize( tsn * mapN );\n\t}\n#endif\n",
                packing: "vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}\n",
                premultiplied_alpha_fragment: "#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif\n",
                project_vertex: "vec4 mvPosition = modelViewMatrix * vec4( transformed, 1.0 );\ngl_Position = projectionMatrix * mvPosition;\n",
                dithering_fragment: "#if defined( DITHERING )\n  gl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif\n",
                dithering_pars_fragment: "#if defined( DITHERING )\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif\n",
                roughnessmap_fragment: "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.g;\n#endif\n",
                roughnessmap_pars_fragment: "#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif",
                shadowmap_pars_fragment: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHTS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHTS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\n\t\tconst vec2 offset = vec2( 0.0, 1.0 );\n\t\tvec2 texelSize = vec2( 1.0 ) / size;\n\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\n\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\n\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\n\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\n\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\n\t\tvec2 f = fract( uv * size + 0.5 );\n\t\tfloat a = mix( lb, lt, f.y );\n\t\tfloat b = mix( rb, rt, f.y );\n\t\tfloat c = mix( a, b, f.x );\n\t\treturn c;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tshadow = (\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\tdp += shadowBias;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif\n",
                shadowmap_pars_vertex: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHTS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHTS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\n\t#endif\n#endif\n",
                shadowmap_vertex: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n#endif\n",
                shadowmask_pars_fragment: "float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\tDirectionalLight directionalLight;\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tshadow *= bool( directionalLight.shadow ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\tSpotLight spotLight;\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tshadow *= bool( spotLight.shadow ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\tPointLight pointLight;\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tshadow *= bool( pointLight.shadow ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#endif\n\t#endif\n\treturn shadow;\n}\n",
                skinbase_vertex: "#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif",
                skinning_pars_vertex: "#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\t#ifdef BONE_TEXTURE\n\t\tuniform sampler2D boneTexture;\n\t\tuniform int boneTextureSize;\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tfloat j = i * 4.0;\n\t\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\t\ty = dy * ( y + 0.5 );\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\t\treturn bone;\n\t\t}\n\t#else\n\t\tuniform mat4 boneMatrices[ MAX_BONES ];\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tmat4 bone = boneMatrices[ int(i) ];\n\t\t\treturn bone;\n\t\t}\n\t#endif\n#endif\n",
                skinning_vertex: "#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif\n",
                skinnormal_vertex: "#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n#endif\n",
                specularmap_fragment: "float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif",
                specularmap_pars_fragment: "#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif",
                tonemapping_fragment: "#if defined( TONE_MAPPING )\n  gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif\n",
                tonemapping_pars_fragment: "#ifndef saturate\n\t#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nuniform float toneMappingWhitePoint;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\n#define Uncharted2Helper( x ) max( ( ( x * ( 0.15 * x + 0.10 * 0.50 ) + 0.20 * 0.02 ) / ( x * ( 0.15 * x + 0.50 ) + 0.20 * 0.30 ) ) - 0.02 / 0.30, vec3( 0.0 ) )\nvec3 Uncharted2ToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( Uncharted2Helper( color ) / Uncharted2Helper( vec3( toneMappingWhitePoint ) ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\n",
                uv_pars_fragment: "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvarying vec2 vUv;\n#endif",
                uv_pars_vertex: "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvarying vec2 vUv;\n\tuniform mat3 uvTransform;\n#endif\n",
                uv_vertex: "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif",
                uv2_pars_fragment: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif",
                uv2_pars_vertex: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n#endif",
                uv2_vertex: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = uv2;\n#endif",
                worldpos_vertex: "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP )\n\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\n#endif\n",
                cube_frag: "uniform samplerCube tCube;\nuniform float tFlip;\nuniform float opacity;\nvarying vec3 vWorldPosition;\nvoid main() {\n\tgl_FragColor = textureCube( tCube, vec3( tFlip * vWorldPosition.x, vWorldPosition.yz ) );\n\tgl_FragColor.a *= opacity;\n}\n",
                cube_vert: "varying vec3 vWorldPosition;\n#include <common>\nvoid main() {\n\tvWorldPosition = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}\n",
                depth_frag: "#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( gl_FragCoord.z ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( gl_FragCoord.z );\n\t#endif\n}\n",
                depth_vert: "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n}\n",
                distanceRGBA_frag: "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}\n",
                distanceRGBA_vert: "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}\n",
                equirect_frag: "uniform sampler2D tEquirect;\nvarying vec3 vWorldPosition;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldPosition );\n\tvec2 sampleUV;\n\tsampleUV.y = asin( clamp( direction.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\tsampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;\n\tgl_FragColor = texture2D( tEquirect, sampleUV );\n}\n",
                equirect_vert: "varying vec3 vWorldPosition;\n#include <common>\nvoid main() {\n\tvWorldPosition = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}\n",
                linedashed_frag: "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n",
                linedashed_vert: "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\tvLineDistance = scale * lineDistance;\n\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}\n",
                meshbasic_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\treflectedLight.indirectDiffuse += texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n",
                meshbasic_vert: "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_ENVMAP\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}\n",
                meshlambert_frag: "uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <bsdfs>\n#include <lights_pars>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\treflectedLight.indirectDiffuse = getAmbientLightIrradiance( ambientLightColor );\n\t#include <lightmap_fragment>\n\treflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\t#else\n\t\treflectedLight.directDiffuse = vLightFront;\n\t#endif\n\treflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}\n",
                meshlambert_vert: "#define LAMBERT\nvarying vec3 vLightFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}\n",
                meshphong_frag: "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_template>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}\n",
                meshphong_vert: "#define PHONG\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}\n",
                meshphysical_frag: "#define PHYSICAL\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifndef STANDARD\n\tuniform float clearCoat;\n\tuniform float clearCoatRoughness;\n#endif\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <lights_pars>\n#include <lights_physical_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_template>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}\n",
                meshphysical_vert: "#define PHYSICAL\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}\n",
                normal_frag: "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\nvoid main() {\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n}\n",
                normal_vert: "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}\n",
                points_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n",
                points_vert: "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#ifdef USE_SIZEATTENUATION\n\t\tgl_PointSize = size * ( scale / - mvPosition.z );\n\t#else\n\t\tgl_PointSize = size;\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}\n",
                shadow_frag: "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <fog_fragment>\n}\n",
                shadow_vert: "#include <fog_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}\n"
            },
            es = {
                basic: {
                    uniforms: Ka.merge([$a.common, $a.specularmap, $a.envmap, $a.aomap, $a.lightmap, $a.fog]),
                    vertexShader: ts.meshbasic_vert,
                    fragmentShader: ts.meshbasic_frag
                },
                lambert: {
                    uniforms: Ka.merge([$a.common, $a.specularmap, $a.envmap, $a.aomap, $a.lightmap, $a.emissivemap, $a.fog, $a.lights, {
                        emissive: {
                            value: new q(0)
                        }
                    }]),
                    vertexShader: ts.meshlambert_vert,
                    fragmentShader: ts.meshlambert_frag
                },
                phong: {
                    uniforms: Ka.merge([$a.common, $a.specularmap, $a.envmap, $a.aomap, $a.lightmap, $a.emissivemap, $a.bumpmap, $a.normalmap, $a.displacementmap, $a.gradientmap, $a.fog, $a.lights, {
                        emissive: {
                            value: new q(0)
                        },
                        specular: {
                            value: new q(1118481)
                        },
                        shininess: {
                            value: 30
                        }
                    }]),
                    vertexShader: ts.meshphong_vert,
                    fragmentShader: ts.meshphong_frag
                },
                standard: {
                    uniforms: Ka.merge([$a.common, $a.envmap, $a.aomap, $a.lightmap, $a.emissivemap, $a.bumpmap, $a.normalmap, $a.displacementmap, $a.roughnessmap, $a.metalnessmap, $a.fog, $a.lights, {
                        emissive: {
                            value: new q(0)
                        },
                        roughness: {
                            value: .5
                        },
                        metalness: {
                            value: .5
                        },
                        envMapIntensity: {
                            value: 1
                        }
                    }]),
                    vertexShader: ts.meshphysical_vert,
                    fragmentShader: ts.meshphysical_frag
                },
                points: {
                    uniforms: Ka.merge([$a.points, $a.fog]),
                    vertexShader: ts.points_vert,
                    fragmentShader: ts.points_frag
                },
                dashed: {
                    uniforms: Ka.merge([$a.common, $a.fog, {
                        scale: {
                            value: 1
                        },
                        dashSize: {
                            value: 1
                        },
                        totalSize: {
                            value: 2
                        }
                    }]),
                    vertexShader: ts.linedashed_vert,
                    fragmentShader: ts.linedashed_frag
                },
                depth: {
                    uniforms: Ka.merge([$a.common, $a.displacementmap]),
                    vertexShader: ts.depth_vert,
                    fragmentShader: ts.depth_frag
                },
                normal: {
                    uniforms: Ka.merge([$a.common, $a.bumpmap, $a.normalmap, $a.displacementmap, {
                        opacity: {
                            value: 1
                        }
                    }]),
                    vertexShader: ts.normal_vert,
                    fragmentShader: ts.normal_frag
                },
                cube: {
                    uniforms: {
                        tCube: {
                            value: null
                        },
                        tFlip: {
                            value: -1
                        },
                        opacity: {
                            value: 1
                        }
                    },
                    vertexShader: ts.cube_vert,
                    fragmentShader: ts.cube_frag
                },
                equirect: {
                    uniforms: {
                        tEquirect: {
                            value: null
                        }
                    },
                    vertexShader: ts.equirect_vert,
                    fragmentShader: ts.equirect_frag
                },
                distanceRGBA: {
                    uniforms: Ka.merge([$a.common, $a.displacementmap, {
                        referencePosition: {
                            value: new o
                        },
                        nearDistance: {
                            value: 1
                        },
                        farDistance: {
                            value: 1e3
                        }
                    }]),
                    vertexShader: ts.distanceRGBA_vert,
                    fragmentShader: ts.distanceRGBA_frag
                },
                shadow: {
                    uniforms: Ka.merge([$a.lights, $a.fog, {
                        color: {
                            value: new q(0)
                        },
                        opacity: {
                            value: 1
                        }
                    }]),
                    vertexShader: ts.shadow_vert,
                    fragmentShader: ts.shadow_frag
                }
            };
        es.physical = {
            uniforms: Ka.merge([es.standard.uniforms, {
                clearCoat: {
                    value: 0
                },
                clearCoatRoughness: {
                    value: 0
                }
            }]),
            vertexShader: ts.meshphysical_vert,
            fragmentShader: ts.meshphysical_frag
        }, Object.assign(Y.prototype, {
            set: function(t, e) {
                return this.min.copy(t), this.max.copy(e), this
            },
            setFromPoints: function(t) {
                this.makeEmpty();
                for (var e = 0, i = t.length; e < i; e++) this.expandByPoint(t[e]);
                return this
            },
            setFromCenterAndSize: function() {
                var t = new i;
                return function(e, i) {
                    var n = t.copy(i).multiplyScalar(.5);
                    return this.min.copy(e).sub(n), this.max.copy(e).add(n), this
                }
            }(),
            clone: function() {
                return (new this.constructor).copy(this)
            },
            copy: function(t) {
                return this.min.copy(t.min), this.max.copy(t.max), this
            },
            makeEmpty: function() {
                return this.min.x = this.min.y = 1 / 0, this.max.x = this.max.y = -1 / 0, this
            },
            isEmpty: function() {
                return this.max.x < this.min.x || this.max.y < this.min.y
            },
            getCenter: function(t) {
                var e = t || new i;
                return this.isEmpty() ? e.set(0, 0) : e.addVectors(this.min, this.max).multiplyScalar(.5)
            },
            getSize: function(t) {
                var e = t || new i;
                return this.isEmpty() ? e.set(0, 0) : e.subVectors(this.max, this.min)
            },
            expandByPoint: function(t) {
                return this.min.min(t), this.max.max(t), this
            },
            expandByVector: function(t) {
                return this.min.sub(t), this.max.add(t), this
            },
            expandByScalar: function(t) {
                return this.min.addScalar(-t), this.max.addScalar(t), this
            },
            containsPoint: function(t) {
                return !(t.x < this.min.x || t.x > this.max.x || t.y < this.min.y || t.y > this.max.y)
            },
            containsBox: function(t) {
                return this.min.x <= t.min.x && t.max.x <= this.max.x && this.min.y <= t.min.y && t.max.y <= this.max.y
            },
            getParameter: function(t, e) {
                return (e || new i).set((t.x - this.min.x) / (this.max.x - this.min.x), (t.y - this.min.y) / (this.max.y - this.min.y))
            },
            intersectsBox: function(t) {
                return !(t.max.x < this.min.x || t.min.x > this.max.x || t.max.y < this.min.y || t.min.y > this.max.y)
            },
            clampPoint: function(t, e) {
                return (e || new i).copy(t).clamp(this.min, this.max)
            },
            distanceToPoint: function() {
                var t = new i;
                return function(e) {
                    return t.copy(e).clamp(this.min, this.max).sub(e).length()
                }
            }(),
            intersect: function(t) {
                return this.min.max(t.min), this.max.min(t.max), this
            },
            union: function(t) {
                return this.min.min(t.min), this.max.max(t.max), this
            },
            translate: function(t) {
                return this.min.add(t), this.max.add(t), this
            },
            equals: function(t) {
                return t.min.equals(this.min) && t.max.equals(this.max)
            }
        }), Z.prototype = Object.create(s.prototype), Z.prototype.constructor = Z;
        var is = 0;
        Object.assign($.prototype, e.prototype, {
            isMaterial: !0,
            onBeforeCompile: function() {},
            setValues: function(t) {
                if (void 0 !== t)
                    for (var e in t) {
                        var i = t[e];
                        if (void 0 !== i)
                            if ("shading" !== e) {
                                var n = this[e];
                                void 0 !== n ? n && n.isColor ? n.set(i) : n && n.isVector3 && i && i.isVector3 ? n.copy(i) : this[e] = "overdraw" === e ? Number(i) : i : console.warn("THREE." + this.type + ": '" + e + "' is not a property of this material.")
                            } else console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead."), this.flatShading = 1 === i;
                        else console.warn("THREE.Material: '" + e + "' parameter is undefined.")
                    }
            },
            toJSON: function(t) {
                function e(t) {
                    var e = [];
                    for (var i in t) {
                        var n = t[i];
                        delete n.metadata, e.push(n)
                    }
                    return e
                }
                var i = void 0 === t || "string" == typeof t;
                i && (t = {
                    textures: {},
                    images: {}
                });
                var n = {
                    metadata: {
                        version: 4.5,
                        type: "Material",
                        generator: "Material.toJSON"
                    }
                };
                if (n.uuid = this.uuid, n.type = this.type, "" !== this.name && (n.name = this.name), this.color && this.color.isColor && (n.color = this.color.getHex()), void 0 !== this.roughness && (n.roughness = this.roughness), void 0 !== this.metalness && (n.metalness = this.metalness), this.emissive && this.emissive.isColor && (n.emissive = this.emissive.getHex()), 1 !== this.emissiveIntensity && (n.emissiveIntensity = this.emissiveIntensity), this.specular && this.specular.isColor && (n.specular = this.specular.getHex()), void 0 !== this.shininess && (n.shininess = this.shininess), void 0 !== this.clearCoat && (n.clearCoat = this.clearCoat), void 0 !== this.clearCoatRoughness && (n.clearCoatRoughness = this.clearCoatRoughness), this.map && this.map.isTexture && (n.map = this.map.toJSON(t).uuid), this.alphaMap && this.alphaMap.isTexture && (n.alphaMap = this.alphaMap.toJSON(t).uuid), this.lightMap && this.lightMap.isTexture && (n.lightMap = this.lightMap.toJSON(t).uuid), this.bumpMap && this.bumpMap.isTexture && (n.bumpMap = this.bumpMap.toJSON(t).uuid, n.bumpScale = this.bumpScale), this.normalMap && this.normalMap.isTexture && (n.normalMap = this.normalMap.toJSON(t).uuid, n.normalScale = this.normalScale.toArray()), this.displacementMap && this.displacementMap.isTexture && (n.displacementMap = this.displacementMap.toJSON(t).uuid, n.displacementScale = this.displacementScale, n.displacementBias = this.displacementBias), this.roughnessMap && this.roughnessMap.isTexture && (n.roughnessMap = this.roughnessMap.toJSON(t).uuid), this.metalnessMap && this.metalnessMap.isTexture && (n.metalnessMap = this.metalnessMap.toJSON(t).uuid), this.emissiveMap && this.emissiveMap.isTexture && (n.emissiveMap = this.emissiveMap.toJSON(t).uuid), this.specularMap && this.specularMap.isTexture && (n.specularMap = this.specularMap.toJSON(t).uuid), this.envMap && this.envMap.isTexture && (n.envMap = this.envMap.toJSON(t).uuid, n.reflectivity = this.reflectivity), this.gradientMap && this.gradientMap.isTexture && (n.gradientMap = this.gradientMap.toJSON(t).uuid), void 0 !== this.size && (n.size = this.size), void 0 !== this.sizeAttenuation && (n.sizeAttenuation = this.sizeAttenuation), this.blending !== Kr && (n.blending = this.blending), !0 === this.flatShading && (n.flatShading = this.flatShading), this.side !== Xr && (n.side = this.side), this.vertexColors !== Qr && (n.vertexColors = this.vertexColors), this.opacity < 1 && (n.opacity = this.opacity), !0 === this.transparent && (n.transparent = this.transparent), n.depthFunc = this.depthFunc, n.depthTest = this.depthTest, n.depthWrite = this.depthWrite, 0 !== this.rotation && (n.rotation = this.rotation), 1 !== this.linewidth && (n.linewidth = this.linewidth), void 0 !== this.dashSize && (n.dashSize = this.dashSize), void 0 !== this.gapSize && (n.gapSize = this.gapSize), void 0 !== this.scale && (n.scale = this.scale), !0 === this.dithering && (n.dithering = !0), this.alphaTest > 0 && (n.alphaTest = this.alphaTest), !0 === this.premultipliedAlpha && (n.premultipliedAlpha = this.premultipliedAlpha), !0 === this.wireframe && (n.wireframe = this.wireframe), this.wireframeLinewidth > 1 && (n.wireframeLinewidth = this.wireframeLinewidth), "round" !== this.wireframeLinecap && (n.wireframeLinecap = this.wireframeLinecap), "round" !== this.wireframeLinejoin && (n.wireframeLinejoin = this.wireframeLinejoin), !0 === this.morphTargets && (n.morphTargets = !0), !0 === this.skinning && (n.skinning = !0), !1 === this.visible && (n.visible = !1), "{}" !== JSON.stringify(this.userData) && (n.userData = this.userData), i) {
                    var r = e(t.textures),
                        o = e(t.images);
                    r.length > 0 && (n.textures = r), o.length > 0 && (n.images = o)
                }
                return n
            },
            clone: function() {
                return (new this.constructor).copy(this)
            },
            copy: function(t) {
                this.name = t.name, this.fog = t.fog, this.lights = t.lights, this.blending = t.blending, this.side = t.side, this.flatShading = t.flatShading, this.vertexColors = t.vertexColors, this.opacity = t.opacity, this.transparent = t.transparent, this.blendSrc = t.blendSrc, this.blendDst = t.blendDst, this.blendEquation = t.blendEquation, this.blendSrcAlpha = t.blendSrcAlpha, this.blendDstAlpha = t.blendDstAlpha, this.blendEquationAlpha = t.blendEquationAlpha, this.depthFunc = t.depthFunc, this.depthTest = t.depthTest, this.depthWrite = t.depthWrite, this.colorWrite = t.colorWrite, this.precision = t.precision, this.polygonOffset = t.polygonOffset, this.polygonOffsetFactor = t.polygonOffsetFactor, this.polygonOffsetUnits = t.polygonOffsetUnits, this.dithering = t.dithering, this.alphaTest = t.alphaTest, this.premultipliedAlpha = t.premultipliedAlpha, this.overdraw = t.overdraw, this.visible = t.visible, this.userData = JSON.parse(JSON.stringify(t.userData)), this.clipShadows = t.clipShadows, this.clipIntersection = t.clipIntersection;
                var e = t.clippingPlanes,
                    i = null;
                if (null !== e) {
                    var n = e.length;
                    i = new Array(n);
                    for (var r = 0; r !== n; ++r) i[r] = e[r].clone()
                }
                return this.clippingPlanes = i, this
            },
            dispose: function() {
                this.dispatchEvent({
                    type: "dispose"
                })
            }
        }), K.prototype = Object.create($.prototype), K.prototype.constructor = K, K.prototype.isMeshDepthMaterial = !0, K.prototype.copy = function(t) {
            return $.prototype.copy.call(this, t), this.depthPacking = t.depthPacking, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.map = t.map, this.alphaMap = t.alphaMap, this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this
        }, tt.prototype = Object.create($.prototype), tt.prototype.constructor = tt, tt.prototype.isMeshDistanceMaterial = !0, tt.prototype.copy = function(t) {
            return $.prototype.copy.call(this, t), this.referencePosition.copy(t.referencePosition), this.nearDistance = t.nearDistance, this.farDistance = t.farDistance, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.map = t.map, this.alphaMap = t.alphaMap, this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this
        }, Object.assign(et.prototype, {
            isBox3: !0,
            set: function(t, e) {
                return this.min.copy(t), this.max.copy(e), this
            },
            setFromArray: function(t) {
                for (var e = 1 / 0, i = 1 / 0, n = 1 / 0, r = -1 / 0, o = -1 / 0, a = -1 / 0, s = 0, l = t.length; s < l; s += 3) {
                    var c = t[s],
                        u = t[s + 1],
                        h = t[s + 2];
                    c < e && (e = c), u < i && (i = u), h < n && (n = h), c > r && (r = c), u > o && (o = u), h > a && (a = h)
                }
                return this.min.set(e, i, n), this.max.set(r, o, a), this
            },
            setFromBufferAttribute: function(t) {
                for (var e = 1 / 0, i = 1 / 0, n = 1 / 0, r = -1 / 0, o = -1 / 0, a = -1 / 0, s = 0, l = t.count; s < l; s++) {
                    var c = t.getX(s),
                        u = t.getY(s),
                        h = t.getZ(s);
                    c < e && (e = c), u < i && (i = u), h < n && (n = h), c > r && (r = c), u > o && (o = u), h > a && (a = h)
                }
                return this.min.set(e, i, n), this.max.set(r, o, a), this
            },
            setFromPoints: function(t) {
                this.makeEmpty();
                for (var e = 0, i = t.length; e < i; e++) this.expandByPoint(t[e]);
                return this
            },
            setFromCenterAndSize: function() {
                var t = new o;
                return function(e, i) {
                    var n = t.copy(i).multiplyScalar(.5);
                    return this.min.copy(e).sub(n), this.max.copy(e).add(n), this
                }
            }(),
            setFromObject: function(t) {
                return this.makeEmpty(), this.expandByObject(t)
            },
            clone: function() {
                return (new this.constructor).copy(this)
            },
            copy: function(t) {
                return this.min.copy(t.min), this.max.copy(t.max), this
            },
            makeEmpty: function() {
                return this.min.x = this.min.y = this.min.z = 1 / 0, this.max.x = this.max.y = this.max.z = -1 / 0, this
            },
            isEmpty: function() {
                return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z
            },
            getCenter: function(t) {
                var e = t || new o;
                return this.isEmpty() ? e.set(0, 0, 0) : e.addVectors(this.min, this.max).multiplyScalar(.5)
            },
            getSize: function(t) {
                var e = t || new o;
                return this.isEmpty() ? e.set(0, 0, 0) : e.subVectors(this.max, this.min)
            },
            expandByPoint: function(t) {
                return this.min.min(t), this.max.max(t), this
            },
            expandByVector: function(t) {
                return this.min.sub(t), this.max.add(t), this
            },
            expandByScalar: function(t) {
                return this.min.addScalar(-t), this.max.addScalar(t), this
            },
            expandByObject: function() {
                function t(t) {
                    var o = t.geometry;
                    if (void 0 !== o)
                        if (o.isGeometry) {
                            var a = o.vertices;
                            for (i = 0, n = a.length; i < n; i++) r.copy(a[i]), r.applyMatrix4(t.matrixWorld), e.expandByPoint(r)
                        } else if (o.isBufferGeometry) {
                        var s = o.attributes.position;
                        if (void 0 !== s)
                            for (i = 0, n = s.count; i < n; i++) r.fromBufferAttribute(s, i).applyMatrix4(t.matrixWorld), e.expandByPoint(r)
                    }
                }
                var e, i, n, r = new o;
                return function(i) {
                    return e = this, i.updateMatrixWorld(!0), i.traverse(t), this
                }
            }(),
            containsPoint: function(t) {
                return !(t.x < this.min.x || t.x > this.max.x || t.y < this.min.y || t.y > this.max.y || t.z < this.min.z || t.z > this.max.z)
            },
            containsBox: function(t) {
                return this.min.x <= t.min.x && t.max.x <= this.max.x && this.min.y <= t.min.y && t.max.y <= this.max.y && this.min.z <= t.min.z && t.max.z <= this.max.z
            },
            getParameter: function(t, e) {
                return (e || new o).set((t.x - this.min.x) / (this.max.x - this.min.x), (t.y - this.min.y) / (this.max.y - this.min.y), (t.z - this.min.z) / (this.max.z - this.min.z))
            },
            intersectsBox: function(t) {
                return !(t.max.x < this.min.x || t.min.x > this.max.x || t.max.y < this.min.y || t.min.y > this.max.y || t.max.z < this.min.z || t.min.z > this.max.z)
            },
            intersectsSphere: function() {
                var t = new o;
                return function(e) {
                    return this.clampPoint(e.center, t), t.distanceToSquared(e.center) <= e.radius * e.radius
                }
            }(),
            intersectsPlane: function(t) {
                var e, i;
                return t.normal.x > 0 ? (e = t.normal.x * this.min.x, i = t.normal.x * this.max.x) : (e = t.normal.x * this.max.x, i = t.normal.x * this.min.x), t.normal.y > 0 ? (e += t.normal.y * this.min.y, i += t.normal.y * this.max.y) : (e += t.normal.y * this.max.y, i += t.normal.y * this.min.y), t.normal.z > 0 ? (e += t.normal.z * this.min.z, i += t.normal.z * this.max.z) : (e += t.normal.z * this.max.z, i += t.normal.z * this.min.z), e <= t.constant && i >= t.constant
            },
            clampPoint: function(t, e) {
                return (e || new o).copy(t).clamp(this.min, this.max)
            },
            distanceToPoint: function() {
                var t = new o;
                return function(e) {
                    return t.copy(e).clamp(this.min, this.max).sub(e).length()
                }
            }(),
            getBoundingSphere: function() {
                var t = new o;
                return function(e) {
                    var i = e || new it;
                    return this.getCenter(i.center), i.radius = .5 * this.getSize(t).length(), i
                }
            }(),
            intersect: function(t) {
                return this.min.max(t.min), this.max.min(t.max), this.isEmpty() && this.makeEmpty(), this
            },
            union: function(t) {
                return this.min.min(t.min), this.max.max(t.max), this
            },
            applyMatrix4: function() {
                var t = [new o, new o, new o, new o, new o, new o, new o, new o];
                return function(e) {
                    return this.isEmpty() ? this : (t[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(e), t[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(e), t[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(e), t[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(e), t[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(e), t[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(e), t[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(e), t[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(e), this.setFromPoints(t), this)
                }
            }(),
            translate: function(t) {
                return this.min.add(t), this.max.add(t), this
            },
            equals: function(t) {
                return t.min.equals(this.min) && t.max.equals(this.max)
            }
        }), Object.assign(it.prototype, {
            set: function(t, e) {
                return this.center.copy(t), this.radius = e, this
            },
            setFromPoints: function() {
                var t = new et;
                return function(e, i) {
                    var n = this.center;
                    void 0 !== i ? n.copy(i) : t.setFromPoints(e).getCenter(n);
                    for (var r = 0, o = 0, a = e.length; o < a; o++) r = Math.max(r, n.distanceToSquared(e[o]));
                    return this.radius = Math.sqrt(r), this
                }
            }(),
            clone: function() {
                return (new this.constructor).copy(this)
            },
            copy: function(t) {
                return this.center.copy(t.center), this.radius = t.radius, this
            },
            empty: function() {
                return this.radius <= 0
            },
            containsPoint: function(t) {
                return t.distanceToSquared(this.center) <= this.radius * this.radius
            },
            distanceToPoint: function(t) {
                return t.distanceTo(this.center) - this.radius
            },
            intersectsSphere: function(t) {
                var e = this.radius + t.radius;
                return t.center.distanceToSquared(this.center) <= e * e
            },
            intersectsBox: function(t) {
                return t.intersectsSphere(this)
            },
            intersectsPlane: function(t) {
                return Math.abs(t.distanceToPoint(this.center)) <= this.radius
            },
            clampPoint: function(t, e) {
                var i = this.center.distanceToSquared(t),
                    n = e || new o;
                return n.copy(t), i > this.radius * this.radius && (n.sub(this.center).normalize(), n.multiplyScalar(this.radius).add(this.center)), n
            },
            getBoundingBox: function(t) {
                var e = t || new et;
                return e.set(this.center, this.center), e.expandByScalar(this.radius), e
            },
            applyMatrix4: function(t) {
                return this.center.applyMatrix4(t), this.radius = this.radius * t.getMaxScaleOnAxis(), this
            },
            translate: function(t) {
                return this.center.add(t), this
            },
            equals: function(t) {
                return t.center.equals(this.center) && t.radius === this.radius
            }
        }), Object.assign(nt.prototype, {
            set: function(t, e) {
                return this.normal.copy(t), this.constant = e, this
            },
            setComponents: function(t, e, i, n) {
                return this.normal.set(t, e, i), this.constant = n, this
            },
            setFromNormalAndCoplanarPoint: function(t, e) {
                return this.normal.copy(t), this.constant = -e.dot(this.normal), this
            },
            setFromCoplanarPoints: function() {
                var t = new o,
                    e = new o;
                return function(i, n, r) {
                    var o = t.subVectors(r, n).cross(e.subVectors(i, n)).normalize();
                    return this.setFromNormalAndCoplanarPoint(o, i), this
                }
            }(),
            clone: function() {
                return (new this.constructor).copy(this)
            },
            copy: function(t) {
                return this.normal.copy(t.normal), this.constant = t.constant, this
            },
            normalize: function() {
                var t = 1 / this.normal.length();
                return this.normal.multiplyScalar(t), this.constant *= t, this
            },
            negate: function() {
                return this.constant *= -1, this.normal.negate(), this
            },
            distanceToPoint: function(t) {
                return this.normal.dot(t) + this.constant
            },
            distanceToSphere: function(t) {
                return this.distanceToPoint(t.center) - t.radius
            },
            projectPoint: function(t, e) {
                return (e || new o).copy(this.normal).multiplyScalar(-this.distanceToPoint(t)).add(t)
            },
            intersectLine: function() {
                var t = new o;
                return function(e, i) {
                    var n = i || new o,
                        r = e.delta(t),
                        a = this.normal.dot(r);
                    if (0 !== a) {
                        var s = -(e.start.dot(this.normal) + this.constant) / a;
                        if (!(s < 0 || s > 1)) return n.copy(r).multiplyScalar(s).add(e.start)
                    } else if (0 === this.distanceToPoint(e.start)) return n.copy(e.start)
                }
            }(),
            intersectsLine: function(t) {
                var e = this.distanceToPoint(t.start),
                    i = this.distanceToPoint(t.end);
                return e < 0 && i > 0 || i < 0 && e > 0
            },
            intersectsBox: function(t) {
                return t.intersectsPlane(this)
            },
            intersectsSphere: function(t) {
                return t.intersectsPlane(this)
            },
            coplanarPoint: function(t) {
                return (t || new o).copy(this.normal).multiplyScalar(-this.constant)
            },
            applyMatrix4: function() {
                var t = new o,
                    e = new a;
                return function(i, n) {
                    var r = n || e.getNormalMatrix(i),
                        o = this.coplanarPoint(t).applyMatrix4(i),
                        a = this.normal.applyMatrix3(r).normalize();
                    return this.constant = -o.dot(a), this
                }
            }(),
            translate: function(t) {
                return this.constant -= t.dot(this.normal), this
            },
            equals: function(t) {
                return t.normal.equals(this.normal) && t.constant === this.constant
            }
        }), Object.assign(rt.prototype, {
            set: function(t, e, i, n, r, o) {
                var a = this.planes;
                return a[0].copy(t), a[1].copy(e), a[2].copy(i), a[3].copy(n), a[4].copy(r), a[5].copy(o), this
            },
            clone: function() {
                return (new this.constructor).copy(this)
            },
            copy: function(t) {
                for (var e = this.planes, i = 0; i < 6; i++) e[i].copy(t.planes[i]);
                return this
            },
            setFromMatrix: function(t) {
                var e = this.planes,
                    i = t.elements,
                    n = i[0],
                    r = i[1],
                    o = i[2],
                    a = i[3],
                    s = i[4],
                    l = i[5],
                    c = i[6],
                    u = i[7],
                    h = i[8],
                    d = i[9],
                    p = i[10],
                    f = i[11],
                    m = i[12],
                    g = i[13],
                    v = i[14],
                    y = i[15];
                return e[0].setComponents(a - n, u - s, f - h, y - m).normalize(), e[1].setComponents(a + n, u + s, f + h, y + m).normalize(), e[2].setComponents(a + r, u + l, f + d, y + g).normalize(), e[3].setComponents(a - r, u - l, f - d, y - g).normalize(), e[4].setComponents(a - o, u - c, f - p, y - v).normalize(), e[5].setComponents(a + o, u + c, f + p, y + v).normalize(), this
            },
            intersectsObject: function() {
                var t = new it;
                return function(e) {
                    var i = e.geometry;
                    return null === i.boundingSphere && i.computeBoundingSphere(), t.copy(i.boundingSphere).applyMatrix4(e.matrixWorld), this.intersectsSphere(t)
                }
            }(),
            intersectsSprite: function() {
                var t = new it;
                return function(e) {
                    return t.center.set(0, 0, 0), t.radius = .7071067811865476, t.applyMatrix4(e.matrixWorld), this.intersectsSphere(t)
                }
            }(),
            intersectsSphere: function(t) {
                for (var e = this.planes, i = t.center, n = -t.radius, r = 0; r < 6; r++)
                    if (e[r].distanceToPoint(i) < n) return !1;
                return !0
            },
            intersectsBox: function() {
                var t = new o,
                    e = new o;
                return function(i) {
                    for (var n = this.planes, r = 0; r < 6; r++) {
                        var o = n[r];
                        t.x = o.normal.x > 0 ? i.min.x : i.max.x, e.x = o.normal.x > 0 ? i.max.x : i.min.x, t.y = o.normal.y > 0 ? i.min.y : i.max.y, e.y = o.normal.y > 0 ? i.max.y : i.min.y, t.z = o.normal.z > 0 ? i.min.z : i.max.z, e.z = o.normal.z > 0 ? i.max.z : i.min.z;
                        var a = o.distanceToPoint(t),
                            s = o.distanceToPoint(e);
                        if (a < 0 && s < 0) return !1
                    }
                    return !0
                }
            }(),
            containsPoint: function(t) {
                for (var e = this.planes, i = 0; i < 6; i++)
                    if (e[i].distanceToPoint(t) < 0) return !1;
                return !0
            }
        }), st.RotationOrders = ["XYZ", "YZX", "ZXY", "XZY", "YXZ", "ZYX"], st.DefaultOrder = "XYZ", Object.defineProperties(st.prototype, {
            x: {
                get: function() {
                    return this._x
                },
                set: function(t) {
                    this._x = t, this.onChangeCallback()
                }
            },
            y: {
                get: function() {
                    return this._y
                },
                set: function(t) {
                    this._y = t, this.onChangeCallback()
                }
            },
            z: {
                get: function() {
                    return this._z
                },
                set: function(t) {
                    this._z = t, this.onChangeCallback()
                }
            },
            order: {
                get: function() {
                    return this._order
                },
                set: function(t) {
                    this._order = t, this.onChangeCallback()
                }
            }
        }), Object.assign(st.prototype, {
            isEuler: !0,
            set: function(t, e, i, n) {
                return this._x = t, this._y = e, this._z = i, this._order = n || this._order, this.onChangeCallback(), this
            },
            clone: function() {
                return new this.constructor(this._x, this._y, this._z, this._order)
            },
            copy: function(t) {
                return this._x = t._x, this._y = t._y, this._z = t._z, this._order = t._order, this.onChangeCallback(), this
            },
            setFromRotationMatrix: function(t, e, i) {
                var n = Ha.clamp,
                    r = t.elements,
                    o = r[0],
                    a = r[4],
                    s = r[8],
                    l = r[1],
                    c = r[5],
                    u = r[9],
                    h = r[2],
                    d = r[6],
                    p = r[10];
                return e = e || this._order, "XYZ" === e ? (this._y = Math.asin(n(s, -1, 1)), Math.abs(s) < .99999 ? (this._x = Math.atan2(-u, p), this._z = Math.atan2(-a, o)) : (this._x = Math.atan2(d, c), this._z = 0)) : "YXZ" === e ? (this._x = Math.asin(-n(u, -1, 1)), Math.abs(u) < .99999 ? (this._y = Math.atan2(s, p), this._z = Math.atan2(l, c)) : (this._y = Math.atan2(-h, o), this._z = 0)) : "ZXY" === e ? (this._x = Math.asin(n(d, -1, 1)), Math.abs(d) < .99999 ? (this._y = Math.atan2(-h, p), this._z = Math.atan2(-a, c)) : (this._y = 0, this._z = Math.atan2(l, o))) : "ZYX" === e ? (this._y = Math.asin(-n(h, -1, 1)), Math.abs(h) < .99999 ? (this._x = Math.atan2(d, p), this._z = Math.atan2(l, o)) : (this._x = 0, this._z = Math.atan2(-a, c))) : "YZX" === e ? (this._z = Math.asin(n(l, -1, 1)), Math.abs(l) < .99999 ? (this._x = Math.atan2(-u, c), this._y = Math.atan2(-h, o)) : (this._x = 0, this._y = Math.atan2(s, p))) : "XZY" === e ? (this._z = Math.asin(-n(a, -1, 1)), Math.abs(a) < .99999 ? (this._x = Math.atan2(d, c), this._y = Math.atan2(s, o)) : (this._x = Math.atan2(-u, p), this._y = 0)) : console.warn("THREE.Euler: .setFromRotationMatrix() given unsupported order: " + e), this._order = e, !1 !== i && this.onChangeCallback(), this
            },
            setFromQuaternion: function() {
                var t = new n;
                return function(e, i, n) {
                    return t.makeRotationFromQuaternion(e), this.setFromRotationMatrix(t, i, n)
                }
            }(),
            setFromVector3: function(t, e) {
                return this.set(t.x, t.y, t.z, e || this._order)
            },
            reorder: function() {
                var t = new r;
                return function(e) {
                    return t.setFromEuler(this), this.setFromQuaternion(t, e)
                }
            }(),
            equals: function(t) {
                return t._x === this._x && t._y === this._y && t._z === this._z && t._order === this._order
            },
            fromArray: function(t) {
                return this._x = t[0], this._y = t[1], this._z = t[2], void 0 !== t[3] && (this._order = t[3]), this.onChangeCallback(), this
            },
            toArray: function(t, e) {
                return void 0 === t && (t = []), void 0 === e && (e = 0), t[e] = this._x, t[e + 1] = this._y, t[e + 2] = this._z, t[e + 3] = this._order, t
            },
            toVector3: function(t) {
                return t ? t.set(this._x, this._y, this._z) : new o(this._x, this._y, this._z)
            },
            onChange: function(t) {
                return this.onChangeCallback = t, this
            },
            onChangeCallback: function() {}
        }), Object.assign(lt.prototype, {
            set: function(t) {
                this.mask = 1 << t | 0
            },
            enable: function(t) {
                this.mask |= 1 << t | 0
            },
            toggle: function(t) {
                this.mask ^= 1 << t | 0
            },
            disable: function(t) {
                this.mask &= ~(1 << t | 0)
            },
            test: function(t) {
                return 0 != (this.mask & t.mask)
            }
        });
        var ns = 0;
        ct.DefaultUp = new o(0, 1, 0), ct.DefaultMatrixAutoUpdate = !0, Object.assign(ct.prototype, e.prototype, {
            isObject3D: !0,
            onBeforeRender: function() {},
            onAfterRender: function() {},
            applyMatrix: function(t) {
                this.matrix.multiplyMatrices(t, this.matrix), this.matrix.decompose(this.position, this.quaternion, this.scale)
            },
            applyQuaternion: function(t) {
                return this.quaternion.premultiply(t), this
            },
            setRotationFromAxisAngle: function(t, e) {
                this.quaternion.setFromAxisAngle(t, e)
            },
            setRotationFromEuler: function(t) {
                this.quaternion.setFromEuler(t, !0)
            },
            setRotationFromMatrix: function(t) {
                this.quaternion.setFromRotationMatrix(t)
            },
            setRotationFromQuaternion: function(t) {
                this.quaternion.copy(t)
            },
            rotateOnAxis: function() {
                var t = new r;
                return function(e, i) {
                    return t.setFromAxisAngle(e, i), this.quaternion.multiply(t), this
                }
            }(),
            rotateOnWorldAxis: function() {
                var t = new r;
                return function(e, i) {
                    return t.setFromAxisAngle(e, i), this.quaternion.premultiply(t), this
                }
            }(),
            rotateX: function() {
                var t = new o(1, 0, 0);
                return function(e) {
                    return this.rotateOnAxis(t, e)
                }
            }(),
            rotateY: function() {
                var t = new o(0, 1, 0);
                return function(e) {
                    return this.rotateOnAxis(t, e)
                }
            }(),
            rotateZ: function() {
                var t = new o(0, 0, 1);
                return function(e) {
                    return this.rotateOnAxis(t, e)
                }
            }(),
            translateOnAxis: function() {
                var t = new o;
                return function(e, i) {
                    return t.copy(e).applyQuaternion(this.quaternion), this.position.add(t.multiplyScalar(i)), this
                }
            }(),
            translateX: function() {
                var t = new o(1, 0, 0);
                return function(e) {
                    return this.translateOnAxis(t, e)
                }
            }(),
            translateY: function() {
                var t = new o(0, 1, 0);
                return function(e) {
                    return this.translateOnAxis(t, e)
                }
            }(),
            translateZ: function() {
                var t = new o(0, 0, 1);
                return function(e) {
                    return this.translateOnAxis(t, e)
                }
            }(),
            localToWorld: function(t) {
                return t.applyMatrix4(this.matrixWorld)
            },
            worldToLocal: function() {
                var t = new n;
                return function(e) {
                    return e.applyMatrix4(t.getInverse(this.matrixWorld))
                }
            }(),
            lookAt: function() {
                var t = new n,
                    e = new o;
                return function(i, n, r) {
                    i.isVector3 ? e.copy(i) : e.set(i, n, r), this.isCamera ? t.lookAt(this.position, e, this.up) : t.lookAt(e, this.position, this.up), this.quaternion.setFromRotationMatrix(t)
                }
            }(),
            add: function(t) {
                if (arguments.length > 1) {
                    for (var e = 0; e < arguments.length; e++) this.add(arguments[e]);
                    return this
                }
                return t === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", t), this) : (t && t.isObject3D ? (null !== t.parent && t.parent.remove(t), t.parent = this, t.dispatchEvent({
                    type: "added"
                }), this.children.push(t)) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", t), this)
            },
            remove: function(t) {
                if (arguments.length > 1) {
                    for (var e = 0; e < arguments.length; e++) this.remove(arguments[e]);
                    return this
                }
                var i = this.children.indexOf(t);
                return -1 !== i && (t.parent = null, t.dispatchEvent({
                    type: "removed"
                }), this.children.splice(i, 1)), this
            },
            getObjectById: function(t) {
                return this.getObjectByProperty("id", t)
            },
            getObjectByName: function(t) {
                return this.getObjectByProperty("name", t)
            },
            getObjectByProperty: function(t, e) {
                if (this[t] === e) return this;
                for (var i = 0, n = this.children.length; i < n; i++) {
                    var r = this.children[i].getObjectByProperty(t, e);
                    if (void 0 !== r) return r
                }
            },
            getWorldPosition: function(t) {
                var e = t || new o;
                return this.updateMatrixWorld(!0), e.setFromMatrixPosition(this.matrixWorld)
            },
            getWorldQuaternion: function() {
                var t = new o,
                    e = new o;
                return function(i) {
                    var n = i || new r;
                    return this.updateMatrixWorld(!0), this.matrixWorld.decompose(t, n, e), n
                }
            }(),
            getWorldRotation: function() {
                var t = new r;
                return function(e) {
                    var i = e || new st;
                    return this.getWorldQuaternion(t), i.setFromQuaternion(t, this.rotation.order, !1)
                }
            }(),
            getWorldScale: function() {
                var t = new o,
                    e = new r;
                return function(i) {
                    var n = i || new o;
                    return this.updateMatrixWorld(!0), this.matrixWorld.decompose(t, e, n), n
                }
            }(),
            getWorldDirection: function() {
                var t = new r;
                return function(e) {
                    var i = e || new o;
                    return this.getWorldQuaternion(t), i.set(0, 0, 1).applyQuaternion(t)
                }
            }(),
            raycast: function() {},
            traverse: function(t) {
                t(this);
                for (var e = this.children, i = 0, n = e.length; i < n; i++) e[i].traverse(t)
            },
            traverseVisible: function(t) {
                if (!1 !== this.visible) {
                    t(this);
                    for (var e = this.children, i = 0, n = e.length; i < n; i++) e[i].traverseVisible(t)
                }
            },
            traverseAncestors: function(t) {
                var e = this.parent;
                null !== e && (t(e), e.traverseAncestors(t))
            },
            updateMatrix: function() {
                this.matrix.compose(this.position, this.quaternion, this.scale), this.matrixWorldNeedsUpdate = !0
            },
            updateMatrixWorld: function(t) {
                this.matrixAutoUpdate && this.updateMatrix(), (this.matrixWorldNeedsUpdate || t) && (null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), this.matrixWorldNeedsUpdate = !1, t = !0);
                for (var e = this.children, i = 0, n = e.length; i < n; i++) e[i].updateMatrixWorld(t)
            },
            toJSON: function(t) {
                function e(e, i) {
                    return void 0 === e[i.uuid] && (e[i.uuid] = i.toJSON(t)), i.uuid
                }

                function i(t) {
                    var e = [];
                    for (var i in t) {
                        var n = t[i];
                        delete n.metadata, e.push(n)
                    }
                    return e
                }
                var n = void 0 === t || "string" == typeof t,
                    r = {};
                n && (t = {
                    geometries: {},
                    materials: {},
                    textures: {},
                    images: {}
                }, r.metadata = {
                    version: 4.5,
                    type: "Object",
                    generator: "Object3D.toJSON"
                });
                var o = {};
                if (o.uuid = this.uuid, o.type = this.type, "" !== this.name && (o.name = this.name), !0 === this.castShadow && (o.castShadow = !0), !0 === this.receiveShadow && (o.receiveShadow = !0), !1 === this.visible && (o.visible = !1), "{}" !== JSON.stringify(this.userData) && (o.userData = this.userData), o.matrix = this.matrix.toArray(), void 0 !== this.geometry && (o.geometry = e(t.geometries, this.geometry)), void 0 !== this.material)
                    if (Array.isArray(this.material)) {
                        for (var a = [], s = 0, l = this.material.length; s < l; s++) a.push(e(t.materials, this.material[s]));
                        o.material = a
                    } else o.material = e(t.materials, this.material);
                if (this.children.length > 0) {
                    o.children = [];
                    for (s = 0; s < this.children.length; s++) o.children.push(this.children[s].toJSON(t).object)
                }
                if (n) {
                    var c = i(t.geometries),
                        u = i(t.materials),
                        h = i(t.textures),
                        d = i(t.images);
                    c.length > 0 && (r.geometries = c), u.length > 0 && (r.materials = u), h.length > 0 && (r.textures = h), d.length > 0 && (r.images = d)
                }
                return r.object = o, r
            },
            clone: function(t) {
                return (new this.constructor).copy(this, t)
            },
            copy: function(t, e) {
                if (void 0 === e && (e = !0), this.name = t.name, this.up.copy(t.up), this.position.copy(t.position), this.quaternion.copy(t.quaternion), this.scale.copy(t.scale), this.matrix.copy(t.matrix), this.matrixWorld.copy(t.matrixWorld), this.matrixAutoUpdate = t.matrixAutoUpdate, this.matrixWorldNeedsUpdate = t.matrixWorldNeedsUpdate, this.layers.mask = t.layers.mask, this.visible = t.visible, this.castShadow = t.castShadow, this.receiveShadow = t.receiveShadow, this.frustumCulled = t.frustumCulled, this.renderOrder = t.renderOrder, this.userData = JSON.parse(JSON.stringify(t.userData)), !0 === e)
                    for (var i = 0; i < t.children.length; i++) {
                        var n = t.children[i];
                        this.add(n.clone())
                    }
                return this
            }
        }), ut.prototype = Object.assign(Object.create(ct.prototype), {
            constructor: ut,
            isCamera: !0,
            copy: function(t, e) {
                return ct.prototype.copy.call(this, t, e), this.matrixWorldInverse.copy(t.matrixWorldInverse), this.projectionMatrix.copy(t.projectionMatrix), this
            },
            getWorldDirection: function() {
                var t = new r;
                return function(e) {
                    var i = e || new o;
                    return this.getWorldQuaternion(t), i.set(0, 0, -1).applyQuaternion(t)
                }
            }(),
            updateMatrixWorld: function(t) {
                ct.prototype.updateMatrixWorld.call(this, t), this.matrixWorldInverse.getInverse(this.matrixWorld)
            },
            clone: function() {
                return (new this.constructor).copy(this)
            }
        }), ht.prototype = Object.assign(Object.create(ut.prototype), {
            constructor: ht,
            isOrthographicCamera: !0,
            copy: function(t, e) {
                return ut.prototype.copy.call(this, t, e), this.left = t.left, this.right = t.right, this.top = t.top, this.bottom = t.bottom, this.near = t.near, this.far = t.far, this.zoom = t.zoom, this.view = null === t.view ? null : Object.assign({}, t.view), this
            },
            setViewOffset: function(t, e, i, n, r, o) {
                null === this.view && (this.view = {
                    enabled: !0,
                    fullWidth: 1,
                    fullHeight: 1,
                    offsetX: 0,
                    offsetY: 0,
                    width: 1,
                    height: 1
                }), this.view.enabled = !0, this.view.fullWidth = t, this.view.fullHeight = e, this.view.offsetX = i, this.view.offsetY = n, this.view.width = r, this.view.height = o, this.updateProjectionMatrix()
            },
            clearViewOffset: function() {
                null !== this.view && (this.view.enabled = !1), this.updateProjectionMatrix()
            },
            updateProjectionMatrix: function() {
                var t = (this.right - this.left) / (2 * this.zoom),
                    e = (this.top - this.bottom) / (2 * this.zoom),
                    i = (this.right + this.left) / 2,
                    n = (this.top + this.bottom) / 2,
                    r = i - t,
                    o = i + t,
                    a = n + e,
                    s = n - e;
                if (null !== this.view && this.view.enabled) {
                    var l = this.zoom / (this.view.width / this.view.fullWidth),
                        c = this.zoom / (this.view.height / this.view.fullHeight),
                        u = (this.right - this.left) / this.view.width,
                        h = (this.top - this.bottom) / this.view.height;
                    o = (r += u * (this.view.offsetX / l)) + u * (this.view.width / l), s = (a -= h * (this.view.offsetY / c)) - h * (this.view.height / c)
                }
                this.projectionMatrix.makeOrthographic(r, o, a, s, this.near, this.far)
            },
            toJSON: function(t) {
                var e = ct.prototype.toJSON.call(this, t);
                return e.object.zoom = this.zoom, e.object.left = this.left, e.object.right = this.right, e.object.top = this.top, e.object.bottom = this.bottom, e.object.near = this.near, e.object.far = this.far, null !== this.view && (e.object.view = Object.assign({}, this.view)), e
            }
        }), Object.assign(dt.prototype, {
            clone: function() {
                return (new this.constructor).copy(this)
            },
            copy: function(t) {
                this.a = t.a, this.b = t.b, this.c = t.c, this.normal.copy(t.normal), this.color.copy(t.color), this.materialIndex = t.materialIndex;
                for (var e = 0, i = t.vertexNormals.length; e < i; e++) this.vertexNormals[e] = t.vertexNormals[e].clone();
                for (var e = 0, i = t.vertexColors.length; e < i; e++) this.vertexColors[e] = t.vertexColors[e].clone();
                return this
            }
        });
        var rs = 0;
        Object.assign(pt.prototype, e.prototype, {
            isGeometry: !0,
            applyMatrix: function(t) {
                for (var e = (new a).getNormalMatrix(t), i = 0, n = this.vertices.length; i < n; i++) this.vertices[i].applyMatrix4(t);
                for (var i = 0, n = this.faces.length; i < n; i++) {
                    var r = this.faces[i];
                    r.normal.applyMatrix3(e).normalize();
                    for (var o = 0, s = r.vertexNormals.length; o < s; o++) r.vertexNormals[o].applyMatrix3(e).normalize()
                }
                return null !== this.boundingBox && this.computeBoundingBox(), null !== this.boundingSphere && this.computeBoundingSphere(), this.verticesNeedUpdate = !0, this.normalsNeedUpdate = !0, this
            },
            rotateX: function() {
                var t = new n;
                return function(e) {
                    return t.makeRotationX(e), this.applyMatrix(t), this
                }
            }(),
            rotateY: function() {
                var t = new n;
                return function(e) {
                    return t.makeRotationY(e), this.applyMatrix(t), this
                }
            }(),
            rotateZ: function() {
                var t = new n;
                return function(e) {
                    return t.makeRotationZ(e), this.applyMatrix(t), this
                }
            }(),
            translate: function() {
                var t = new n;
                return function(e, i, n) {
                    return t.makeTranslation(e, i, n), this.applyMatrix(t), this
                }
            }(),
            scale: function() {
                var t = new n;
                return function(e, i, n) {
                    return t.makeScale(e, i, n), this.applyMatrix(t), this
                }
            }(),
            lookAt: function() {
                var t = new ct;
                return function(e) {
                    t.lookAt(e), t.updateMatrix(), this.applyMatrix(t.matrix)
                }
            }(),
            fromBufferGeometry: function(t) {
                function e(t, e, i, r) {
                    var o = new dt(t, e, i, void 0 !== l ? [d[t].clone(), d[e].clone(), d[i].clone()] : [], void 0 !== c ? [n.colors[t].clone(), n.colors[e].clone(), n.colors[i].clone()] : [], r);
                    n.faces.push(o), void 0 !== u && n.faceVertexUvs[0].push([p[t].clone(), p[e].clone(), p[i].clone()]), void 0 !== h && n.faceVertexUvs[1].push([f[t].clone(), f[e].clone(), f[i].clone()])
                }
                var n = this,
                    r = null !== t.index ? t.index.array : void 0,
                    a = t.attributes,
                    s = a.position.array,
                    l = void 0 !== a.normal ? a.normal.array : void 0,
                    c = void 0 !== a.color ? a.color.array : void 0,
                    u = void 0 !== a.uv ? a.uv.array : void 0,
                    h = void 0 !== a.uv2 ? a.uv2.array : void 0;
                void 0 !== h && (this.faceVertexUvs[1] = []);
                for (var d = [], p = [], f = [], m = 0, g = 0; m < s.length; m += 3, g += 2) n.vertices.push(new o(s[m], s[m + 1], s[m + 2])), void 0 !== l && d.push(new o(l[m], l[m + 1], l[m + 2])), void 0 !== c && n.colors.push(new q(c[m], c[m + 1], c[m + 2])), void 0 !== u && p.push(new i(u[g], u[g + 1])), void 0 !== h && f.push(new i(h[g], h[g + 1]));
                var v = t.groups;
                if (v.length > 0)
                    for (m = 0; m < v.length; m++)
                        for (var y = v[m], _ = y.start, g = _, x = _ + y.count; g < x; g += 3) void 0 !== r ? e(r[g], r[g + 1], r[g + 2], y.materialIndex) : e(g, g + 1, g + 2, y.materialIndex);
                else if (void 0 !== r)
                    for (m = 0; m < r.length; m += 3) e(r[m], r[m + 1], r[m + 2]);
                else
                    for (m = 0; m < s.length / 3; m += 3) e(m, m + 1, m + 2);
                return this.computeFaceNormals(), null !== t.boundingBox && (this.boundingBox = t.boundingBox.clone()), null !== t.boundingSphere && (this.boundingSphere = t.boundingSphere.clone()), this
            },
            center: function() {
                this.computeBoundingBox();
                var t = this.boundingBox.getCenter().negate();
                return this.translate(t.x, t.y, t.z), t
            },
            normalize: function() {
                this.computeBoundingSphere();
                var t = this.boundingSphere.center,
                    e = this.boundingSphere.radius,
                    i = 0 === e ? 1 : 1 / e,
                    r = new n;
                return r.set(i, 0, 0, -i * t.x, 0, i, 0, -i * t.y, 0, 0, i, -i * t.z, 0, 0, 0, 1), this.applyMatrix(r), this
            },
            computeFaceNormals: function() {
                for (var t = new o, e = new o, i = 0, n = this.faces.length; i < n; i++) {
                    var r = this.faces[i],
                        a = this.vertices[r.a],
                        s = this.vertices[r.b],
                        l = this.vertices[r.c];
                    t.subVectors(l, s), e.subVectors(a, s), t.cross(e), t.normalize(), r.normal.copy(t)
                }
            },
            computeVertexNormals: function(t) {
                void 0 === t && (t = !0);
                var e, i, n, r, a, s;
                for (s = new Array(this.vertices.length), e = 0, i = this.vertices.length; e < i; e++) s[e] = new o;
                if (t) {
                    var l, c, u, h = new o,
                        d = new o;
                    for (n = 0, r = this.faces.length; n < r; n++) a = this.faces[n], l = this.vertices[a.a], c = this.vertices[a.b], u = this.vertices[a.c], h.subVectors(u, c), d.subVectors(l, c), h.cross(d), s[a.a].add(h), s[a.b].add(h), s[a.c].add(h)
                } else
                    for (this.computeFaceNormals(), n = 0, r = this.faces.length; n < r; n++) s[(a = this.faces[n]).a].add(a.normal), s[a.b].add(a.normal), s[a.c].add(a.normal);
                for (e = 0, i = this.vertices.length; e < i; e++) s[e].normalize();
                for (n = 0, r = this.faces.length; n < r; n++) {
                    var p = (a = this.faces[n]).vertexNormals;
                    3 === p.length ? (p[0].copy(s[a.a]), p[1].copy(s[a.b]), p[2].copy(s[a.c])) : (p[0] = s[a.a].clone(), p[1] = s[a.b].clone(), p[2] = s[a.c].clone())
                }
                this.faces.length > 0 && (this.normalsNeedUpdate = !0)
            },
            computeFlatVertexNormals: function() {
                var t, e, i;
                for (this.computeFaceNormals(), t = 0, e = this.faces.length; t < e; t++) {
                    var n = (i = this.faces[t]).vertexNormals;
                    3 === n.length ? (n[0].copy(i.normal), n[1].copy(i.normal), n[2].copy(i.normal)) : (n[0] = i.normal.clone(), n[1] = i.normal.clone(), n[2] = i.normal.clone())
                }
                this.faces.length > 0 && (this.normalsNeedUpdate = !0)
            },
            computeMorphNormals: function() {
                var t, e, i, n, r;
                for (i = 0, n = this.faces.length; i < n; i++)
                    for ((r = this.faces[i]).__originalFaceNormal ? r.__originalFaceNormal.copy(r.normal) : r.__originalFaceNormal = r.normal.clone(), r.__originalVertexNormals || (r.__originalVertexNormals = []), t = 0, e = r.vertexNormals.length; t < e; t++) r.__originalVertexNormals[t] ? r.__originalVertexNormals[t].copy(r.vertexNormals[t]) : r.__originalVertexNormals[t] = r.vertexNormals[t].clone();
                var a = new pt;
                for (a.faces = this.faces, t = 0, e = this.morphTargets.length; t < e; t++) {
                    if (!this.morphNormals[t]) {
                        this.morphNormals[t] = {}, this.morphNormals[t].faceNormals = [], this.morphNormals[t].vertexNormals = [];
                        var s = this.morphNormals[t].faceNormals,
                            l = this.morphNormals[t].vertexNormals;
                        for (i = 0, n = this.faces.length; i < n; i++) u = new o, h = {
                            a: new o,
                            b: new o,
                            c: new o
                        }, s.push(u), l.push(h)
                    }
                    var c = this.morphNormals[t];
                    a.vertices = this.morphTargets[t].vertices, a.computeFaceNormals(), a.computeVertexNormals();
                    var u, h;
                    for (i = 0, n = this.faces.length; i < n; i++) r = this.faces[i], u = c.faceNormals[i], h = c.vertexNormals[i], u.copy(r.normal), h.a.copy(r.vertexNormals[0]), h.b.copy(r.vertexNormals[1]), h.c.copy(r.vertexNormals[2])
                }
                for (i = 0, n = this.faces.length; i < n; i++)(r = this.faces[i]).normal = r.__originalFaceNormal, r.vertexNormals = r.__originalVertexNormals
            },
            computeLineDistances: function() {
                for (var t = 0, e = this.vertices, i = 0, n = e.length; i < n; i++) i > 0 && (t += e[i].distanceTo(e[i - 1])), this.lineDistances[i] = t
            },
            computeBoundingBox: function() {
                null === this.boundingBox && (this.boundingBox = new et), this.boundingBox.setFromPoints(this.vertices)
            },
            computeBoundingSphere: function() {
                null === this.boundingSphere && (this.boundingSphere = new it), this.boundingSphere.setFromPoints(this.vertices)
            },
            merge: function(t, e, i) {
                if (t && t.isGeometry) {
                    var n, r = this.vertices.length,
                        o = this.vertices,
                        s = t.vertices,
                        l = this.faces,
                        c = t.faces,
                        u = this.faceVertexUvs[0],
                        h = t.faceVertexUvs[0],
                        d = this.colors,
                        p = t.colors;
                    void 0 === i && (i = 0), void 0 !== e && (n = (new a).getNormalMatrix(e));
                    for (var f = 0, m = s.length; f < m; f++) {
                        var g = s[f].clone();
                        void 0 !== e && g.applyMatrix4(e), o.push(g)
                    }
                    for (var f = 0, m = p.length; f < m; f++) d.push(p[f].clone());
                    for (f = 0, m = c.length; f < m; f++) {
                        var v, y, _, x = c[f],
                            b = x.vertexNormals,
                            w = x.vertexColors;
                        (v = new dt(x.a + r, x.b + r, x.c + r)).normal.copy(x.normal), void 0 !== n && v.normal.applyMatrix3(n).normalize();
                        for (var T = 0, S = b.length; T < S; T++) y = b[T].clone(), void 0 !== n && y.applyMatrix3(n).normalize(), v.vertexNormals.push(y);
                        v.color.copy(x.color);
                        for (var T = 0, S = w.length; T < S; T++) _ = w[T], v.vertexColors.push(_.clone());
                        v.materialIndex = x.materialIndex + i, l.push(v)
                    }
                    for (f = 0, m = h.length; f < m; f++) {
                        var E = h[f],
                            M = [];
                        if (void 0 !== E) {
                            for (var T = 0, S = E.length; T < S; T++) M.push(E[T].clone());
                            u.push(M)
                        }
                    }
                } else console.error("THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.", t)
            },
            mergeMesh: function(t) {
                t && t.isMesh ? (t.matrixAutoUpdate && t.updateMatrix(), this.merge(t.geometry, t.matrix)) : console.error("THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.", t)
            },
            mergeVertices: function() {
                var t, e, i, n, r, o, a, s, l = {},
                    c = [],
                    u = [],
                    h = Math.pow(10, 4);
                for (i = 0, n = this.vertices.length; i < n; i++) t = this.vertices[i], void 0 === l[e = Math.round(t.x * h) + "_" + Math.round(t.y * h) + "_" + Math.round(t.z * h)] ? (l[e] = i, c.push(this.vertices[i]), u[i] = c.length - 1) : u[i] = u[l[e]];
                var d = [];
                for (i = 0, n = this.faces.length; i < n; i++) {
                    (r = this.faces[i]).a = u[r.a], r.b = u[r.b], r.c = u[r.c], o = [r.a, r.b, r.c];
                    for (var p = 0; p < 3; p++)
                        if (o[p] === o[(p + 1) % 3]) {
                            d.push(i);
                            break
                        }
                }
                for (i = d.length - 1; i >= 0; i--) {
                    var f = d[i];
                    for (this.faces.splice(f, 1), a = 0, s = this.faceVertexUvs.length; a < s; a++) this.faceVertexUvs[a].splice(f, 1)
                }
                var m = this.vertices.length - c.length;
                return this.vertices = c, m
            },
            setFromPoints: function(t) {
                this.vertices = [];
                for (var e = 0, i = t.length; e < i; e++) {
                    var n = t[e];
                    this.vertices.push(new o(n.x, n.y, n.z || 0))
                }
                return this
            },
            sortFacesByMaterialIndex: function() {
                for (var t = this.faces, e = t.length, i = 0; i < e; i++) t[i]._id = i;
                t.sort(function(t, e) {
                    return t.materialIndex - e.materialIndex
                });
                var n, r, o = this.faceVertexUvs[0],
                    a = this.faceVertexUvs[1];
                o && o.length === e && (n = []), a && a.length === e && (r = []);
                for (i = 0; i < e; i++) {
                    var s = t[i]._id;
                    n && n.push(o[s]), r && r.push(a[s])
                }
                n && (this.faceVertexUvs[0] = n), r && (this.faceVertexUvs[1] = r)
            },
            toJSON: function() {
                function t(t, e, i) {
                    return i ? t | 1 << e : t & ~(1 << e)
                }

                function e(t) {
                    var e = t.x.toString() + t.y.toString() + t.z.toString();
                    return void 0 !== d[e] ? d[e] : (d[e] = h.length / 3, h.push(t.x, t.y, t.z), d[e])
                }

                function i(t) {
                    var e = t.r.toString() + t.g.toString() + t.b.toString();
                    return void 0 !== f[e] ? f[e] : (f[e] = p.length, p.push(t.getHex()), f[e])
                }

                function n(t) {
                    var e = t.x.toString() + t.y.toString();
                    return void 0 !== g[e] ? g[e] : (g[e] = m.length / 2, m.push(t.x, t.y), g[e])
                }
                var r = {
                    metadata: {
                        version: 4.5,
                        type: "Geometry",
                        generator: "Geometry.toJSON"
                    }
                };
                if (r.uuid = this.uuid, r.type = this.type, "" !== this.name && (r.name = this.name), void 0 !== this.parameters) {
                    var o = this.parameters;
                    for (var a in o) void 0 !== o[a] && (r[a] = o[a]);
                    return r
                }
                for (var s = [], l = 0; l < this.vertices.length; l++) {
                    var c = this.vertices[l];
                    s.push(c.x, c.y, c.z)
                }
                for (var u = [], h = [], d = {}, p = [], f = {}, m = [], g = {}, l = 0; l < this.faces.length; l++) {
                    var v = this.faces[l],
                        y = void 0 !== this.faceVertexUvs[0][l],
                        _ = v.normal.length() > 0,
                        x = v.vertexNormals.length > 0,
                        b = 1 !== v.color.r || 1 !== v.color.g || 1 !== v.color.b,
                        w = v.vertexColors.length > 0,
                        T = 0;
                    if (T = t(T, 0, 0), T = t(T, 1, !0), T = t(T, 2, !1), T = t(T, 3, y), T = t(T, 4, _), T = t(T, 5, x), T = t(T, 6, b), T = t(T, 7, w), u.push(T), u.push(v.a, v.b, v.c), u.push(v.materialIndex), y) {
                        var S = this.faceVertexUvs[0][l];
                        u.push(n(S[0]), n(S[1]), n(S[2]))
                    }
                    if (_ && u.push(e(v.normal)), x) {
                        var E = v.vertexNormals;
                        u.push(e(E[0]), e(E[1]), e(E[2]))
                    }
                    if (b && u.push(i(v.color)), w) {
                        var M = v.vertexColors;
                        u.push(i(M[0]), i(M[1]), i(M[2]))
                    }
                }
                return r.data = {}, r.data.vertices = s, r.data.normals = h, p.length > 0 && (r.data.colors = p), m.length > 0 && (r.data.uvs = [m]), r.data.faces = u, r
            },
            clone: function() {
                return (new pt).copy(this)
            },
            copy: function(t) {
                var e, i, n, r, o, a;
                this.vertices = [], this.colors = [], this.faces = [], this.faceVertexUvs = [
                    []
                ], this.morphTargets = [], this.morphNormals = [], this.skinWeights = [], this.skinIndices = [], this.lineDistances = [], this.boundingBox = null, this.boundingSphere = null, this.name = t.name;
                var s = t.vertices;
                for (e = 0, i = s.length; e < i; e++) this.vertices.push(s[e].clone());
                var l = t.colors;
                for (e = 0, i = l.length; e < i; e++) this.colors.push(l[e].clone());
                var c = t.faces;
                for (e = 0, i = c.length; e < i; e++) this.faces.push(c[e].clone());
                for (e = 0, i = t.faceVertexUvs.length; e < i; e++) {
                    var u = t.faceVertexUvs[e];
                    for (void 0 === this.faceVertexUvs[e] && (this.faceVertexUvs[e] = []), n = 0, r = u.length; n < r; n++) {
                        var h = u[n],
                            d = [];
                        for (o = 0, a = h.length; o < a; o++) {
                            var p = h[o];
                            d.push(p.clone())
                        }
                        this.faceVertexUvs[e].push(d)
                    }
                }
                var f = t.morphTargets;
                for (e = 0, i = f.length; e < i; e++) {
                    var m = {};
                    if (m.name = f[e].name, void 0 !== f[e].vertices)
                        for (m.vertices = [], n = 0, r = f[e].vertices.length; n < r; n++) m.vertices.push(f[e].vertices[n].clone());
                    if (void 0 !== f[e].normals)
                        for (m.normals = [], n = 0, r = f[e].normals.length; n < r; n++) m.normals.push(f[e].normals[n].clone());
                    this.morphTargets.push(m)
                }
                var g = t.morphNormals;
                for (e = 0, i = g.length; e < i; e++) {
                    var v = {};
                    if (void 0 !== g[e].vertexNormals)
                        for (v.vertexNormals = [], n = 0, r = g[e].vertexNormals.length; n < r; n++) {
                            var y = g[e].vertexNormals[n],
                                _ = {};
                            _.a = y.a.clone(), _.b = y.b.clone(), _.c = y.c.clone(), v.vertexNormals.push(_)
                        }
                    if (void 0 !== g[e].faceNormals)
                        for (v.faceNormals = [], n = 0, r = g[e].faceNormals.length; n < r; n++) v.faceNormals.push(g[e].faceNormals[n].clone());
                    this.morphNormals.push(v)
                }
                var x = t.skinWeights;
                for (e = 0, i = x.length; e < i; e++) this.skinWeights.push(x[e].clone());
                var b = t.skinIndices;
                for (e = 0, i = b.length; e < i; e++) this.skinIndices.push(b[e].clone());
                var w = t.lineDistances;
                for (e = 0, i = w.length; e < i; e++) this.lineDistances.push(w[e]);
                var T = t.boundingBox;
                null !== T && (this.boundingBox = T.clone());
                var S = t.boundingSphere;
                return null !== S && (this.boundingSphere = S.clone()), this.elementsNeedUpdate = t.elementsNeedUpdate, this.verticesNeedUpdate = t.verticesNeedUpdate, this.uvsNeedUpdate = t.uvsNeedUpdate, this.normalsNeedUpdate = t.normalsNeedUpdate, this.colorsNeedUpdate = t.colorsNeedUpdate, this.lineDistancesNeedUpdate = t.lineDistancesNeedUpdate, this.groupsNeedUpdate = t.groupsNeedUpdate, this
            },
            dispose: function() {
                this.dispatchEvent({
                    type: "dispose"
                })
            }
        }), Object.defineProperty(ft.prototype, "needsUpdate", {
            set: function(t) {
                !0 === t && this.version++
            }
        }), Object.assign(ft.prototype, {
            isBufferAttribute: !0,
            setArray: function(t) {
                if (Array.isArray(t)) throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
                this.count = void 0 !== t ? t.length / this.itemSize : 0, this.array = t
            },
            setDynamic: function(t) {
                return this.dynamic = t, this
            },
            copy: function(t) {
                return this.array = new t.array.constructor(t.array), this.itemSize = t.itemSize, this.count = t.count, this.normalized = t.normalized, this.dynamic = t.dynamic, this
            },
            copyAt: function(t, e, i) {
                t *= this.itemSize, i *= e.itemSize;
                for (var n = 0, r = this.itemSize; n < r; n++) this.array[t + n] = e.array[i + n];
                return this
            },
            copyArray: function(t) {
                return this.array.set(t), this
            },
            copyColorsArray: function(t) {
                for (var e = this.array, i = 0, n = 0, r = t.length; n < r; n++) {
                    var o = t[n];
                    void 0 === o && (console.warn("THREE.BufferAttribute.copyColorsArray(): color is undefined", n), o = new q), e[i++] = o.r, e[i++] = o.g, e[i++] = o.b
                }
                return this
            },
            copyIndicesArray: function(t) {
                for (var e = this.array, i = 0, n = 0, r = t.length; n < r; n++) {
                    var o = t[n];
                    e[i++] = o.a, e[i++] = o.b, e[i++] = o.c
                }
                return this
            },
            copyVector2sArray: function(t) {
                for (var e = this.array, n = 0, r = 0, o = t.length; r < o; r++) {
                    var a = t[r];
                    void 0 === a && (console.warn("THREE.BufferAttribute.copyVector2sArray(): vector is undefined", r), a = new i), e[n++] = a.x, e[n++] = a.y
                }
                return this
            },
            copyVector3sArray: function(t) {
                for (var e = this.array, i = 0, n = 0, r = t.length; n < r; n++) {
                    var a = t[n];
                    void 0 === a && (console.warn("THREE.BufferAttribute.copyVector3sArray(): vector is undefined", n), a = new o), e[i++] = a.x, e[i++] = a.y, e[i++] = a.z
                }
                return this
            },
            copyVector4sArray: function(t) {
                for (var e = this.array, i = 0, n = 0, r = t.length; n < r; n++) {
                    var o = t[n];
                    void 0 === o && (console.warn("THREE.BufferAttribute.copyVector4sArray(): vector is undefined", n), o = new l), e[i++] = o.x, e[i++] = o.y, e[i++] = o.z, e[i++] = o.w
                }
                return this
            },
            set: function(t, e) {
                return void 0 === e && (e = 0), this.array.set(t, e), this
            },
            getX: function(t) {
                return this.array[t * this.itemSize]
            },
            setX: function(t, e) {
                return this.array[t * this.itemSize] = e, this
            },
            getY: function(t) {
                return this.array[t * this.itemSize + 1]
            },
            setY: function(t, e) {
                return this.array[t * this.itemSize + 1] = e, this
            },
            getZ: function(t) {
                return this.array[t * this.itemSize + 2]
            },
            setZ: function(t, e) {
                return this.array[t * this.itemSize + 2] = e, this
            },
            getW: function(t) {
                return this.array[t * this.itemSize + 3]
            },
            setW: function(t, e) {
                return this.array[t * this.itemSize + 3] = e, this
            },
            setXY: function(t, e, i) {
                return t *= this.itemSize, this.array[t + 0] = e, this.array[t + 1] = i, this
            },
            setXYZ: function(t, e, i, n) {
                return t *= this.itemSize, this.array[t + 0] = e, this.array[t + 1] = i, this.array[t + 2] = n, this
            },
            setXYZW: function(t, e, i, n, r) {
                return t *= this.itemSize, this.array[t + 0] = e, this.array[t + 1] = i, this.array[t + 2] = n, this.array[t + 3] = r, this
            },
            onUpload: function(t) {
                return this.onUploadCallback = t, this
            },
            clone: function() {
                return new this.constructor(this.array, this.itemSize).copy(this)
            }
        }), mt.prototype = Object.create(ft.prototype), mt.prototype.constructor = mt, gt.prototype = Object.create(ft.prototype), gt.prototype.constructor = gt, vt.prototype = Object.create(ft.prototype), vt.prototype.constructor = vt, yt.prototype = Object.create(ft.prototype), yt.prototype.constructor = yt, _t.prototype = Object.create(ft.prototype), _t.prototype.constructor = _t, xt.prototype = Object.create(ft.prototype), xt.prototype.constructor = xt, bt.prototype = Object.create(ft.prototype), bt.prototype.constructor = bt, wt.prototype = Object.create(ft.prototype), wt.prototype.constructor = wt, Tt.prototype = Object.create(ft.prototype), Tt.prototype.constructor = Tt, Object.assign(St.prototype, {
            computeGroups: function(t) {
                for (var e, i = [], n = void 0, r = t.faces, o = 0; o < r.length; o++) {
                    var a = r[o];
                    a.materialIndex !== n && (n = a.materialIndex, void 0 !== e && (e.count = 3 * o - e.start, i.push(e)), e = {
                        start: 3 * o,
                        materialIndex: n
                    })
                }
                void 0 !== e && (e.count = 3 * o - e.start, i.push(e)), this.groups = i
            },
            fromGeometry: function(t) {
                var e, n = t.faces,
                    r = t.vertices,
                    o = t.faceVertexUvs,
                    a = o[0] && o[0].length > 0,
                    s = o[1] && o[1].length > 0,
                    l = t.morphTargets,
                    c = l.length;
                if (c > 0) {
                    e = [];
                    for (v = 0; v < c; v++) e[v] = [];
                    this.morphTargets.position = e
                }
                var u, h = t.morphNormals,
                    d = h.length;
                if (d > 0) {
                    u = [];
                    for (v = 0; v < d; v++) u[v] = [];
                    this.morphTargets.normal = u
                }
                for (var p = t.skinIndices, f = t.skinWeights, m = p.length === r.length, g = f.length === r.length, v = 0; v < n.length; v++) {
                    var y = n[v];
                    this.vertices.push(r[y.a], r[y.b], r[y.c]);
                    var _ = y.vertexNormals;
                    if (3 === _.length) this.normals.push(_[0], _[1], _[2]);
                    else {
                        var x = y.normal;
                        this.normals.push(x, x, x)
                    }
                    var b = y.vertexColors;
                    if (3 === b.length) this.colors.push(b[0], b[1], b[2]);
                    else {
                        var w = y.color;
                        this.colors.push(w, w, w)
                    }
                    if (!0 === a && (void 0 !== (T = o[0][v]) ? this.uvs.push(T[0], T[1], T[2]) : (console.warn("THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ", v), this.uvs.push(new i, new i, new i))), !0 === s) {
                        var T = o[1][v];
                        void 0 !== T ? this.uvs2.push(T[0], T[1], T[2]) : (console.warn("THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ", v), this.uvs2.push(new i, new i, new i))
                    }
                    for (E = 0; E < c; E++) {
                        var S = l[E].vertices;
                        e[E].push(S[y.a], S[y.b], S[y.c])
                    }
                    for (var E = 0; E < d; E++) {
                        var M = h[E].vertexNormals[v];
                        u[E].push(M.a, M.b, M.c)
                    }
                    m && this.skinIndices.push(p[y.a], p[y.b], p[y.c]), g && this.skinWeights.push(f[y.a], f[y.b], f[y.c])
                }
                return this.computeGroups(t), this.verticesNeedUpdate = t.verticesNeedUpdate, this.normalsNeedUpdate = t.normalsNeedUpdate, this.colorsNeedUpdate = t.colorsNeedUpdate, this.uvsNeedUpdate = t.uvsNeedUpdate, this.groupsNeedUpdate = t.groupsNeedUpdate, this
            }
        });
        var os = 1;
        Object.assign(Mt.prototype, e.prototype, {
            isBufferGeometry: !0,
            getIndex: function() {
                return this.index
            },
            setIndex: function(t) {
                Array.isArray(t) ? this.index = new(Et(t) > 65535 ? bt : _t)(t, 1) : this.index = t
            },
            addAttribute: function(t, e) {
                return e && e.isBufferAttribute || e && e.isInterleavedBufferAttribute ? "index" === t ? (console.warn("THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute."), void this.setIndex(e)) : (this.attributes[t] = e, this) : (console.warn("THREE.BufferGeometry: .addAttribute() now expects ( name, attribute )."), void this.addAttribute(t, new ft(arguments[1], arguments[2])))
            },
            getAttribute: function(t) {
                return this.attributes[t]
            },
            removeAttribute: function(t) {
                return delete this.attributes[t], this
            },
            addGroup: function(t, e, i) {
                this.groups.push({
                    start: t,
                    count: e,
                    materialIndex: void 0 !== i ? i : 0
                })
            },
            clearGroups: function() {
                this.groups = []
            },
            setDrawRange: function(t, e) {
                this.drawRange.start = t, this.drawRange.count = e
            },
            applyMatrix: function(t) {
                var e = this.attributes.position;
                void 0 !== e && (t.applyToBufferAttribute(e), e.needsUpdate = !0);
                var i = this.attributes.normal;
                return void 0 !== i && ((new a).getNormalMatrix(t).applyToBufferAttribute(i), i.needsUpdate = !0), null !== this.boundingBox && this.computeBoundingBox(), null !== this.boundingSphere && this.computeBoundingSphere(), this
            },
            rotateX: function() {
                var t = new n;
                return function(e) {
                    return t.makeRotationX(e), this.applyMatrix(t), this
                }
            }(),
            rotateY: function() {
                var t = new n;
                return function(e) {
                    return t.makeRotationY(e), this.applyMatrix(t), this
                }
            }(),
            rotateZ: function() {
                var t = new n;
                return function(e) {
                    return t.makeRotationZ(e), this.applyMatrix(t), this
                }
            }(),
            translate: function() {
                var t = new n;
                return function(e, i, n) {
                    return t.makeTranslation(e, i, n), this.applyMatrix(t), this
                }
            }(),
            scale: function() {
                var t = new n;
                return function(e, i, n) {
                    return t.makeScale(e, i, n), this.applyMatrix(t), this
                }
            }(),
            lookAt: function() {
                var t = new ct;
                return function(e) {
                    t.lookAt(e), t.updateMatrix(), this.applyMatrix(t.matrix)
                }
            }(),
            center: function() {
                this.computeBoundingBox();
                var t = this.boundingBox.getCenter().negate();
                return this.translate(t.x, t.y, t.z), t
            },
            setFromObject: function(t) {
                var e = t.geometry;
                if (t.isPoints || t.isLine) {
                    var i = new wt(3 * e.vertices.length, 3),
                        n = new wt(3 * e.colors.length, 3);
                    if (this.addAttribute("position", i.copyVector3sArray(e.vertices)), this.addAttribute("color", n.copyColorsArray(e.colors)), e.lineDistances && e.lineDistances.length === e.vertices.length) {
                        var r = new wt(e.lineDistances.length, 1);
                        this.addAttribute("lineDistance", r.copyArray(e.lineDistances))
                    }
                    null !== e.boundingSphere && (this.boundingSphere = e.boundingSphere.clone()), null !== e.boundingBox && (this.boundingBox = e.boundingBox.clone())
                } else t.isMesh && e && e.isGeometry && this.fromGeometry(e);
                return this
            },
            setFromPoints: function(t) {
                for (var e = [], i = 0, n = t.length; i < n; i++) {
                    var r = t[i];
                    e.push(r.x, r.y, r.z || 0)
                }
                return this.addAttribute("position", new wt(e, 3)), this
            },
            updateFromObject: function(t) {
                var e = t.geometry;
                if (t.isMesh) {
                    var i = e.__directGeometry;
                    if (!0 === e.elementsNeedUpdate && (i = void 0, e.elementsNeedUpdate = !1), void 0 === i) return this.fromGeometry(e);
                    i.verticesNeedUpdate = e.verticesNeedUpdate, i.normalsNeedUpdate = e.normalsNeedUpdate, i.colorsNeedUpdate = e.colorsNeedUpdate, i.uvsNeedUpdate = e.uvsNeedUpdate, i.groupsNeedUpdate = e.groupsNeedUpdate, e.verticesNeedUpdate = !1, e.normalsNeedUpdate = !1, e.colorsNeedUpdate = !1, e.uvsNeedUpdate = !1, e.groupsNeedUpdate = !1, e = i
                }
                var n;
                return !0 === e.verticesNeedUpdate && (void 0 !== (n = this.attributes.position) && (n.copyVector3sArray(e.vertices), n.needsUpdate = !0), e.verticesNeedUpdate = !1), !0 === e.normalsNeedUpdate && (void 0 !== (n = this.attributes.normal) && (n.copyVector3sArray(e.normals), n.needsUpdate = !0), e.normalsNeedUpdate = !1), !0 === e.colorsNeedUpdate && (void 0 !== (n = this.attributes.color) && (n.copyColorsArray(e.colors), n.needsUpdate = !0), e.colorsNeedUpdate = !1), e.uvsNeedUpdate && (void 0 !== (n = this.attributes.uv) && (n.copyVector2sArray(e.uvs), n.needsUpdate = !0), e.uvsNeedUpdate = !1), e.lineDistancesNeedUpdate && (void 0 !== (n = this.attributes.lineDistance) && (n.copyArray(e.lineDistances), n.needsUpdate = !0), e.lineDistancesNeedUpdate = !1), e.groupsNeedUpdate && (e.computeGroups(t.geometry), this.groups = e.groups, e.groupsNeedUpdate = !1), this
            },
            fromGeometry: function(t) {
                return t.__directGeometry = (new St).fromGeometry(t), this.fromDirectGeometry(t.__directGeometry)
            },
            fromDirectGeometry: function(t) {
                var e = new Float32Array(3 * t.vertices.length);
                if (this.addAttribute("position", new ft(e, 3).copyVector3sArray(t.vertices)), t.normals.length > 0) {
                    var i = new Float32Array(3 * t.normals.length);
                    this.addAttribute("normal", new ft(i, 3).copyVector3sArray(t.normals))
                }
                if (t.colors.length > 0) {
                    var n = new Float32Array(3 * t.colors.length);
                    this.addAttribute("color", new ft(n, 3).copyColorsArray(t.colors))
                }
                if (t.uvs.length > 0) {
                    var r = new Float32Array(2 * t.uvs.length);
                    this.addAttribute("uv", new ft(r, 2).copyVector2sArray(t.uvs))
                }
                if (t.uvs2.length > 0) {
                    var o = new Float32Array(2 * t.uvs2.length);
                    this.addAttribute("uv2", new ft(o, 2).copyVector2sArray(t.uvs2))
                }
                if (t.indices.length > 0) {
                    var a = new(Et(t.indices) > 65535 ? Uint32Array : Uint16Array)(3 * t.indices.length);
                    this.setIndex(new ft(a, 1).copyIndicesArray(t.indices))
                }
                this.groups = t.groups;
                for (var s in t.morphTargets) {
                    for (var l = [], c = t.morphTargets[s], u = 0, h = c.length; u < h; u++) {
                        var d = c[u],
                            p = new wt(3 * d.length, 3);
                        l.push(p.copyVector3sArray(d))
                    }
                    this.morphAttributes[s] = l
                }
                if (t.skinIndices.length > 0) {
                    var f = new wt(4 * t.skinIndices.length, 4);
                    this.addAttribute("skinIndex", f.copyVector4sArray(t.skinIndices))
                }
                if (t.skinWeights.length > 0) {
                    var m = new wt(4 * t.skinWeights.length, 4);
                    this.addAttribute("skinWeight", m.copyVector4sArray(t.skinWeights))
                }
                return null !== t.boundingSphere && (this.boundingSphere = t.boundingSphere.clone()), null !== t.boundingBox && (this.boundingBox = t.boundingBox.clone()), this
            },
            computeBoundingBox: function() {
                null === this.boundingBox && (this.boundingBox = new et);
                var t = this.attributes.position;
                void 0 !== t ? this.boundingBox.setFromBufferAttribute(t) : this.boundingBox.makeEmpty(), (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox: Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this)
            },
            computeBoundingSphere: function() {
                var t = new et,
                    e = new o;
                return function() {
                    null === this.boundingSphere && (this.boundingSphere = new it);
                    var i = this.attributes.position;
                    if (i) {
                        var n = this.boundingSphere.center;
                        t.setFromBufferAttribute(i), t.getCenter(n);
                        for (var r = 0, o = 0, a = i.count; o < a; o++) e.x = i.getX(o), e.y = i.getY(o), e.z = i.getZ(o), r = Math.max(r, n.distanceToSquared(e));
                        this.boundingSphere.radius = Math.sqrt(r), isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this)
                    }
                }
            }(),
            computeFaceNormals: function() {},
            computeVertexNormals: function() {
                var t = this.index,
                    e = this.attributes,
                    i = this.groups;
                if (e.position) {
                    var n = e.position.array;
                    if (void 0 === e.normal) this.addAttribute("normal", new ft(new Float32Array(n.length), 3));
                    else
                        for (var r = e.normal.array, a = 0, s = r.length; a < s; a++) r[a] = 0;
                    var l, c, u, h = e.normal.array,
                        d = new o,
                        p = new o,
                        f = new o,
                        m = new o,
                        g = new o;
                    if (t) {
                        var v = t.array;
                        0 === i.length && this.addGroup(0, v.length);
                        for (var y = 0, _ = i.length; y < _; ++y)
                            for (var x = i[y], b = x.start, a = b, s = b + x.count; a < s; a += 3) l = 3 * v[a + 0], c = 3 * v[a + 1], u = 3 * v[a + 2], d.fromArray(n, l), p.fromArray(n, c), f.fromArray(n, u), m.subVectors(f, p), g.subVectors(d, p), m.cross(g), h[l] += m.x, h[l + 1] += m.y, h[l + 2] += m.z, h[c] += m.x, h[c + 1] += m.y, h[c + 2] += m.z, h[u] += m.x, h[u + 1] += m.y, h[u + 2] += m.z
                    } else
                        for (var a = 0, s = n.length; a < s; a += 9) d.fromArray(n, a), p.fromArray(n, a + 3), f.fromArray(n, a + 6), m.subVectors(f, p), g.subVectors(d, p), m.cross(g), h[a] = m.x, h[a + 1] = m.y, h[a + 2] = m.z, h[a + 3] = m.x, h[a + 4] = m.y, h[a + 5] = m.z, h[a + 6] = m.x, h[a + 7] = m.y, h[a + 8] = m.z;
                    this.normalizeNormals(), e.normal.needsUpdate = !0
                }
            },
            merge: function(t, e) {
                if (t && t.isBufferGeometry) {
                    void 0 === e && (e = 0);
                    var i = this.attributes;
                    for (var n in i)
                        if (void 0 !== t.attributes[n])
                            for (var r = i[n].array, o = t.attributes[n], a = o.array, s = 0, l = o.itemSize * e; s < a.length; s++, l++) r[l] = a[s];
                    return this
                }
                console.error("THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.", t)
            },
            normalizeNormals: function() {
                var t = new o;
                return function() {
                    for (var e = this.attributes.normal, i = 0, n = e.count; i < n; i++) t.x = e.getX(i), t.y = e.getY(i), t.z = e.getZ(i), t.normalize(), e.setXYZ(i, t.x, t.y, t.z)
                }
            }(),
            toNonIndexed: function() {
                if (null === this.index) return console.warn("THREE.BufferGeometry.toNonIndexed(): Geometry is already non-indexed."), this;
                var t = new Mt,
                    e = this.index.array,
                    i = this.attributes;
                for (var n in i) {
                    for (var r = i[n], o = r.array, a = r.itemSize, s = new o.constructor(e.length * a), l = 0, c = 0, u = 0, h = e.length; u < h; u++) {
                        l = e[u] * a;
                        for (var d = 0; d < a; d++) s[c++] = o[l++]
                    }
                    t.addAttribute(n, new ft(s, a))
                }
                return t
            },
            toJSON: function() {
                var t = {
                    metadata: {
                        version: 4.5,
                        type: "BufferGeometry",
                        generator: "BufferGeometry.toJSON"
                    }
                };
                if (t.uuid = this.uuid, t.type = this.type, "" !== this.name && (t.name = this.name), void 0 !== this.parameters) {
                    var e = this.parameters;
                    for (var i in e) void 0 !== e[i] && (t[i] = e[i]);
                    return t
                }
                t.data = {
                    attributes: {}
                };
                var n = this.index;
                if (null !== n) {
                    a = Array.prototype.slice.call(n.array);
                    t.data.index = {
                        type: n.array.constructor.name,
                        array: a
                    }
                }
                var r = this.attributes;
                for (var i in r) {
                    var o = r[i],
                        a = Array.prototype.slice.call(o.array);
                    t.data.attributes[i] = {
                        itemSize: o.itemSize,
                        type: o.array.constructor.name,
                        array: a,
                        normalized: o.normalized
                    }
                }
                var s = this.groups;
                s.length > 0 && (t.data.groups = JSON.parse(JSON.stringify(s)));
                var l = this.boundingSphere;
                return null !== l && (t.data.boundingSphere = {
                    center: l.center.toArray(),
                    radius: l.radius
                }), t
            },
            clone: function() {
                return (new Mt).copy(this)
            },
            copy: function(t) {
                var e, i, n;
                this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingBox = null, this.boundingSphere = null, this.name = t.name;
                var r = t.index;
                null !== r && this.setIndex(r.clone());
                var o = t.attributes;
                for (e in o) {
                    var a = o[e];
                    this.addAttribute(e, a.clone())
                }
                var s = t.morphAttributes;
                for (e in s) {
                    var l = [],
                        c = s[e];
                    for (i = 0, n = c.length; i < n; i++) l.push(c[i].clone());
                    this.morphAttributes[e] = l
                }
                var u = t.groups;
                for (i = 0, n = u.length; i < n; i++) {
                    var h = u[i];
                    this.addGroup(h.start, h.count, h.materialIndex)
                }
                var d = t.boundingBox;
                null !== d && (this.boundingBox = d.clone());
                var p = t.boundingSphere;
                return null !== p && (this.boundingSphere = p.clone()), this.drawRange.start = t.drawRange.start, this.drawRange.count = t.drawRange.count, this
            },
            dispose: function() {
                this.dispatchEvent({
                    type: "dispose"
                })
            }
        }), (At.prototype = Object.create(pt.prototype)).constructor = At, Lt.prototype = Object.create(Mt.prototype), Lt.prototype.constructor = Lt, (Ct.prototype = Object.create(pt.prototype)).constructor = Ct, Pt.prototype = Object.create(Mt.prototype), Pt.prototype.constructor = Pt, Rt.prototype = Object.create($.prototype), Rt.prototype.constructor = Rt, Rt.prototype.isMeshBasicMaterial = !0, Rt.prototype.copy = function(t) {
            return $.prototype.copy.call(this, t), this.color.copy(t.color), this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.specularMap = t.specularMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.combine = t.combine, this.reflectivity = t.reflectivity, this.refractionRatio = t.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this
        }, Ot.prototype = Object.create($.prototype), Ot.prototype.constructor = Ot, Ot.prototype.isShaderMaterial = !0, Ot.prototype.copy = function(t) {
            return $.prototype.copy.call(this, t), this.fragmentShader = t.fragmentShader, this.vertexShader = t.vertexShader, this.uniforms = Ka.clone(t.uniforms), this.defines = t.defines, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.lights = t.lights, this.clipping = t.clipping, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this.extensions = t.extensions, this
        }, Ot.prototype.toJSON = function(t) {
            var e = $.prototype.toJSON.call(this, t);
            return e.uniforms = this.uniforms, e.vertexShader = this.vertexShader, e.fragmentShader = this.fragmentShader, e
        }, Object.assign(It.prototype, {
            set: function(t, e) {
                return this.origin.copy(t), this.direction.copy(e), this
            },
            clone: function() {
                return (new this.constructor).copy(this)
            },
            copy: function(t) {
                return this.origin.copy(t.origin), this.direction.copy(t.direction), this
            },
            at: function(t, e) {
                return (e || new o).copy(this.direction).multiplyScalar(t).add(this.origin)
            },
            lookAt: function(t) {
                return this.direction.copy(t).sub(this.origin).normalize(), this
            },
            recast: function() {
                var t = new o;
                return function(e) {
                    return this.origin.copy(this.at(e, t)), this
                }
            }(),
            closestPointToPoint: function(t, e) {
                var i = e || new o;
                i.subVectors(t, this.origin);
                var n = i.dot(this.direction);
                return n < 0 ? i.copy(this.origin) : i.copy(this.direction).multiplyScalar(n).add(this.origin)
            },
            distanceToPoint: function(t) {
                return Math.sqrt(this.distanceSqToPoint(t))
            },
            distanceSqToPoint: function() {
                var t = new o;
                return function(e) {
                    var i = t.subVectors(e, this.origin).dot(this.direction);
                    return i < 0 ? this.origin.distanceToSquared(e) : (t.copy(this.direction).multiplyScalar(i).add(this.origin), t.distanceToSquared(e))
                }
            }(),
            distanceSqToSegment: function() {
                var t = new o,
                    e = new o,
                    i = new o;
                return function(n, r, o, a) {
                    t.copy(n).add(r).multiplyScalar(.5), e.copy(r).sub(n).normalize(), i.copy(this.origin).sub(t);
                    var s, l, c, u, h = .5 * n.distanceTo(r),
                        d = -this.direction.dot(e),
                        p = i.dot(this.direction),
                        f = -i.dot(e),
                        m = i.lengthSq(),
                        g = Math.abs(1 - d * d);
                    if (g > 0)
                        if (s = d * f - p, l = d * p - f, u = h * g, s >= 0)
                            if (l >= -u)
                                if (l <= u) {
                                    var v = 1 / g;
                                    c = (s *= v) * (s + d * (l *= v) + 2 * p) + l * (d * s + l + 2 * f) + m
                                } else l = h, c = -(s = Math.max(0, -(d * l + p))) * s + l * (l + 2 * f) + m;
                    else l = -h, c = -(s = Math.max(0, -(d * l + p))) * s + l * (l + 2 * f) + m;
                    else l <= -u ? c = -(s = Math.max(0, -(-d * h + p))) * s + (l = s > 0 ? -h : Math.min(Math.max(-h, -f), h)) * (l + 2 * f) + m : l <= u ? (s = 0, c = (l = Math.min(Math.max(-h, -f), h)) * (l + 2 * f) + m) : c = -(s = Math.max(0, -(d * h + p))) * s + (l = s > 0 ? h : Math.min(Math.max(-h, -f), h)) * (l + 2 * f) + m;
                    else l = d > 0 ? -h : h, c = -(s = Math.max(0, -(d * l + p))) * s + l * (l + 2 * f) + m;
                    return o && o.copy(this.direction).multiplyScalar(s).add(this.origin), a && a.copy(e).multiplyScalar(l).add(t), c
                }
            }(),
            intersectSphere: function() {
                var t = new o;
                return function(e, i) {
                    t.subVectors(e.center, this.origin);
                    var n = t.dot(this.direction),
                        r = t.dot(t) - n * n,
                        o = e.radius * e.radius;
                    if (r > o) return null;
                    var a = Math.sqrt(o - r),
                        s = n - a,
                        l = n + a;
                    return s < 0 && l < 0 ? null : s < 0 ? this.at(l, i) : this.at(s, i)
                }
            }(),
            intersectsSphere: function(t) {
                return this.distanceToPoint(t.center) <= t.radius
            },
            distanceToPlane: function(t) {
                var e = t.normal.dot(this.direction);
                if (0 === e) return 0 === t.distanceToPoint(this.origin) ? 0 : null;
                var i = -(this.origin.dot(t.normal) + t.constant) / e;
                return i >= 0 ? i : null
            },
            intersectPlane: function(t, e) {
                var i = this.distanceToPlane(t);
                return null === i ? null : this.at(i, e)
            },
            intersectsPlane: function(t) {
                var e = t.distanceToPoint(this.origin);
                return 0 === e || t.normal.dot(this.direction) * e < 0
            },
            intersectBox: function(t, e) {
                var i, n, r, o, a, s, l = 1 / this.direction.x,
                    c = 1 / this.direction.y,
                    u = 1 / this.direction.z,
                    h = this.origin;
                return l >= 0 ? (i = (t.min.x - h.x) * l, n = (t.max.x - h.x) * l) : (i = (t.max.x - h.x) * l, n = (t.min.x - h.x) * l), c >= 0 ? (r = (t.min.y - h.y) * c, o = (t.max.y - h.y) * c) : (r = (t.max.y - h.y) * c, o = (t.min.y - h.y) * c), i > o || r > n ? null : ((r > i || i !== i) && (i = r), (o < n || n !== n) && (n = o), u >= 0 ? (a = (t.min.z - h.z) * u, s = (t.max.z - h.z) * u) : (a = (t.max.z - h.z) * u, s = (t.min.z - h.z) * u), i > s || a > n ? null : ((a > i || i !== i) && (i = a), (s < n || n !== n) && (n = s), n < 0 ? null : this.at(i >= 0 ? i : n, e)))
            },
            intersectsBox: function() {
                var t = new o;
                return function(e) {
                    return null !== this.intersectBox(e, t)
                }
            }(),
            intersectTriangle: function() {
                var t = new o,
                    e = new o,
                    i = new o,
                    n = new o;
                return function(r, o, a, s, l) {
                    e.subVectors(o, r), i.subVectors(a, r), n.crossVectors(e, i);
                    var c, u = this.direction.dot(n);
                    if (u > 0) {
                        if (s) return null;
                        c = 1
                    } else {
                        if (!(u < 0)) return null;
                        c = -1, u = -u
                    }
                    t.subVectors(this.origin, r);
                    var h = c * this.direction.dot(i.crossVectors(t, i));
                    if (h < 0) return null;
                    var d = c * this.direction.dot(e.cross(t));
                    if (d < 0) return null;
                    if (h + d > u) return null;
                    var p = -c * t.dot(n);
                    return p < 0 ? null : this.at(p / u, l)
                }
            }(),
            applyMatrix4: function(t) {
                return this.origin.applyMatrix4(t), this.direction.transformDirection(t), this
            },
            equals: function(t) {
                return t.origin.equals(this.origin) && t.direction.equals(this.direction)
            }
        }), Object.assign(Dt.prototype, {
            set: function(t, e) {
                return this.start.copy(t), this.end.copy(e), this
            },
            clone: function() {
                return (new this.constructor).copy(this)
            },
            copy: function(t) {
                return this.start.copy(t.start), this.end.copy(t.end), this
            },
            getCenter: function(t) {
                return (t || new o).addVectors(this.start, this.end).multiplyScalar(.5)
            },
            delta: function(t) {
                return (t || new o).subVectors(this.end, this.start)
            },
            distanceSq: function() {
                return this.start.distanceToSquared(this.end)
            },
            distance: function() {
                return this.start.distanceTo(this.end)
            },
            at: function(t, e) {
                var i = e || new o;
                return this.delta(i).multiplyScalar(t).add(this.start)
            },
            closestPointToPointParameter: function() {
                var t = new o,
                    e = new o;
                return function(i, n) {
                    t.subVectors(i, this.start), e.subVectors(this.end, this.start);
                    var r = e.dot(e),
                        o = e.dot(t) / r;
                    return n && (o = Ha.clamp(o, 0, 1)), o
                }
            }(),
            closestPointToPoint: function(t, e, i) {
                var n = this.closestPointToPointParameter(t, e),
                    r = i || new o;
                return this.delta(r).multiplyScalar(n).add(this.start)
            },
            applyMatrix4: function(t) {
                return this.start.applyMatrix4(t), this.end.applyMatrix4(t), this
            },
            equals: function(t) {
                return t.start.equals(this.start) && t.end.equals(this.end)
            }
        }), Object.assign(Nt, {
            normal: function() {
                var t = new o;
                return function(e, i, n, r) {
                    var a = r || new o;
                    a.subVectors(n, i), t.subVectors(e, i), a.cross(t);
                    var s = a.lengthSq();
                    return s > 0 ? a.multiplyScalar(1 / Math.sqrt(s)) : a.set(0, 0, 0)
                }
            }(),
            barycoordFromPoint: function() {
                var t = new o,
                    e = new o,
                    i = new o;
                return function(n, r, a, s, l) {
                    t.subVectors(s, r), e.subVectors(a, r), i.subVectors(n, r);
                    var c = t.dot(t),
                        u = t.dot(e),
                        h = t.dot(i),
                        d = e.dot(e),
                        p = e.dot(i),
                        f = c * d - u * u,
                        m = l || new o;
                    if (0 === f) return m.set(-2, -1, -1);
                    var g = 1 / f,
                        v = (d * h - u * p) * g,
                        y = (c * p - u * h) * g;
                    return m.set(1 - v - y, y, v)
                }
            }(),
            containsPoint: function() {
                var t = new o;
                return function(e, i, n, r) {
                    var o = Nt.barycoordFromPoint(e, i, n, r, t);
                    return o.x >= 0 && o.y >= 0 && o.x + o.y <= 1
                }
            }()
        }), Object.assign(Nt.prototype, {
            set: function(t, e, i) {
                return this.a.copy(t), this.b.copy(e), this.c.copy(i), this
            },
            setFromPointsAndIndices: function(t, e, i, n) {
                return this.a.copy(t[e]), this.b.copy(t[i]), this.c.copy(t[n]), this
            },
            clone: function() {
                return (new this.constructor).copy(this)
            },
            copy: function(t) {
                return this.a.copy(t.a), this.b.copy(t.b), this.c.copy(t.c), this
            },
            area: function() {
                var t = new o,
                    e = new o;
                return function() {
                    return t.subVectors(this.c, this.b), e.subVectors(this.a, this.b), .5 * t.cross(e).length()
                }
            }(),
            midpoint: function(t) {
                return (t || new o).addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3)
            },
            normal: function(t) {
                return Nt.normal(this.a, this.b, this.c, t)
            },
            plane: function(t) {
                return (t || new nt).setFromCoplanarPoints(this.a, this.b, this.c)
            },
            barycoordFromPoint: function(t, e) {
                return Nt.barycoordFromPoint(t, this.a, this.b, this.c, e)
            },
            containsPoint: function(t) {
                return Nt.containsPoint(t, this.a, this.b, this.c)
            },
            closestPointToPoint: function() {
                var t = new nt,
                    e = [new Dt, new Dt, new Dt],
                    i = new o,
                    n = new o;
                return function(r, a) {
                    var s = a || new o,
                        l = 1 / 0;
                    if (t.setFromCoplanarPoints(this.a, this.b, this.c), t.projectPoint(r, i), !0 === this.containsPoint(i)) s.copy(i);
                    else {
                        e[0].set(this.a, this.b), e[1].set(this.b, this.c), e[2].set(this.c, this.a);
                        for (var c = 0; c < e.length; c++) {
                            e[c].closestPointToPoint(i, !0, n);
                            var u = i.distanceToSquared(n);
                            u < l && (l = u, s.copy(n))
                        }
                    }
                    return s
                }
            }(),
            equals: function(t) {
                return t.a.equals(this.a) && t.b.equals(this.b) && t.c.equals(this.c)
            }
        }), Ft.prototype = Object.assign(Object.create(ct.prototype), {
            constructor: Ft,
            isMesh: !0,
            setDrawMode: function(t) {
                this.drawMode = t
            },
            copy: function(t) {
                return ct.prototype.copy.call(this, t), this.drawMode = t.drawMode, void 0 !== t.morphTargetInfluences && (this.morphTargetInfluences = t.morphTargetInfluences.slice()), void 0 !== t.morphTargetDictionary && (this.morphTargetDictionary = Object.assign({}, t.morphTargetDictionary)), this
            },
            updateMorphTargets: function() {
                var t, e, i, n = this.geometry;
                if (n.isBufferGeometry) {
                    var r = n.morphAttributes,
                        o = Object.keys(r);
                    if (o.length > 0) {
                        var a = r[o[0]];
                        if (void 0 !== a)
                            for (this.morphTargetInfluences = [], this.morphTargetDictionary = {}, t = 0, e = a.length; t < e; t++) i = a[t].name || String(t), this.morphTargetInfluences.push(0), this.morphTargetDictionary[i] = t
                    }
                } else {
                    var s = n.morphTargets;
                    if (void 0 !== s && s.length > 0)
                        for (this.morphTargetInfluences = [], this.morphTargetDictionary = {}, t = 0, e = s.length; t < e; t++) i = s[t].name || String(t), this.morphTargetInfluences.push(0), this.morphTargetDictionary[i] = t
                }
            },
            raycast: function() {
                function t(t, e, i, n, r, o, a) {
                    return Nt.barycoordFromPoint(t, e, i, n, y), r.multiplyScalar(y.x), o.multiplyScalar(y.y), a.multiplyScalar(y.z), r.add(o).add(a), r.clone()
                }

                function e(t, e, i, n, r, o, a, s) {
                    if (null === (e.side === qr ? n.intersectTriangle(a, o, r, !0, s) : n.intersectTriangle(r, o, a, e.side !== Yr, s))) return null;
                    x.copy(s), x.applyMatrix4(t.matrixWorld);
                    var l = i.ray.origin.distanceTo(x);
                    return l < i.near || l > i.far ? null : {
                        distance: l,
                        point: x.clone(),
                        object: t
                    }
                }

                function r(i, n, r, o, a, s, l, d) {
                    c.fromBufferAttribute(o, s), u.fromBufferAttribute(o, l), h.fromBufferAttribute(o, d);
                    var p = e(i, i.material, n, r, c, u, h, _);
                    return p && (a && (m.fromBufferAttribute(a, s), g.fromBufferAttribute(a, l), v.fromBufferAttribute(a, d), p.uv = t(_, c, u, h, m, g, v)), p.face = new dt(s, l, d, Nt.normal(c, u, h)), p.faceIndex = s), p
                }
                var a = new n,
                    s = new It,
                    l = new it,
                    c = new o,
                    u = new o,
                    h = new o,
                    d = new o,
                    p = new o,
                    f = new o,
                    m = new i,
                    g = new i,
                    v = new i,
                    y = new o,
                    _ = new o,
                    x = new o;
                return function(i, n) {
                    var o = this.geometry,
                        y = this.material,
                        x = this.matrixWorld;
                    if (void 0 !== y && (null === o.boundingSphere && o.computeBoundingSphere(), l.copy(o.boundingSphere), l.applyMatrix4(x), !1 !== i.ray.intersectsSphere(l) && (a.getInverse(x), s.copy(i.ray).applyMatrix4(a), null === o.boundingBox || !1 !== s.intersectsBox(o.boundingBox)))) {
                        var b;
                        if (o.isBufferGeometry) {
                            var w, T, S, E, M, A = o.index,
                                L = o.attributes.position,
                                C = o.attributes.uv;
                            if (null !== A)
                                for (E = 0, M = A.count; E < M; E += 3) w = A.getX(E), T = A.getX(E + 1), S = A.getX(E + 2), (b = r(this, i, s, L, C, w, T, S)) && (b.faceIndex = Math.floor(E / 3), n.push(b));
                            else if (void 0 !== L)
                                for (E = 0, M = L.count; E < M; E += 3)(b = r(this, i, s, L, C, w = E, T = E + 1, S = E + 2)) && (b.index = w, n.push(b))
                        } else if (o.isGeometry) {
                            var P, R, O, I, D = Array.isArray(y),
                                N = o.vertices,
                                F = o.faces,
                                k = o.faceVertexUvs[0];
                            k.length > 0 && (I = k);
                            for (var U = 0, B = F.length; U < B; U++) {
                                var z = F[U],
                                    j = D ? y[z.materialIndex] : y;
                                if (void 0 !== j) {
                                    if (P = N[z.a], R = N[z.b], O = N[z.c], !0 === j.morphTargets) {
                                        var H = o.morphTargets,
                                            G = this.morphTargetInfluences;
                                        c.set(0, 0, 0), u.set(0, 0, 0), h.set(0, 0, 0);
                                        for (var V = 0, W = H.length; V < W; V++) {
                                            var X = G[V];
                                            if (0 !== X) {
                                                var q = H[V].vertices;
                                                c.addScaledVector(d.subVectors(q[z.a], P), X), u.addScaledVector(p.subVectors(q[z.b], R), X), h.addScaledVector(f.subVectors(q[z.c], O), X)
                                            }
                                        }
                                        c.add(P), u.add(R), h.add(O), P = c, R = u, O = h
                                    }
                                    if (b = e(this, j, i, s, P, R, O, _)) {
                                        if (I && I[U]) {
                                            var Y = I[U];
                                            m.copy(Y[0]), g.copy(Y[1]), v.copy(Y[2]), b.uv = t(_, P, R, O, m, g, v)
                                        }
                                        b.face = z, b.faceIndex = U, n.push(b)
                                    }
                                }
                            }
                        }
                    }
                }
            }(),
            clone: function() {
                return new this.constructor(this.geometry, this.material).copy(this)
            }
        });
        var as = 0;
        me.prototype = Object.assign(Object.create(ut.prototype), {
            constructor: me,
            isPerspectiveCamera: !0,
            copy: function(t, e) {
                return ut.prototype.copy.call(this, t, e), this.fov = t.fov, this.zoom = t.zoom, this.near = t.near, this.far = t.far, this.focus = t.focus, this.aspect = t.aspect, this.view = null === t.view ? null : Object.assign({}, t.view), this.filmGauge = t.filmGauge, this.filmOffset = t.filmOffset, this
            },
            setFocalLength: function(t) {
                var e = .5 * this.getFilmHeight() / t;
                this.fov = 2 * Ha.RAD2DEG * Math.atan(e), this.updateProjectionMatrix()
            },
            getFocalLength: function() {
                var t = Math.tan(.5 * Ha.DEG2RAD * this.fov);
                return .5 * this.getFilmHeight() / t
            },
            getEffectiveFOV: function() {
                return 2 * Ha.RAD2DEG * Math.atan(Math.tan(.5 * Ha.DEG2RAD * this.fov) / this.zoom)
            },
            getFilmWidth: function() {
                return this.filmGauge * Math.min(this.aspect, 1)
            },
            getFilmHeight: function() {
                return this.filmGauge / Math.max(this.aspect, 1)
            },
            setViewOffset: function(t, e, i, n, r, o) {
                this.aspect = t / e, null === this.view && (this.view = {
                    enabled: !0,
                    fullWidth: 1,
                    fullHeight: 1,
                    offsetX: 0,
                    offsetY: 0,
                    width: 1,
                    height: 1
                }), this.view.enabled = !0, this.view.fullWidth = t, this.view.fullHeight = e, this.view.offsetX = i, this.view.offsetY = n, this.view.width = r, this.view.height = o, this.updateProjectionMatrix()
            },
            clearViewOffset: function() {
                null !== this.view && (this.view.enabled = !1), this.updateProjectionMatrix()
            },
            updateProjectionMatrix: function() {
                var t = this.near,
                    e = t * Math.tan(.5 * Ha.DEG2RAD * this.fov) / this.zoom,
                    i = 2 * e,
                    n = this.aspect * i,
                    r = -.5 * n,
                    o = this.view;
                if (null !== this.view && this.view.enabled) {
                    var a = o.fullWidth,
                        s = o.fullHeight;
                    r += o.offsetX * n / a, e -= o.offsetY * i / s, n *= o.width / a, i *= o.height / s
                }
                var l = this.filmOffset;
                0 !== l && (r += t * l / this.getFilmWidth()), this.projectionMatrix.makePerspective(r, r + n, e, e - i, t, this.far)
            },
            toJSON: function(t) {
                var e = ct.prototype.toJSON.call(this, t);
                return e.object.fov = this.fov, e.object.zoom = this.zoom, e.object.near = this.near, e.object.far = this.far, e.object.focus = this.focus, e.object.aspect = this.aspect, null !== this.view && (e.object.view = Object.assign({}, this.view)), e.object.filmGauge = this.filmGauge, e.object.filmOffset = this.filmOffset, e
            }
        }), ge.prototype = Object.assign(Object.create(me.prototype), {
            constructor: ge,
            isArrayCamera: !0
        }), we.prototype.isFogExp2 = !0, we.prototype.clone = function() {
            return new we(this.color.getHex(), this.density)
        }, we.prototype.toJSON = function() {
            return {
                type: "FogExp2",
                color: this.color.getHex(),
                density: this.density
            }
        }, Te.prototype.isFog = !0, Te.prototype.clone = function() {
            return new Te(this.color.getHex(), this.near, this.far)
        }, Te.prototype.toJSON = function() {
            return {
                type: "Fog",
                color: this.color.getHex(),
                near: this.near,
                far: this.far
            }
        }, Se.prototype = Object.assign(Object.create(ct.prototype), {
            constructor: Se,
            copy: function(t, e) {
                return ct.prototype.copy.call(this, t, e), null !== t.background && (this.background = t.background.clone()), null !== t.fog && (this.fog = t.fog.clone()), null !== t.overrideMaterial && (this.overrideMaterial = t.overrideMaterial.clone()), this.autoUpdate = t.autoUpdate, this.matrixAutoUpdate = t.matrixAutoUpdate, this
            },
            toJSON: function(t) {
                var e = ct.prototype.toJSON.call(this, t);
                return null !== this.background && (e.object.background = this.background.toJSON(t)), null !== this.fog && (e.object.fog = this.fog.toJSON()), e
            }
        }), Ee.prototype = Object.assign(Object.create(ct.prototype), {
            constructor: Ee,
            isLensFlare: !0,
            copy: function(t) {
                ct.prototype.copy.call(this, t), this.positionScreen.copy(t.positionScreen), this.customUpdateCallback = t.customUpdateCallback;
                for (var e = 0, i = t.lensFlares.length; e < i; e++) this.lensFlares.push(t.lensFlares[e]);
                return this
            },
            add: function(t, e, i, n, r, o) {
                void 0 === e && (e = -1), void 0 === i && (i = 0), void 0 === o && (o = 1), void 0 === r && (r = new q(16777215)), void 0 === n && (n = Kr), i = Math.min(i, Math.max(0, i)), this.lensFlares.push({
                    texture: t,
                    size: e,
                    distance: i,
                    x: 0,
                    y: 0,
                    z: 0,
                    scale: 1,
                    rotation: 0,
                    opacity: o,
                    color: r,
                    blending: n
                })
            },
            updateLensFlares: function() {
                var t, e, i = this.lensFlares.length,
                    n = 2 * -this.positionScreen.x,
                    r = 2 * -this.positionScreen.y;
                for (t = 0; t < i; t++)(e = this.lensFlares[t]).x = this.positionScreen.x + n * e.distance, e.y = this.positionScreen.y + r * e.distance, e.wantedRotation = e.x * Math.PI * .25, e.rotation += .25 * (e.wantedRotation - e.rotation)
            }
        }), Me.prototype = Object.create($.prototype), Me.prototype.constructor = Me, Me.prototype.isSpriteMaterial = !0, Me.prototype.copy = function(t) {
            return $.prototype.copy.call(this, t), this.color.copy(t.color), this.map = t.map, this.rotation = t.rotation, this
        }, Ae.prototype = Object.assign(Object.create(ct.prototype), {
            constructor: Ae,
            isSprite: !0,
            raycast: function() {
                var t = new o,
                    e = new o,
                    i = new o;
                return function(n, r) {
                    e.setFromMatrixPosition(this.matrixWorld), n.ray.closestPointToPoint(e, t), i.setFromMatrixScale(this.matrixWorld);
                    var o = i.x * i.y / 4;
                    if (!(e.distanceToSquared(t) > o)) {
                        var a = n.ray.origin.distanceTo(t);
                        a < n.near || a > n.far || r.push({
                            distance: a,
                            point: t.clone(),
                            face: null,
                            object: this
                        })
                    }
                }
            }(),
            clone: function() {
                return new this.constructor(this.material).copy(this)
            }
        }), Le.prototype = Object.assign(Object.create(ct.prototype), {
            constructor: Le,
            copy: function(t) {
                ct.prototype.copy.call(this, t, !1);
                for (var e = t.levels, i = 0, n = e.length; i < n; i++) {
                    var r = e[i];
                    this.addLevel(r.object.clone(), r.distance)
                }
                return this
            },
            addLevel: function(t, e) {
                void 0 === e && (e = 0), e = Math.abs(e);
                for (var i = this.levels, n = 0; n < i.length && !(e < i[n].distance); n++);
                i.splice(n, 0, {
                    distance: e,
                    object: t
                }), this.add(t)
            },
            getObjectForDistance: function(t) {
                for (var e = this.levels, i = 1, n = e.length; i < n && !(t < e[i].distance); i++);
                return e[i - 1].object
            },
            raycast: function() {
                var t = new o;
                return function(e, i) {
                    t.setFromMatrixPosition(this.matrixWorld);
                    var n = e.ray.origin.distanceTo(t);
                    this.getObjectForDistance(n).raycast(e, i)
                }
            }(),
            update: function() {
                var t = new o,
                    e = new o;
                return function(i) {
                    var n = this.levels;
                    if (n.length > 1) {
                        t.setFromMatrixPosition(i.matrixWorld), e.setFromMatrixPosition(this.matrixWorld);
                        var r = t.distanceTo(e);
                        n[0].object.visible = !0;
                        for (var o = 1, a = n.length; o < a && r >= n[o].distance; o++) n[o - 1].object.visible = !1, n[o].object.visible = !0;
                        for (; o < a; o++) n[o].object.visible = !1
                    }
                }
            }(),
            toJSON: function(t) {
                var e = ct.prototype.toJSON.call(this, t);
                e.object.levels = [];
                for (var i = this.levels, n = 0, r = i.length; n < r; n++) {
                    var o = i[n];
                    e.object.levels.push({
                        object: o.object.uuid,
                        distance: o.distance
                    })
                }
                return e
            }
        }), Object.assign(Ce.prototype, {
            calculateInverses: function() {
                this.boneInverses = [];
                for (var t = 0, e = this.bones.length; t < e; t++) {
                    var i = new n;
                    this.bones[t] && i.getInverse(this.bones[t].matrixWorld), this.boneInverses.push(i)
                }
            },
            pose: function() {
                var t, e, i;
                for (e = 0, i = this.bones.length; e < i; e++)(t = this.bones[e]) && t.matrixWorld.getInverse(this.boneInverses[e]);
                for (e = 0, i = this.bones.length; e < i; e++)(t = this.bones[e]) && (t.parent && t.parent.isBone ? (t.matrix.getInverse(t.parent.matrixWorld), t.matrix.multiply(t.matrixWorld)) : t.matrix.copy(t.matrixWorld), t.matrix.decompose(t.position, t.quaternion, t.scale))
            },
            update: function() {
                var t = new n,
                    e = new n;
                return function() {
                    for (var i = this.bones, n = this.boneInverses, r = this.boneMatrices, o = this.boneTexture, a = 0, s = i.length; a < s; a++) {
                        var l = i[a] ? i[a].matrixWorld : e;
                        t.multiplyMatrices(l, n[a]), t.toArray(r, 16 * a)
                    }
                    void 0 !== o && (o.needsUpdate = !0)
                }
            }(),
            clone: function() {
                return new Ce(this.bones, this.boneInverses)
            }
        }), Pe.prototype = Object.assign(Object.create(ct.prototype), {
            constructor: Pe,
            isBone: !0
        }), Re.prototype = Object.assign(Object.create(Ft.prototype), {
            constructor: Re,
            isSkinnedMesh: !0,
            initBones: function() {
                var t, e, i, n, r = [];
                if (this.geometry && void 0 !== this.geometry.bones) {
                    for (i = 0, n = this.geometry.bones.length; i < n; i++) e = this.geometry.bones[i], t = new Pe, r.push(t), t.name = e.name, t.position.fromArray(e.pos), t.quaternion.fromArray(e.rotq), void 0 !== e.scl && t.scale.fromArray(e.scl);
                    for (i = 0, n = this.geometry.bones.length; i < n; i++) - 1 !== (e = this.geometry.bones[i]).parent && null !== e.parent && void 0 !== r[e.parent] ? r[e.parent].add(r[i]) : this.add(r[i])
                }
                return this.updateMatrixWorld(!0), r
            },
            bind: function(t, e) {
                this.skeleton = t, void 0 === e && (this.updateMatrixWorld(!0), this.skeleton.calculateInverses(), e = this.matrixWorld), this.bindMatrix.copy(e), this.bindMatrixInverse.getInverse(e)
            },
            pose: function() {
                this.skeleton.pose()
            },
            normalizeSkinWeights: function() {
                var t, e;
                if (this.geometry && this.geometry.isGeometry)
                    for (e = 0; e < this.geometry.skinWeights.length; e++) {
                        var i = this.geometry.skinWeights[e];
                        (t = 1 / i.manhattanLength()) !== 1 / 0 ? i.multiplyScalar(t) : i.set(1, 0, 0, 0)
                    } else if (this.geometry && this.geometry.isBufferGeometry) {
                        var n = new l,
                            r = this.geometry.attributes.skinWeight;
                        for (e = 0; e < r.count; e++) n.x = r.getX(e), n.y = r.getY(e), n.z = r.getZ(e), n.w = r.getW(e), (t = 1 / n.manhattanLength()) !== 1 / 0 ? n.multiplyScalar(t) : n.set(1, 0, 0, 0), r.setXYZW(e, n.x, n.y, n.z, n.w)
                    }
            },
            updateMatrixWorld: function(t) {
                Ft.prototype.updateMatrixWorld.call(this, t), "attached" === this.bindMode ? this.bindMatrixInverse.getInverse(this.matrixWorld) : "detached" === this.bindMode ? this.bindMatrixInverse.getInverse(this.bindMatrix) : console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode)
            },
            clone: function() {
                return new this.constructor(this.geometry, this.material).copy(this)
            }
        }), Oe.prototype = Object.create($.prototype), Oe.prototype.constructor = Oe, Oe.prototype.isLineBasicMaterial = !0, Oe.prototype.copy = function(t) {
            return $.prototype.copy.call(this, t), this.color.copy(t.color), this.linewidth = t.linewidth, this.linecap = t.linecap, this.linejoin = t.linejoin, this
        }, Ie.prototype = Object.assign(Object.create(ct.prototype), {
            constructor: Ie,
            isLine: !0,
            raycast: function() {
                var t = new n,
                    e = new It,
                    i = new it;
                return function(n, r) {
                    var a = n.linePrecision,
                        s = a * a,
                        l = this.geometry,
                        c = this.matrixWorld;
                    if (null === l.boundingSphere && l.computeBoundingSphere(), i.copy(l.boundingSphere), i.applyMatrix4(c), !1 !== n.ray.intersectsSphere(i)) {
                        t.getInverse(c), e.copy(n.ray).applyMatrix4(t);
                        var u = new o,
                            h = new o,
                            d = new o,
                            p = new o,
                            f = this && this.isLineSegments ? 2 : 1;
                        if (l.isBufferGeometry) {
                            var m = l.index,
                                g = l.attributes.position.array;
                            if (null !== m)
                                for (var v = m.array, y = 0, _ = v.length - 1; y < _; y += f) {
                                    var x = v[y],
                                        b = v[y + 1];
                                    u.fromArray(g, 3 * x), h.fromArray(g, 3 * b), (S = e.distanceSqToSegment(u, h, p, d)) > s || (p.applyMatrix4(this.matrixWorld), (E = n.ray.origin.distanceTo(p)) < n.near || E > n.far || r.push({
                                        distance: E,
                                        point: d.clone().applyMatrix4(this.matrixWorld),
                                        index: y,
                                        face: null,
                                        faceIndex: null,
                                        object: this
                                    }))
                                } else
                                    for (var y = 0, _ = g.length / 3 - 1; y < _; y += f) u.fromArray(g, 3 * y), h.fromArray(g, 3 * y + 3), (S = e.distanceSqToSegment(u, h, p, d)) > s || (p.applyMatrix4(this.matrixWorld), (E = n.ray.origin.distanceTo(p)) < n.near || E > n.far || r.push({
                                        distance: E,
                                        point: d.clone().applyMatrix4(this.matrixWorld),
                                        index: y,
                                        face: null,
                                        faceIndex: null,
                                        object: this
                                    }))
                        } else if (l.isGeometry)
                            for (var w = l.vertices, T = w.length, y = 0; y < T - 1; y += f) {
                                var S = e.distanceSqToSegment(w[y], w[y + 1], p, d);
                                if (!(S > s)) {
                                    p.applyMatrix4(this.matrixWorld);
                                    var E = n.ray.origin.distanceTo(p);
                                    E < n.near || E > n.far || r.push({
                                        distance: E,
                                        point: d.clone().applyMatrix4(this.matrixWorld),
                                        index: y,
                                        face: null,
                                        faceIndex: null,
                                        object: this
                                    })
                                }
                            }
                    }
                }
            }(),
            clone: function() {
                return new this.constructor(this.geometry, this.material).copy(this)
            }
        }), De.prototype = Object.assign(Object.create(Ie.prototype), {
            constructor: De,
            isLineSegments: !0
        }), Ne.prototype = Object.assign(Object.create(Ie.prototype), {
            constructor: Ne,
            isLineLoop: !0
        }), Fe.prototype = Object.create($.prototype), Fe.prototype.constructor = Fe, Fe.prototype.isPointsMaterial = !0, Fe.prototype.copy = function(t) {
            return $.prototype.copy.call(this, t), this.color.copy(t.color), this.map = t.map, this.size = t.size, this.sizeAttenuation = t.sizeAttenuation, this
        }, ke.prototype = Object.assign(Object.create(ct.prototype), {
            constructor: ke,
            isPoints: !0,
            raycast: function() {
                var t = new n,
                    e = new It,
                    i = new it;
                return function(n, r) {
                    function a(t, i) {
                        var o = e.distanceSqToPoint(t);
                        if (o < d) {
                            var a = e.closestPointToPoint(t);
                            a.applyMatrix4(c);
                            var l = n.ray.origin.distanceTo(a);
                            if (l < n.near || l > n.far) return;
                            r.push({
                                distance: l,
                                distanceToRay: Math.sqrt(o),
                                point: a.clone(),
                                index: i,
                                face: null,
                                object: s
                            })
                        }
                    }
                    var s = this,
                        l = this.geometry,
                        c = this.matrixWorld,
                        u = n.params.Points.threshold;
                    if (null === l.boundingSphere && l.computeBoundingSphere(), i.copy(l.boundingSphere), i.applyMatrix4(c), i.radius += u, !1 !== n.ray.intersectsSphere(i)) {
                        t.getInverse(c), e.copy(n.ray).applyMatrix4(t);
                        var h = u / ((this.scale.x + this.scale.y + this.scale.z) / 3),
                            d = h * h,
                            p = new o;
                        if (l.isBufferGeometry) {
                            var f = l.index,
                                m = l.attributes.position.array;
                            if (null !== f)
                                for (var g = f.array, v = 0, y = g.length; v < y; v++) {
                                    var _ = g[v];
                                    p.fromArray(m, 3 * _), a(p, _)
                                } else
                                    for (var v = 0, x = m.length / 3; v < x; v++) p.fromArray(m, 3 * v), a(p, v)
                        } else
                            for (var b = l.vertices, v = 0, x = b.length; v < x; v++) a(b[v], v)
                    }
                }
            }(),
            clone: function() {
                return new this.constructor(this.geometry, this.material).copy(this)
            }
        }), Ue.prototype = Object.assign(Object.create(ct.prototype), {
            constructor: Ue
        }), (Be.prototype = Object.create(s.prototype)).constructor = Be, (ze.prototype = Object.create(s.prototype)).constructor = ze, ze.prototype.isCompressedTexture = !0, (je.prototype = Object.create(s.prototype)).constructor = je, je.prototype.isDepthTexture = !0, He.prototype = Object.create(Mt.prototype), He.prototype.constructor = He, (Ge.prototype = Object.create(pt.prototype)).constructor = Ge, (Ve.prototype = Object.create(Mt.prototype)).constructor = Ve, (We.prototype = Object.create(pt.prototype)).constructor = We, Xe.prototype = Object.create(Mt.prototype), Xe.prototype.constructor = Xe, (qe.prototype = Object.create(pt.prototype)).constructor = qe, (Ye.prototype = Object.create(Xe.prototype)).constructor = Ye, (Qe.prototype = Object.create(pt.prototype)).constructor = Qe, Ze.prototype = Object.create(Xe.prototype), Ze.prototype.constructor = Ze, (Je.prototype = Object.create(pt.prototype)).constructor = Je, ($e.prototype = Object.create(Xe.prototype)).constructor = $e, (Ke.prototype = Object.create(pt.prototype)).constructor = Ke, (ti.prototype = Object.create(Xe.prototype)).constructor = ti, (ei.prototype = Object.create(pt.prototype)).constructor = ei, (ii.prototype = Object.create(Mt.prototype)).constructor = ii, (ni.prototype = Object.create(pt.prototype)).constructor = ni, (ri.prototype = Object.create(Mt.prototype)).constructor = ri, (oi.prototype = Object.create(pt.prototype)).constructor = oi, (ai.prototype = Object.create(Mt.prototype)).constructor = ai;
        var ss = {
            area: function(t) {
                for (var e = t.length, i = 0, n = e - 1, r = 0; r < e; n = r++) i += t[n].x * t[r].y - t[r].x * t[n].y;
                return .5 * i
            },
            triangulate: function() {
                function t(t, e, i, n, r, o) {
                    var a, s, l, c, u, h, d, p, f;
                    if (s = t[o[e]].x, l = t[o[e]].y, c = t[o[i]].x, u = t[o[i]].y, h = t[o[n]].x, d = t[o[n]].y, (c - s) * (d - l) - (u - l) * (h - s) <= 0) return !1;
                    var m, g, v, y, _, x, b, w, T, S, E, M, A, L, C;
                    for (m = h - c, g = d - u, v = s - h, y = l - d, _ = c - s, x = u - l, a = 0; a < r; a++)
                        if (p = t[o[a]].x, f = t[o[a]].y, !(p === s && f === l || p === c && f === u || p === h && f === d) && (b = p - s, w = f - l, T = p - c, S = f - u, E = p - h, M = f - d, C = m * S - g * T, A = _ * w - x * b, L = v * M - y * E, C >= -Number.EPSILON && L >= -Number.EPSILON && A >= -Number.EPSILON)) return !1;
                    return !0
                }
                return function(e, i) {
                    var n = e.length;
                    if (n < 3) return null;
                    var r, o, a, s = [],
                        l = [],
                        c = [];
                    if (ss.area(e) > 0)
                        for (o = 0; o < n; o++) l[o] = o;
                    else
                        for (o = 0; o < n; o++) l[o] = n - 1 - o;
                    var u = n,
                        h = 2 * u;
                    for (o = u - 1; u > 2;) {
                        if (h-- <= 0) return console.warn("THREE.ShapeUtils: Unable to triangulate polygon! in triangulate()"), i ? c : s;
                        if (r = o, u <= r && (r = 0), o = r + 1, u <= o && (o = 0), a = o + 1, u <= a && (a = 0), t(e, r, o, a, u, l)) {
                            var d, p, f, m, g;
                            for (d = l[r], p = l[o], f = l[a], s.push([e[d], e[p], e[f]]), c.push([l[r], l[o], l[a]]), m = o, g = o + 1; g < u; m++, g++) l[m] = l[g];
                            h = 2 * --u
                        }
                    }
                    return i ? c : s
                }
            }(),
            triangulateShape: function(t, e) {
                function i(t) {
                    var e = t.length;
                    e > 2 && t[e - 1].equals(t[0]) && t.pop()
                }

                function n(t, e, i) {
                    return t.x !== e.x ? t.x < e.x ? t.x <= i.x && i.x <= e.x : e.x <= i.x && i.x <= t.x : t.y < e.y ? t.y <= i.y && i.y <= e.y : e.y <= i.y && i.y <= t.y
                }

                function r(t, e, i, r, o) {
                    var a = e.x - t.x,
                        s = e.y - t.y,
                        l = r.x - i.x,
                        c = r.y - i.y,
                        u = t.x - i.x,
                        h = t.y - i.y,
                        d = s * l - a * c,
                        p = s * u - a * h;
                    if (Math.abs(d) > Number.EPSILON) {
                        var f;
                        if (d > 0) {
                            if (p < 0 || p > d) return [];
                            if ((f = c * u - l * h) < 0 || f > d) return []
                        } else {
                            if (p > 0 || p < d) return [];
                            if ((f = c * u - l * h) > 0 || f < d) return []
                        }
                        if (0 === f) return !o || 0 !== p && p !== d ? [t] : [];
                        if (f === d) return !o || 0 !== p && p !== d ? [e] : [];
                        if (0 === p) return [i];
                        if (p === d) return [r];
                        var m = f / d;
                        return [{
                            x: t.x + m * a,
                            y: t.y + m * s
                        }]
                    }
                    if (0 !== p || c * u != l * h) return [];
                    var g = 0 === a && 0 === s,
                        v = 0 === l && 0 === c;
                    if (g && v) return t.x !== i.x || t.y !== i.y ? [] : [t];
                    if (g) return n(i, r, t) ? [t] : [];
                    if (v) return n(t, e, i) ? [i] : [];
                    var y, _, x, b, w, T, S, E;
                    return 0 !== a ? (t.x < e.x ? (y = t, x = t.x, _ = e, b = e.x) : (y = e, x = e.x, _ = t, b = t.x), i.x < r.x ? (w = i, S = i.x, T = r, E = r.x) : (w = r, S = r.x, T = i, E = i.x)) : (t.y < e.y ? (y = t, x = t.y, _ = e, b = e.y) : (y = e, x = e.y, _ = t, b = t.y), i.y < r.y ? (w = i, S = i.y, T = r, E = r.y) : (w = r, S = r.y, T = i, E = i.y)), x <= S ? b < S ? [] : b === S ? o ? [] : [w] : b <= E ? [w, _] : [w, T] : x > E ? [] : x === E ? o ? [] : [y] : b <= E ? [y, _] : [y, T]
                }

                function o(t, e, i, n) {
                    var r = e.x - t.x,
                        o = e.y - t.y,
                        a = i.x - t.x,
                        s = i.y - t.y,
                        l = n.x - t.x,
                        c = n.y - t.y,
                        u = r * s - o * a,
                        h = r * c - o * l;
                    if (Math.abs(u) > Number.EPSILON) {
                        var d = l * s - c * a;
                        return u > 0 ? h >= 0 && d >= 0 : h >= 0 || d >= 0
                    }
                    return h > 0
                }
                i(t), e.forEach(i);
                for (var a, s, l, c, u, h, d = {}, p = t.concat(), f = 0, m = e.length; f < m; f++) Array.prototype.push.apply(p, e[f]);
                for (a = 0, s = p.length; a < s; a++) void 0 !== d[u = p[a].x + ":" + p[a].y] && console.warn("THREE.ShapeUtils: Duplicate point", u, a), d[u] = a;
                var g = function(t, e) {
                        for (var i, n, a, s, l, c, u, h, d, p, f, m = t.concat(), g = [], v = [], y = 0, _ = e.length; y < _; y++) g.push(y);
                        for (var x = 0, b = 2 * g.length; g.length > 0;) {
                            if (--b < 0) {
                                console.log('THREE.ShapeUtils: Infinite Loop! Holes left:" + indepHoles.length + ", Probably Hole outside Shape!');
                                break
                            }
                            for (a = x; a < m.length; a++) {
                                for (s = m[a], n = -1, y = 0; y < g.length; y++)
                                    if (c = g[y], u = s.x + ":" + s.y + ":" + c, void 0 === v[u]) {
                                        i = e[c];
                                        for (var w = 0; w < i.length; w++)
                                            if (l = i[w], function(t, e) {
                                                    var n = m.length - 1,
                                                        r = t - 1;
                                                    r < 0 && (r = n);
                                                    var a = t + 1;
                                                    a > n && (a = 0);
                                                    var s = o(m[t], m[r], m[a], i[e]);
                                                    if (!s) return !1;
                                                    var l = i.length - 1,
                                                        c = e - 1;
                                                    c < 0 && (c = l);
                                                    var u = e + 1;
                                                    return u > l && (u = 0), !!(s = o(i[e], i[c], i[u], m[t]))
                                                }(a, w) && ! function(t, e) {
                                                    var i, n;
                                                    for (i = 0; i < m.length; i++)
                                                        if (n = i + 1, n %= m.length, r(t, e, m[i], m[n], !0).length > 0) return !0;
                                                    return !1
                                                }(s, l) && ! function(t, i) {
                                                    var n, o, a, s;
                                                    for (n = 0; n < g.length; n++)
                                                        for (o = e[g[n]], a = 0; a < o.length; a++)
                                                            if (s = a + 1, s %= o.length, r(t, i, o[a], o[s], !0).length > 0) return !0;
                                                    return !1
                                                }(s, l)) {
                                                n = w, g.splice(y, 1), h = m.slice(0, a + 1), d = m.slice(a), p = i.slice(n), f = i.slice(0, n + 1), m = h.concat(p).concat(f).concat(d), x = a;
                                                break
                                            } if (n >= 0) break;
                                        v[u] = !0
                                    } if (n >= 0) break
                            }
                        }
                        return m
                    }(t, e),
                    v = ss.triangulate(g, !1);
                for (a = 0, s = v.length; a < s; a++)
                    for (c = v[a], l = 0; l < 3; l++) void 0 !== (h = d[u = c[l].x + ":" + c[l].y]) && (c[l] = h);
                return v.concat()
            },
            isClockWise: function(t) {
                return ss.area(t) < 0
            }
        };
        (si.prototype = Object.create(pt.prototype)).constructor = si, li.prototype = Object.create(Mt.prototype), li.prototype.constructor = li, li.prototype.getArrays = function() {
            var t = this.getAttribute("position"),
                e = t ? Array.prototype.slice.call(t.array) : [],
                i = this.getAttribute("uv"),
                n = i ? Array.prototype.slice.call(i.array) : [],
                r = this.index;
            return {
                position: e,
                uv: n,
                index: r ? Array.prototype.slice.call(r.array) : []
            }
        }, li.prototype.addShapeList = function(t, e) {
            var i = t.length;
            e.arrays = this.getArrays();
            for (var n = 0; n < i; n++) {
                var r = t[n];
                this.addShape(r, e)
            }
            this.setIndex(e.arrays.index), this.addAttribute("position", new wt(e.arrays.position, 3)), this.addAttribute("uv", new wt(e.arrays.uv, 2))
        }, li.prototype.addShape = function(t, e) {
            function n(t, e, i) {
                return e || console.error("THREE.ExtrudeGeometry: vec does not exist"), e.clone().multiplyScalar(i).add(t)
            }

            function r(t, e, n) {
                var r, o, a, s = t.x - e.x,
                    l = t.y - e.y,
                    c = n.x - t.x,
                    u = n.y - t.y,
                    h = s * s + l * l,
                    d = s * u - l * c;
                if (Math.abs(d) > Number.EPSILON) {
                    var p = Math.sqrt(h),
                        f = Math.sqrt(c * c + u * u),
                        m = e.x - l / p,
                        g = e.y + s / p,
                        v = ((n.x - u / f - m) * u - (n.y + c / f - g) * c) / (s * u - l * c),
                        y = (r = m + s * v - t.x) * r + (o = g + l * v - t.y) * o;
                    if (y <= 2) return new i(r, o);
                    a = Math.sqrt(y / 2)
                } else {
                    var _ = !1;
                    s > Number.EPSILON ? c > Number.EPSILON && (_ = !0) : s < -Number.EPSILON ? c < -Number.EPSILON && (_ = !0) : Math.sign(l) === Math.sign(u) && (_ = !0), _ ? (r = -l, o = s, a = Math.sqrt(h)) : (r = s, o = l, a = Math.sqrt(h / 2))
                }
                return new i(r / a, o / a)
            }

            function a(t, e) {
                var i, n;
                for (Z = t.length; --Z >= 0;) {
                    i = Z, (n = Z - 1) < 0 && (n = t.length - 1);
                    var r = 0,
                        o = L + 2 * E;
                    for (r = 0; r < o; r++) {
                        var a = q * r,
                            s = q * (r + 1);
                        c(e + i + a, e + n + a, e + n + s, e + i + s)
                    }
                }
            }

            function s(t, e, i) {
                b.push(t), b.push(e), b.push(i)
            }

            function l(t, e, i) {
                u(t), u(e), u(i);
                var n = y.length / 3,
                    r = R.generateTopUV(N, y, n - 3, n - 2, n - 1);
                h(r[0]), h(r[1]), h(r[2])
            }

            function c(t, e, i, n) {
                u(t), u(e), u(n), u(e), u(i), u(n);
                var r = y.length / 3,
                    o = R.generateSideWallUV(N, y, r - 6, r - 3, r - 2, r - 1);
                h(o[0]), h(o[1]), h(o[3]), h(o[1]), h(o[2]), h(o[3])
            }

            function u(t) {
                _.push(y.length / 3), y.push(b[3 * t + 0]), y.push(b[3 * t + 1]), y.push(b[3 * t + 2])
            }

            function h(t) {
                x.push(t.x), x.push(t.y)
            }
            var d, p, f, m, g, v = e.arrays ? e.arrays : this.getArrays(),
                y = v.position,
                _ = v.index,
                x = v.uv,
                b = [],
                w = void 0 !== e.amount ? e.amount : 100,
                T = void 0 !== e.bevelThickness ? e.bevelThickness : 6,
                S = void 0 !== e.bevelSize ? e.bevelSize : T - 2,
                E = void 0 !== e.bevelSegments ? e.bevelSegments : 3,
                M = void 0 === e.bevelEnabled || e.bevelEnabled,
                A = void 0 !== e.curveSegments ? e.curveSegments : 12,
                L = void 0 !== e.steps ? e.steps : 1,
                C = e.extrudePath,
                P = !1,
                R = void 0 !== e.UVGenerator ? e.UVGenerator : si.WorldUVGenerator;
            C && (d = C.getSpacedPoints(L), P = !0, M = !1, p = void 0 !== e.frames ? e.frames : C.computeFrenetFrames(L, !1), f = new o, m = new o, g = new o), M || (E = 0, T = 0, S = 0);
            var O, I, D, N = this,
                F = t.extractPoints(A),
                k = F.shape,
                U = F.holes;
            if (!ss.isClockWise(k))
                for (k = k.reverse(), I = 0, D = U.length; I < D; I++) O = U[I], ss.isClockWise(O) && (U[I] = O.reverse());
            var B = ss.triangulateShape(k, U),
                z = k;
            for (I = 0, D = U.length; I < D; I++) O = U[I], k = k.concat(O);
            for (var j, H, G, V, W, X, q = k.length, Y = B.length, Q = [], Z = 0, J = z.length, $ = J - 1, K = Z + 1; Z < J; Z++, $++, K++) $ === J && ($ = 0), K === J && (K = 0), Q[Z] = r(z[Z], z[$], z[K]);
            var tt, et = [],
                it = Q.concat();
            for (I = 0, D = U.length; I < D; I++) {
                for (O = U[I], tt = [], Z = 0, $ = (J = O.length) - 1, K = Z + 1; Z < J; Z++, $++, K++) $ === J && ($ = 0), K === J && (K = 0), tt[Z] = r(O[Z], O[$], O[K]);
                et.push(tt), it = it.concat(tt)
            }
            for (j = 0; j < E; j++) {
                for (G = j / E, V = T * Math.cos(G * Math.PI / 2), H = S * Math.sin(G * Math.PI / 2), Z = 0, J = z.length; Z < J; Z++) s((W = n(z[Z], Q[Z], H)).x, W.y, -V);
                for (I = 0, D = U.length; I < D; I++)
                    for (O = U[I], tt = et[I], Z = 0, J = O.length; Z < J; Z++) s((W = n(O[Z], tt[Z], H)).x, W.y, -V)
            }
            for (H = S, Z = 0; Z < q; Z++) W = M ? n(k[Z], it[Z], H) : k[Z], P ? (m.copy(p.normals[0]).multiplyScalar(W.x), f.copy(p.binormals[0]).multiplyScalar(W.y), g.copy(d[0]).add(m).add(f), s(g.x, g.y, g.z)) : s(W.x, W.y, 0);
            var nt;
            for (nt = 1; nt <= L; nt++)
                for (Z = 0; Z < q; Z++) W = M ? n(k[Z], it[Z], H) : k[Z], P ? (m.copy(p.normals[nt]).multiplyScalar(W.x), f.copy(p.binormals[nt]).multiplyScalar(W.y), g.copy(d[nt]).add(m).add(f), s(g.x, g.y, g.z)) : s(W.x, W.y, w / L * nt);
            for (j = E - 1; j >= 0; j--) {
                for (G = j / E, V = T * Math.cos(G * Math.PI / 2), H = S * Math.sin(G * Math.PI / 2), Z = 0, J = z.length; Z < J; Z++) s((W = n(z[Z], Q[Z], H)).x, W.y, w + V);
                for (I = 0, D = U.length; I < D; I++)
                    for (O = U[I], tt = et[I], Z = 0, J = O.length; Z < J; Z++) W = n(O[Z], tt[Z], H), P ? s(W.x, W.y + d[L - 1].y, d[L - 1].x + V) : s(W.x, W.y, w + V)
            }! function() {
                var t = y.length / 3;
                if (M) {
                    var i = 0,
                        n = q * i;
                    for (Z = 0; Z < Y; Z++) l((X = B[Z])[2] + n, X[1] + n, X[0] + n);
                    for (n = q * (i = L + 2 * E), Z = 0; Z < Y; Z++) l((X = B[Z])[0] + n, X[1] + n, X[2] + n)
                } else {
                    for (Z = 0; Z < Y; Z++) l((X = B[Z])[2], X[1], X[0]);
                    for (Z = 0; Z < Y; Z++) l((X = B[Z])[0] + q * L, X[1] + q * L, X[2] + q * L)
                }
                N.addGroup(t, y.length / 3 - t, void 0 !== e.material ? e.material : 0)
            }(),
            function() {
                var t = y.length / 3,
                    i = 0;
                for (a(z, i), i += z.length, I = 0, D = U.length; I < D; I++) a(O = U[I], i), i += O.length;
                N.addGroup(t, y.length / 3 - t, void 0 !== e.extrudeMaterial ? e.extrudeMaterial : 1)
            }(), e.arrays || (this.setIndex(_), this.addAttribute("position", new wt(y, 3)), this.addAttribute("uv", new wt(e.arrays.uv, 2)))
        }, si.WorldUVGenerator = {
            generateTopUV: function(t, e, n, r, o) {
                var a = e[3 * n],
                    s = e[3 * n + 1],
                    l = e[3 * r],
                    c = e[3 * r + 1],
                    u = e[3 * o],
                    h = e[3 * o + 1];
                return [new i(a, s), new i(l, c), new i(u, h)]
            },
            generateSideWallUV: function(t, e, n, r, o, a) {
                var s = e[3 * n],
                    l = e[3 * n + 1],
                    c = e[3 * n + 2],
                    u = e[3 * r],
                    h = e[3 * r + 1],
                    d = e[3 * r + 2],
                    p = e[3 * o],
                    f = e[3 * o + 1],
                    m = e[3 * o + 2],
                    g = e[3 * a],
                    v = e[3 * a + 1],
                    y = e[3 * a + 2];
                return Math.abs(l - h) < .01 ? [new i(s, 1 - c), new i(u, 1 - d), new i(p, 1 - m), new i(g, 1 - y)] : [new i(l, 1 - c), new i(h, 1 - d), new i(f, 1 - m), new i(v, 1 - y)]
            }
        }, (ci.prototype = Object.create(pt.prototype)).constructor = ci, (ui.prototype = Object.create(li.prototype)).constructor = ui, (hi.prototype = Object.create(pt.prototype)).constructor = hi, di.prototype = Object.create(Mt.prototype), di.prototype.constructor = di, (pi.prototype = Object.create(pt.prototype)).constructor = pi, (fi.prototype = Object.create(Mt.prototype)).constructor = fi, (mi.prototype = Object.create(pt.prototype)).constructor = mi, (gi.prototype = Object.create(Mt.prototype)).constructor = gi, (vi.prototype = Object.create(pt.prototype)).constructor = vi, (yi.prototype = Object.create(Mt.prototype)).constructor = yi, _i.prototype = Object.create(Mt.prototype), _i.prototype.constructor = _i, xi.prototype = Object.create(pt.prototype), xi.prototype.constructor = xi, bi.prototype = Object.create(Mt.prototype), bi.prototype.constructor = bi, (wi.prototype = Object.create(xi.prototype)).constructor = wi, (Ti.prototype = Object.create(bi.prototype)).constructor = Ti, (Si.prototype = Object.create(pt.prototype)).constructor = Si, (Ei.prototype = Object.create(Mt.prototype)).constructor = Ei;
        var ls = Object.freeze({
            WireframeGeometry: He,
            ParametricGeometry: Ge,
            ParametricBufferGeometry: Ve,
            TetrahedronGeometry: qe,
            TetrahedronBufferGeometry: Ye,
            OctahedronGeometry: Qe,
            OctahedronBufferGeometry: Ze,
            IcosahedronGeometry: Je,
            IcosahedronBufferGeometry: $e,
            DodecahedronGeometry: Ke,
            DodecahedronBufferGeometry: ti,
            PolyhedronGeometry: We,
            PolyhedronBufferGeometry: Xe,
            TubeGeometry: ei,
            TubeBufferGeometry: ii,
            TorusKnotGeometry: ni,
            TorusKnotBufferGeometry: ri,
            TorusGeometry: oi,
            TorusBufferGeometry: ai,
            TextGeometry: ci,
            TextBufferGeometry: ui,
            SphereGeometry: hi,
            SphereBufferGeometry: di,
            RingGeometry: pi,
            RingBufferGeometry: fi,
            PlaneGeometry: Ct,
            PlaneBufferGeometry: Pt,
            LatheGeometry: mi,
            LatheBufferGeometry: gi,
            ShapeGeometry: vi,
            ShapeBufferGeometry: yi,
            ExtrudeGeometry: si,
            ExtrudeBufferGeometry: li,
            EdgesGeometry: _i,
            ConeGeometry: wi,
            ConeBufferGeometry: Ti,
            CylinderGeometry: xi,
            CylinderBufferGeometry: bi,
            CircleGeometry: Si,
            CircleBufferGeometry: Ei,
            BoxGeometry: At,
            BoxBufferGeometry: Lt
        });
        (Mi.prototype = Object.create($.prototype)).constructor = Mi, Mi.prototype.isShadowMaterial = !0, (Ai.prototype = Object.create(Ot.prototype)).constructor = Ai, Ai.prototype.isRawShaderMaterial = !0, Li.prototype = Object.create($.prototype), Li.prototype.constructor = Li, Li.prototype.isMeshStandardMaterial = !0, Li.prototype.copy = function(t) {
            return $.prototype.copy.call(this, t), this.defines = {
                STANDARD: ""
            }, this.color.copy(t.color), this.roughness = t.roughness, this.metalness = t.metalness, this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.emissive.copy(t.emissive), this.emissiveMap = t.emissiveMap, this.emissiveIntensity = t.emissiveIntensity, this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.roughnessMap = t.roughnessMap, this.metalnessMap = t.metalnessMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.envMapIntensity = t.envMapIntensity, this.refractionRatio = t.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this
        }, (Ci.prototype = Object.create(Li.prototype)).constructor = Ci, Ci.prototype.isMeshPhysicalMaterial = !0, Ci.prototype.copy = function(t) {
            return Li.prototype.copy.call(this, t), this.defines = {
                PHYSICAL: ""
            }, this.reflectivity = t.reflectivity, this.clearCoat = t.clearCoat, this.clearCoatRoughness = t.clearCoatRoughness, this
        }, Pi.prototype = Object.create($.prototype), Pi.prototype.constructor = Pi, Pi.prototype.isMeshPhongMaterial = !0, Pi.prototype.copy = function(t) {
            return $.prototype.copy.call(this, t), this.color.copy(t.color), this.specular.copy(t.specular), this.shininess = t.shininess, this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.emissive.copy(t.emissive), this.emissiveMap = t.emissiveMap, this.emissiveIntensity = t.emissiveIntensity, this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.specularMap = t.specularMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.combine = t.combine, this.reflectivity = t.reflectivity, this.refractionRatio = t.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this
        }, (Ri.prototype = Object.create(Pi.prototype)).constructor = Ri, Ri.prototype.isMeshToonMaterial = !0, Ri.prototype.copy = function(t) {
            return Pi.prototype.copy.call(this, t), this.gradientMap = t.gradientMap, this
        }, (Oi.prototype = Object.create($.prototype)).constructor = Oi, Oi.prototype.isMeshNormalMaterial = !0, Oi.prototype.copy = function(t) {
            return $.prototype.copy.call(this, t), this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this
        }, (Ii.prototype = Object.create($.prototype)).constructor = Ii, Ii.prototype.isMeshLambertMaterial = !0, Ii.prototype.copy = function(t) {
            return $.prototype.copy.call(this, t), this.color.copy(t.color), this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.emissive.copy(t.emissive), this.emissiveMap = t.emissiveMap, this.emissiveIntensity = t.emissiveIntensity, this.specularMap = t.specularMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.combine = t.combine, this.reflectivity = t.reflectivity, this.refractionRatio = t.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this
        }, (Di.prototype = Object.create(Oe.prototype)).constructor = Di, Di.prototype.isLineDashedMaterial = !0, Di.prototype.copy = function(t) {
            return Oe.prototype.copy.call(this, t), this.scale = t.scale, this.dashSize = t.dashSize, this.gapSize = t.gapSize, this
        };
        var cs = Object.freeze({
                ShadowMaterial: Mi,
                SpriteMaterial: Me,
                RawShaderMaterial: Ai,
                ShaderMaterial: Ot,
                PointsMaterial: Fe,
                MeshPhysicalMaterial: Ci,
                MeshStandardMaterial: Li,
                MeshPhongMaterial: Pi,
                MeshToonMaterial: Ri,
                MeshNormalMaterial: Oi,
                MeshLambertMaterial: Ii,
                MeshDepthMaterial: K,
                MeshDistanceMaterial: tt,
                MeshBasicMaterial: Rt,
                LineDashedMaterial: Di,
                LineBasicMaterial: Oe,
                Material: $
            }),
            us = {
                enabled: !1,
                files: {},
                add: function(t, e) {
                    !1 !== this.enabled && (this.files[t] = e)
                },
                get: function(t) {
                    if (!1 !== this.enabled) return this.files[t]
                },
                remove: function(t) {
                    delete this.files[t]
                },
                clear: function() {
                    this.files = {}
                }
            },
            hs = new Ni,
            ds = {};
        Object.assign(Fi.prototype, {
            load: function(t, e, i, n) {
                void 0 === t && (t = ""), void 0 !== this.path && (t = this.path + t), t = this.manager.resolveURL(t);
                var r = this,
                    o = us.get(t);
                if (void 0 !== o) return r.manager.itemStart(t), setTimeout(function() {
                    e && e(o), r.manager.itemEnd(t)
                }, 0), o;
                if (void 0 === ds[t]) {
                    var a = /^data:(.*?)(;base64)?,(.*)$/,
                        s = t.match(a);
                    if (s) {
                        var l = s[1],
                            c = !!s[2],
                            u = s[3];
                        u = window.decodeURIComponent(u), c && (u = window.atob(u));
                        try {
                            var h, d = (this.responseType || "").toLowerCase();
                            switch (d) {
                                case "arraybuffer":
                                case "blob":
                                    for (var p = new Uint8Array(u.length), f = 0; f < u.length; f++) p[f] = u.charCodeAt(f);
                                    h = "blob" === d ? new Blob([p.buffer], {
                                        type: l
                                    }) : p.buffer;
                                    break;
                                case "document":
                                    var m = new DOMParser;
                                    h = m.parseFromString(u, l);
                                    break;
                                case "json":
                                    h = JSON.parse(u);
                                    break;
                                default:
                                    h = u
                            }
                            window.setTimeout(function() {
                                e && e(h), r.manager.itemEnd(t)
                            }, 0)
                        } catch (e) {
                            window.setTimeout(function() {
                                n && n(e), r.manager.itemEnd(t), r.manager.itemError(t)
                            }, 0)
                        }
                    } else {
                        ds[t] = [], ds[t].push({
                            onLoad: e,
                            onProgress: i,
                            onError: n
                        });
                        var g = new XMLHttpRequest;
                        g.open("GET", t, !0), g.addEventListener("load", function(e) {
                            var i = e.target.response;
                            us.add(t, i);
                            var n = ds[t];
                            if (delete ds[t], 200 === this.status) {
                                for (var o = 0, a = n.length; o < a; o++)(s = n[o]).onLoad && s.onLoad(i);
                                r.manager.itemEnd(t)
                            } else if (0 === this.status) {
                                console.warn("THREE.FileLoader: HTTP Status 0 received.");
                                for (var o = 0, a = n.length; o < a; o++)(s = n[o]).onLoad && s.onLoad(i);
                                r.manager.itemEnd(t)
                            } else {
                                for (var o = 0, a = n.length; o < a; o++) {
                                    var s = n[o];
                                    s.onError && s.onError(e)
                                }
                                r.manager.itemEnd(t), r.manager.itemError(t)
                            }
                        }, !1), g.addEventListener("progress", function(e) {
                            for (var i = ds[t], n = 0, r = i.length; n < r; n++) {
                                var o = i[n];
                                o.onProgress && o.onProgress(e)
                            }
                        }, !1), g.addEventListener("error", function(e) {
                            var i = ds[t];
                            delete ds[t];
                            for (var n = 0, o = i.length; n < o; n++) {
                                var a = i[n];
                                a.onError && a.onError(e)
                            }
                            r.manager.itemEnd(t), r.manager.itemError(t)
                        }, !1), void 0 !== this.responseType && (g.responseType = this.responseType), void 0 !== this.withCredentials && (g.withCredentials = this.withCredentials), g.overrideMimeType && g.overrideMimeType(void 0 !== this.mimeType ? this.mimeType : "text/plain");
                        for (var v in this.requestHeader) g.setRequestHeader(v, this.requestHeader[v]);
                        g.send(null)
                    }
                    return r.manager.itemStart(t), g
                }
                ds[t].push({
                    onLoad: e,
                    onProgress: i,
                    onError: n
                })
            },
            setPath: function(t) {
                return this.path = t, this
            },
            setResponseType: function(t) {
                return this.responseType = t, this
            },
            setWithCredentials: function(t) {
                return this.withCredentials = t, this
            },
            setMimeType: function(t) {
                return this.mimeType = t, this
            },
            setRequestHeader: function(t) {
                return this.requestHeader = t, this
            }
        }), Object.assign(ki.prototype, {
            load: function(t, e, i, n) {
                var r = this,
                    o = [],
                    a = new ze;
                a.image = o;
                var s = new Fi(this.manager);
                if (s.setPath(this.path), s.setResponseType("arraybuffer"), Array.isArray(t))
                    for (var l = 0, c = 0, u = t.length; c < u; ++c) ! function(c) {
                        s.load(t[c], function(t) {
                            var i = r._parser(t, !0);
                            o[c] = {
                                width: i.width,
                                height: i.height,
                                format: i.format,
                                mipmaps: i.mipmaps
                            }, 6 === (l += 1) && (1 === i.mipmapCount && (a.minFilter = Zo), a.format = i.format, a.needsUpdate = !0, e && e(a))
                        }, i, n)
                    }(c);
                else s.load(t, function(t) {
                    var i = r._parser(t, !0);
                    if (i.isCubemap)
                        for (var n = i.mipmaps.length / i.mipmapCount, s = 0; s < n; s++) {
                            o[s] = {
                                mipmaps: []
                            };
                            for (var l = 0; l < i.mipmapCount; l++) o[s].mipmaps.push(i.mipmaps[s * i.mipmapCount + l]), o[s].format = i.format, o[s].width = i.width, o[s].height = i.height
                        } else a.image.width = i.width, a.image.height = i.height, a.mipmaps = i.mipmaps;
                    1 === i.mipmapCount && (a.minFilter = Zo), a.format = i.format, a.needsUpdate = !0, e && e(a)
                }, i, n);
                return a
            },
            setPath: function(t) {
                return this.path = t, this
            }
        }), Object.assign(Ui.prototype, {
            load: function(t, e, i, n) {
                var r = this,
                    o = new h,
                    a = new Fi(this.manager);
                return a.setResponseType("arraybuffer"), a.load(t, function(t) {
                    var i = r._parser(t);
                    i && (void 0 !== i.image ? o.image = i.image : void 0 !== i.data && (o.image.width = i.width, o.image.height = i.height, o.image.data = i.data), o.wrapS = void 0 !== i.wrapS ? i.wrapS : Wo, o.wrapT = void 0 !== i.wrapT ? i.wrapT : Wo, o.magFilter = void 0 !== i.magFilter ? i.magFilter : Zo, o.minFilter = void 0 !== i.minFilter ? i.minFilter : $o, o.anisotropy = void 0 !== i.anisotropy ? i.anisotropy : 1, void 0 !== i.format && (o.format = i.format), void 0 !== i.type && (o.type = i.type), void 0 !== i.mipmaps && (o.mipmaps = i.mipmaps), 1 === i.mipmapCount && (o.minFilter = Zo), o.needsUpdate = !0, e && e(o, i))
                }, i, n), o
            }
        }), Object.assign(Bi.prototype, {
            crossOrigin: "Anonymous",
            load: function(t, e, i, n) {
                void 0 === t && (t = ""), void 0 !== this.path && (t = this.path + t), t = this.manager.resolveURL(t);
                var r = this,
                    o = us.get(t);
                if (void 0 !== o) return r.manager.itemStart(t), setTimeout(function() {
                    e && e(o), r.manager.itemEnd(t)
                }, 0), o;
                var a = document.createElementNS("http://www.w3.org/1999/xhtml", "img");
                return a.addEventListener("load", function() {
                    us.add(t, this), e && e(this), r.manager.itemEnd(t)
                }, !1), a.addEventListener("error", function(e) {
                    n && n(e), r.manager.itemEnd(t), r.manager.itemError(t)
                }, !1), "data:" !== t.substr(0, 5) && void 0 !== this.crossOrigin && (a.crossOrigin = this.crossOrigin), r.manager.itemStart(t), a.src = t, a
            },
            setCrossOrigin: function(t) {
                return this.crossOrigin = t, this
            },
            setPath: function(t) {
                return this.path = t, this
            }
        }), Object.assign(zi.prototype, {
            crossOrigin: "Anonymous",
            load: function(t, e, i, n) {
                var r = new d,
                    o = new Bi(this.manager);
                o.setCrossOrigin(this.crossOrigin), o.setPath(this.path);
                for (var a = 0, s = 0; s < t.length; ++s) ! function(i) {
                    o.load(t[i], function(t) {
                        r.images[i] = t, 6 == ++a && (r.needsUpdate = !0, e && e(r))
                    }, void 0, n)
                }(s);
                return r
            },
            setCrossOrigin: function(t) {
                return this.crossOrigin = t, this
            },
            setPath: function(t) {
                return this.path = t, this
            }
        }), Object.assign(ji.prototype, {
            crossOrigin: "Anonymous",
            load: function(t, e, i, n) {
                var r = new Bi(this.manager);
                r.setCrossOrigin(this.crossOrigin), r.setPath(this.path);
                var o = new s;
                return o.image = r.load(t, function() {
                    var i = t.search(/\.(jpg|jpeg)$/) > 0 || 0 === t.search(/^data\:image\/jpeg/);
                    o.format = i ? da : pa, o.needsUpdate = !0, void 0 !== e && e(o)
                }, i, n), o
            },
            setCrossOrigin: function(t) {
                return this.crossOrigin = t, this
            },
            setPath: function(t) {
                return this.path = t, this
            }
        }), Hi.prototype = Object.assign(Object.create(ct.prototype), {
            constructor: Hi,
            isLight: !0,
            copy: function(t) {
                return ct.prototype.copy.call(this, t), this.color.copy(t.color), this.intensity = t.intensity, this
            },
            toJSON: function(t) {
                var e = ct.prototype.toJSON.call(this, t);
                return e.object.color = this.color.getHex(), e.object.intensity = this.intensity, void 0 !== this.groundColor && (e.object.groundColor = this.groundColor.getHex()), void 0 !== this.distance && (e.object.distance = this.distance), void 0 !== this.angle && (e.object.angle = this.angle), void 0 !== this.decay && (e.object.decay = this.decay), void 0 !== this.penumbra && (e.object.penumbra = this.penumbra), void 0 !== this.shadow && (e.object.shadow = this.shadow.toJSON()), e
            }
        }), Gi.prototype = Object.assign(Object.create(Hi.prototype), {
            constructor: Gi,
            isHemisphereLight: !0,
            copy: function(t) {
                return Hi.prototype.copy.call(this, t), this.groundColor.copy(t.groundColor), this
            }
        }), Object.assign(Vi.prototype, {
            copy: function(t) {
                return this.camera = t.camera.clone(), this.bias = t.bias, this.radius = t.radius, this.mapSize.copy(t.mapSize), this
            },
            clone: function() {
                return (new this.constructor).copy(this)
            },
            toJSON: function() {
                var t = {};
                return 0 !== this.bias && (t.bias = this.bias), 1 !== this.radius && (t.radius = this.radius), 512 === this.mapSize.x && 512 === this.mapSize.y || (t.mapSize = this.mapSize.toArray()), t.camera = this.camera.toJSON(!1).object, delete t.camera.matrix, t
            }
        }), Wi.prototype = Object.assign(Object.create(Vi.prototype), {
            constructor: Wi,
            isSpotLightShadow: !0,
            update: function(t) {
                var e = this.camera,
                    i = 2 * Ha.RAD2DEG * t.angle,
                    n = this.mapSize.width / this.mapSize.height,
                    r = t.distance || e.far;
                i === e.fov && n === e.aspect && r === e.far || (e.fov = i, e.aspect = n, e.far = r, e.updateProjectionMatrix())
            }
        }), Xi.prototype = Object.assign(Object.create(Hi.prototype), {
            constructor: Xi,
            isSpotLight: !0,
            copy: function(t) {
                return Hi.prototype.copy.call(this, t), this.distance = t.distance, this.angle = t.angle, this.penumbra = t.penumbra, this.decay = t.decay, this.target = t.target.clone(), this.shadow = t.shadow.clone(), this
            }
        }), qi.prototype = Object.assign(Object.create(Hi.prototype), {
            constructor: qi,
            isPointLight: !0,
            copy: function(t) {
                return Hi.prototype.copy.call(this, t), this.distance = t.distance, this.decay = t.decay, this.shadow = t.shadow.clone(), this
            }
        }), Yi.prototype = Object.assign(Object.create(Vi.prototype), {
            constructor: Yi
        }), Qi.prototype = Object.assign(Object.create(Hi.prototype), {
            constructor: Qi,
            isDirectionalLight: !0,
            copy: function(t) {
                return Hi.prototype.copy.call(this, t), this.target = t.target.clone(), this.shadow = t.shadow.clone(), this
            }
        }), Zi.prototype = Object.assign(Object.create(Hi.prototype), {
            constructor: Zi,
            isAmbientLight: !0
        }), Ji.prototype = Object.assign(Object.create(Hi.prototype), {
            constructor: Ji,
            isRectAreaLight: !0,
            copy: function(t) {
                return Hi.prototype.copy.call(this, t), this.width = t.width, this.height = t.height, this
            },
            toJSON: function(t) {
                var e = Hi.prototype.toJSON.call(this, t);
                return e.object.width = this.width, e.object.height = this.height, e
            }
        });
        var ps = {
            arraySlice: function(t, e, i) {
                return ps.isTypedArray(t) ? new t.constructor(t.subarray(e, void 0 !== i ? i : t.length)) : t.slice(e, i)
            },
            convertArray: function(t, e, i) {
                return !t || !i && t.constructor === e ? t : "number" == typeof e.BYTES_PER_ELEMENT ? new e(t) : Array.prototype.slice.call(t)
            },
            isTypedArray: function(t) {
                return ArrayBuffer.isView(t) && !(t instanceof DataView)
            },
            getKeyframeOrder: function(t) {
                for (var e = t.length, i = new Array(e), n = 0; n !== e; ++n) i[n] = n;
                return i.sort(function(e, i) {
                    return t[e] - t[i]
                }), i
            },
            sortedArray: function(t, e, i) {
                for (var n = t.length, r = new t.constructor(n), o = 0, a = 0; a !== n; ++o)
                    for (var s = i[o] * e, l = 0; l !== e; ++l) r[a++] = t[s + l];
                return r
            },
            flattenJSON: function(t, e, i, n) {
                for (var r = 1, o = t[0]; void 0 !== o && void 0 === o[n];) o = t[r++];
                if (void 0 !== o) {
                    var a = o[n];
                    if (void 0 !== a)
                        if (Array.isArray(a))
                            do {
                                void 0 !== (a = o[n]) && (e.push(o.time), i.push.apply(i, a)), o = t[r++]
                            } while (void 0 !== o);
                        else if (void 0 !== a.toArray)
                        do {
                            void 0 !== (a = o[n]) && (e.push(o.time), a.toArray(i, i.length)), o = t[r++]
                        } while (void 0 !== o);
                    else
                        do {
                            void 0 !== (a = o[n]) && (e.push(o.time), i.push(a)), o = t[r++]
                        } while (void 0 !== o)
                }
            }
        };
        Object.assign($i.prototype, {
            evaluate: function(t) {
                var e = this.parameterPositions,
                    i = this._cachedIndex,
                    n = e[i],
                    r = e[i - 1];
                t: {
                    e: {
                        var o;i: {
                            n: if (!(t < n)) {
                                for (s = i + 2;;) {
                                    if (void 0 === n) {
                                        if (t < r) break n;
                                        return i = e.length, this._cachedIndex = i, this.afterEnd_(i - 1, t, r)
                                    }
                                    if (i === s) break;
                                    if (r = n, n = e[++i], t < n) break e
                                }
                                o = e.length;
                                break i
                            } {
                                if (t >= r) break t;
                                var a = e[1];
                                t < a && (i = 2, r = a);
                                for (var s = i - 2;;) {
                                    if (void 0 === r) return this._cachedIndex = 0, this.beforeStart_(0, t, n);
                                    if (i === s) break;
                                    if (n = r, r = e[--i - 1], t >= r) break e
                                }
                                o = i, i = 0
                            }
                        }
                        for (; i < o;) {
                            var l = i + o >>> 1;
                            t < e[l] ? o = l : i = l + 1
                        }
                        if (n = e[i], void 0 === (r = e[i - 1])) return this._cachedIndex = 0,
                        this.beforeStart_(0, t, n);
                        if (void 0 === n) return i = e.length,
                        this._cachedIndex = i,
                        this.afterEnd_(i - 1, r, t)
                    }
                    this._cachedIndex = i,
                    this.intervalChanged_(i, r, n)
                }
                return this.interpolate_(i, r, t, n)
            },
            settings: null,
            DefaultSettings_: {},
            getSettings_: function() {
                return this.settings || this.DefaultSettings_
            },
            copySampleValue_: function(t) {
                for (var e = this.resultBuffer, i = this.sampleValues, n = this.valueSize, r = t * n, o = 0; o !== n; ++o) e[o] = i[r + o];
                return e
            },
            interpolate_: function() {
                throw new Error("call to abstract method")
            },
            intervalChanged_: function() {}
        }), Object.assign($i.prototype, {
            beforeStart_: $i.prototype.copySampleValue_,
            afterEnd_: $i.prototype.copySampleValue_
        }), Ki.prototype = Object.assign(Object.create($i.prototype), {
            constructor: Ki,
            DefaultSettings_: {
                endingStart: Ca,
                endingEnd: Ca
            },
            intervalChanged_: function(t, e, i) {
                var n = this.parameterPositions,
                    r = t - 2,
                    o = t + 1,
                    a = n[r],
                    s = n[o];
                if (void 0 === a) switch (this.getSettings_().endingStart) {
                    case 2401:
                        r = t, a = 2 * e - i;
                        break;
                    case 2402:
                        a = e + n[r = n.length - 2] - n[r + 1];
                        break;
                    default:
                        r = t, a = i
                }
                if (void 0 === s) switch (this.getSettings_().endingEnd) {
                    case 2401:
                        o = t, s = 2 * i - e;
                        break;
                    case 2402:
                        o = 1, s = i + n[1] - n[0];
                        break;
                    default:
                        o = t - 1, s = e
                }
                var l = .5 * (i - e),
                    c = this.valueSize;
                this._weightPrev = l / (e - a), this._weightNext = l / (s - i), this._offsetPrev = r * c, this._offsetNext = o * c
            },
            interpolate_: function(t, e, i, n) {
                for (var r = this.resultBuffer, o = this.sampleValues, a = this.valueSize, s = t * a, l = s - a, c = this._offsetPrev, u = this._offsetNext, h = this._weightPrev, d = this._weightNext, p = (i - e) / (n - e), f = p * p, m = f * p, g = -h * m + 2 * h * f - h * p, v = (1 + h) * m + (-1.5 - 2 * h) * f + (-.5 + h) * p + 1, y = (-1 - d) * m + (1.5 + d) * f + .5 * p, _ = d * m - d * f, x = 0; x !== a; ++x) r[x] = g * o[c + x] + v * o[l + x] + y * o[s + x] + _ * o[u + x];
                return r
            }
        }), tn.prototype = Object.assign(Object.create($i.prototype), {
            constructor: tn,
            interpolate_: function(t, e, i, n) {
                for (var r = this.resultBuffer, o = this.sampleValues, a = this.valueSize, s = t * a, l = s - a, c = (i - e) / (n - e), u = 1 - c, h = 0; h !== a; ++h) r[h] = o[l + h] * u + o[s + h] * c;
                return r
            }
        }), en.prototype = Object.assign(Object.create($i.prototype), {
            constructor: en,
            interpolate_: function(t) {
                return this.copySampleValue_(t - 1)
            }
        });
        var fs;
        fs = {
            TimeBufferType: Float32Array,
            ValueBufferType: Float32Array,
            DefaultInterpolation: 2301,
            InterpolantFactoryMethodDiscrete: function(t) {
                return new en(this.times, this.values, this.getValueSize(), t)
            },
            InterpolantFactoryMethodLinear: function(t) {
                return new tn(this.times, this.values, this.getValueSize(), t)
            },
            InterpolantFactoryMethodSmooth: function(t) {
                return new Ki(this.times, this.values, this.getValueSize(), t)
            },
            setInterpolation: function(t) {
                var e;
                switch (t) {
                    case 2300:
                        e = this.InterpolantFactoryMethodDiscrete;
                        break;
                    case 2301:
                        e = this.InterpolantFactoryMethodLinear;
                        break;
                    case 2302:
                        e = this.InterpolantFactoryMethodSmooth
                }
                if (void 0 !== e) this.createInterpolant = e;
                else {
                    var i = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
                    if (void 0 === this.createInterpolant) {
                        if (t === this.DefaultInterpolation) throw new Error(i);
                        this.setInterpolation(this.DefaultInterpolation)
                    }
                    console.warn("THREE.KeyframeTrackPrototype:", i)
                }
            },
            getInterpolation: function() {
                switch (this.createInterpolant) {
                    case this.InterpolantFactoryMethodDiscrete:
                        return 2300;
                    case this.InterpolantFactoryMethodLinear:
                        return 2301;
                    case this.InterpolantFactoryMethodSmooth:
                        return 2302
                }
            },
            getValueSize: function() {
                return this.values.length / this.times.length
            },
            shift: function(t) {
                if (0 !== t)
                    for (var e = this.times, i = 0, n = e.length; i !== n; ++i) e[i] += t;
                return this
            },
            scale: function(t) {
                if (1 !== t)
                    for (var e = this.times, i = 0, n = e.length; i !== n; ++i) e[i] *= t;
                return this
            },
            trim: function(t, e) {
                for (var i = this.times, n = i.length, r = 0, o = n - 1; r !== n && i[r] < t;) ++r;
                for (; - 1 !== o && i[o] > e;) --o;
                if (++o, 0 !== r || o !== n) {
                    r >= o && (o = Math.max(o, 1), r = o - 1);
                    var a = this.getValueSize();
                    this.times = ps.arraySlice(i, r, o), this.values = ps.arraySlice(this.values, r * a, o * a)
                }
                return this
            },
            validate: function() {
                var t = !0,
                    e = this.getValueSize();
                e - Math.floor(e) != 0 && (console.error("THREE.KeyframeTrackPrototype: Invalid value size in track.", this), t = !1);
                var i = this.times,
                    n = this.values,
                    r = i.length;
                0 === r && (console.error("THREE.KeyframeTrackPrototype: Track is empty.", this), t = !1);
                for (var o = null, a = 0; a !== r; a++) {
                    var s = i[a];
                    if ("number" == typeof s && isNaN(s)) {
                        console.error("THREE.KeyframeTrackPrototype: Time is not a valid number.", this, a, s), t = !1;
                        break
                    }
                    if (null !== o && o > s) {
                        console.error("THREE.KeyframeTrackPrototype: Out of order keys.", this, a, s, o), t = !1;
                        break
                    }
                    o = s
                }
                if (void 0 !== n && ps.isTypedArray(n))
                    for (var a = 0, l = n.length; a !== l; ++a) {
                        var c = n[a];
                        if (isNaN(c)) {
                            console.error("THREE.KeyframeTrackPrototype: Value is not a valid number.", this, a, c), t = !1;
                            break
                        }
                    }
                return t
            },
            optimize: function() {
                for (var t = this.times, e = this.values, i = this.getValueSize(), n = 2302 === this.getInterpolation(), r = 1, o = t.length - 1, a = 1; a < o; ++a) {
                    var s = !1,
                        l = t[a];
                    if (l !== t[a + 1] && (1 !== a || l !== l[0]))
                        if (n) s = !0;
                        else
                            for (var c = a * i, u = c - i, h = c + i, d = 0; d !== i; ++d) {
                                var p = e[c + d];
                                if (p !== e[u + d] || p !== e[h + d]) {
                                    s = !0;
                                    break
                                }
                            }
                    if (s) {
                        if (a !== r) {
                            t[r] = t[a];
                            for (var f = a * i, m = r * i, d = 0; d !== i; ++d) e[m + d] = e[f + d]
                        }++r
                    }
                }
                if (o > 0) {
                    t[r] = t[o];
                    for (var f = o * i, m = r * i, d = 0; d !== i; ++d) e[m + d] = e[f + d];
                    ++r
                }
                return r !== t.length && (this.times = ps.arraySlice(t, 0, r), this.values = ps.arraySlice(e, 0, r * i)), this
            }
        }, rn.prototype = Object.assign(Object.create(fs), {
            constructor: rn,
            ValueTypeName: "vector"
        }), on.prototype = Object.assign(Object.create($i.prototype), {
            constructor: on,
            interpolate_: function(t, e, i, n) {
                for (var o = this.resultBuffer, a = this.sampleValues, s = this.valueSize, l = t * s, c = (i - e) / (n - e), u = l + s; l !== u; l += 4) r.slerpFlat(o, 0, a, l - s, a, l, c);
                return o
            }
        }), an.prototype = Object.assign(Object.create(fs), {
            constructor: an,
            ValueTypeName: "quaternion",
            DefaultInterpolation: 2301,
            InterpolantFactoryMethodLinear: function(t) {
                return new on(this.times, this.values, this.getValueSize(), t)
            },
            InterpolantFactoryMethodSmooth: void 0
        }), sn.prototype = Object.assign(Object.create(fs), {
            constructor: sn,
            ValueTypeName: "number"
        }), ln.prototype = Object.assign(Object.create(fs), {
            constructor: ln,
            ValueTypeName: "string",
            ValueBufferType: Array,
            DefaultInterpolation: 2300,
            InterpolantFactoryMethodLinear: void 0,
            InterpolantFactoryMethodSmooth: void 0
        }), cn.prototype = Object.assign(Object.create(fs), {
            constructor: cn,
            ValueTypeName: "bool",
            ValueBufferType: Array,
            DefaultInterpolation: 2300,
            InterpolantFactoryMethodLinear: void 0,
            InterpolantFactoryMethodSmooth: void 0
        }), un.prototype = Object.assign(Object.create(fs), {
            constructor: un,
            ValueTypeName: "color"
        }), hn.prototype = fs, fs.constructor = hn, Object.assign(hn, {
            parse: function(t) {
                if (void 0 === t.type) throw new Error("track type undefined, can not parse");
                var e = hn._getTrackTypeForValueTypeName(t.type);
                if (void 0 === t.times) {
                    var i = [],
                        n = [];
                    ps.flattenJSON(t.keys, i, n, "value"), t.times = i, t.values = n
                }
                return void 0 !== e.parse ? e.parse(t) : new e(t.name, t.times, t.values, t.interpolation)
            },
            toJSON: function(t) {
                var e, i = t.constructor;
                if (void 0 !== i.toJSON) e = i.toJSON(t);
                else {
                    e = {
                        name: t.name,
                        times: ps.convertArray(t.times, Array),
                        values: ps.convertArray(t.values, Array)
                    };
                    var n = t.getInterpolation();
                    n !== t.DefaultInterpolation && (e.interpolation = n)
                }
                return e.type = t.ValueTypeName, e
            },
            _getTrackTypeForValueTypeName: function(t) {
                switch (t.toLowerCase()) {
                    case "scalar":
                    case "double":
                    case "float":
                    case "number":
                    case "integer":
                        return sn;
                    case "vector":
                    case "vector2":
                    case "vector3":
                    case "vector4":
                        return rn;
                    case "color":
                        return un;
                    case "quaternion":
                        return an;
                    case "bool":
                    case "boolean":
                        return cn;
                    case "string":
                        return ln
                }
                throw new Error("Unsupported typeName: " + t)
            }
        }), Object.assign(dn, {
            parse: function(t) {
                for (var e = [], i = t.tracks, n = 1 / (t.fps || 1), r = 0, o = i.length; r !== o; ++r) e.push(hn.parse(i[r]).scale(n));
                return new dn(t.name, t.duration, e)
            },
            toJSON: function(t) {
                for (var e = [], i = t.tracks, n = {
                        name: t.name,
                        duration: t.duration,
                        tracks: e
                    }, r = 0, o = i.length; r !== o; ++r) e.push(hn.toJSON(i[r]));
                return n
            },
            CreateFromMorphTargetSequence: function(t, e, i, n) {
                for (var r = e.length, o = [], a = 0; a < r; a++) {
                    var s = [],
                        l = [];
                    s.push((a + r - 1) % r, a, (a + 1) % r), l.push(0, 1, 0);
                    var c = ps.getKeyframeOrder(s);
                    s = ps.sortedArray(s, 1, c), l = ps.sortedArray(l, 1, c), n || 0 !== s[0] || (s.push(r), l.push(l[0])), o.push(new sn(".morphTargetInfluences[" + e[a].name + "]", s, l).scale(1 / i))
                }
                return new dn(t, -1, o)
            },
            findByName: function(t, e) {
                var i = t;
                if (!Array.isArray(t)) {
                    var n = t;
                    i = n.geometry && n.geometry.animations || n.animations
                }
                for (var r = 0; r < i.length; r++)
                    if (i[r].name === e) return i[r];
                return null
            },
            CreateClipsFromMorphTargetSequences: function(t, e, i) {
                for (var n = {}, r = /^([\w-]*?)([\d]+)$/, o = 0, a = t.length; o < a; o++) {
                    var s = t[o],
                        l = s.name.match(r);
                    if (l && l.length > 1) {
                        var c = n[h = l[1]];
                        c || (n[h] = c = []), c.push(s)
                    }
                }
                var u = [];
                for (var h in n) u.push(dn.CreateFromMorphTargetSequence(h, n[h], e, i));
                return u
            },
            parseAnimation: function(t, e) {
                if (!t) return console.error("THREE.AnimationClip: No animation in JSONLoader data."), null;
                for (var i = function(t, e, i, n, r) {
                        if (0 !== i.length) {
                            var o = [],
                                a = [];
                            ps.flattenJSON(i, o, a, n), 0 !== o.length && r.push(new t(e, o, a))
                        }
                    }, n = [], r = t.name || "default", o = t.length || -1, a = t.fps || 30, s = t.hierarchy || [], l = 0; l < s.length; l++) {
                    var c = s[l].keys;
                    if (c && 0 !== c.length)
                        if (c[0].morphTargets) {
                            for (var u = {}, h = 0; h < c.length; h++)
                                if (c[h].morphTargets)
                                    for (m = 0; m < c[h].morphTargets.length; m++) u[c[h].morphTargets[m]] = -1;
                            for (var d in u) {
                                for (var p = [], f = [], m = 0; m !== c[h].morphTargets.length; ++m) {
                                    var g = c[h];
                                    p.push(g.time), f.push(g.morphTarget === d ? 1 : 0)
                                }
                                n.push(new sn(".morphTargetInfluence[" + d + "]", p, f))
                            }
                            o = u.length * (a || 1)
                        } else {
                            var v = ".bones[" + e[l].name + "]";
                            i(rn, v + ".position", c, "pos", n), i(an, v + ".quaternion", c, "rot", n), i(rn, v + ".scale", c, "scl", n)
                        }
                }
                return 0 === n.length ? null : new dn(r, o, n)
            }
        }), Object.assign(dn.prototype, {
            resetDuration: function() {
                for (var t = 0, e = 0, i = this.tracks.length; e !== i; ++e) {
                    var n = this.tracks[e];
                    t = Math.max(t, n.times[n.times.length - 1])
                }
                this.duration = t
            },
            trim: function() {
                for (var t = 0; t < this.tracks.length; t++) this.tracks[t].trim(0, this.duration);
                return this
            },
            optimize: function() {
                for (var t = 0; t < this.tracks.length; t++) this.tracks[t].optimize();
                return this
            }
        }), Object.assign(pn.prototype, {
            load: function(t, e, i, n) {
                var r = this;
                new Fi(r.manager).load(t, function(t) {
                    e(r.parse(JSON.parse(t)))
                }, i, n)
            },
            setTextures: function(t) {
                this.textures = t
            },
            parse: function(t) {
                function e(t) {
                    return void 0 === n[t] && console.warn("THREE.MaterialLoader: Undefined texture", t), n[t]
                }
                var n = this.textures,
                    r = new cs[t.type];
                if (void 0 !== t.uuid && (r.uuid = t.uuid), void 0 !== t.name && (r.name = t.name), void 0 !== t.color && r.color.setHex(t.color), void 0 !== t.roughness && (r.roughness = t.roughness), void 0 !== t.metalness && (r.metalness = t.metalness), void 0 !== t.emissive && r.emissive.setHex(t.emissive), void 0 !== t.specular && r.specular.setHex(t.specular), void 0 !== t.shininess && (r.shininess = t.shininess), void 0 !== t.clearCoat && (r.clearCoat = t.clearCoat), void 0 !== t.clearCoatRoughness && (r.clearCoatRoughness = t.clearCoatRoughness), void 0 !== t.uniforms && (r.uniforms = t.uniforms), void 0 !== t.vertexShader && (r.vertexShader = t.vertexShader), void 0 !== t.fragmentShader && (r.fragmentShader = t.fragmentShader), void 0 !== t.vertexColors && (r.vertexColors = t.vertexColors), void 0 !== t.fog && (r.fog = t.fog), void 0 !== t.flatShading && (r.flatShading = t.flatShading), void 0 !== t.blending && (r.blending = t.blending), void 0 !== t.side && (r.side = t.side), void 0 !== t.opacity && (r.opacity = t.opacity), void 0 !== t.transparent && (r.transparent = t.transparent), void 0 !== t.alphaTest && (r.alphaTest = t.alphaTest), void 0 !== t.depthTest && (r.depthTest = t.depthTest), void 0 !== t.depthWrite && (r.depthWrite = t.depthWrite), void 0 !== t.colorWrite && (r.colorWrite = t.colorWrite), void 0 !== t.wireframe && (r.wireframe = t.wireframe), void 0 !== t.wireframeLinewidth && (r.wireframeLinewidth = t.wireframeLinewidth), void 0 !== t.wireframeLinecap && (r.wireframeLinecap = t.wireframeLinecap), void 0 !== t.wireframeLinejoin && (r.wireframeLinejoin = t.wireframeLinejoin), void 0 !== t.rotation && (r.rotation = t.rotation), 1 !== t.linewidth && (r.linewidth = t.linewidth), void 0 !== t.dashSize && (r.dashSize = t.dashSize), void 0 !== t.gapSize && (r.gapSize = t.gapSize), void 0 !== t.scale && (r.scale = t.scale), void 0 !== t.skinning && (r.skinning = t.skinning), void 0 !== t.morphTargets && (r.morphTargets = t.morphTargets), void 0 !== t.dithering && (r.dithering = t.dithering), void 0 !== t.visible && (r.visible = t.visible), void 0 !== t.userData && (r.userData = t.userData), void 0 !== t.shading && (r.flatShading = 1 === t.shading), void 0 !== t.size && (r.size = t.size), void 0 !== t.sizeAttenuation && (r.sizeAttenuation = t.sizeAttenuation), void 0 !== t.map && (r.map = e(t.map)), void 0 !== t.alphaMap && (r.alphaMap = e(t.alphaMap), r.transparent = !0), void 0 !== t.bumpMap && (r.bumpMap = e(t.bumpMap)), void 0 !== t.bumpScale && (r.bumpScale = t.bumpScale), void 0 !== t.normalMap && (r.normalMap = e(t.normalMap)), void 0 !== t.normalScale) {
                    var o = t.normalScale;
                    !1 === Array.isArray(o) && (o = [o, o]), r.normalScale = (new i).fromArray(o)
                }
                return void 0 !== t.displacementMap && (r.displacementMap = e(t.displacementMap)), void 0 !== t.displacementScale && (r.displacementScale = t.displacementScale), void 0 !== t.displacementBias && (r.displacementBias = t.displacementBias), void 0 !== t.roughnessMap && (r.roughnessMap = e(t.roughnessMap)), void 0 !== t.metalnessMap && (r.metalnessMap = e(t.metalnessMap)), void 0 !== t.emissiveMap && (r.emissiveMap = e(t.emissiveMap)), void 0 !== t.emissiveIntensity && (r.emissiveIntensity = t.emissiveIntensity), void 0 !== t.specularMap && (r.specularMap = e(t.specularMap)), void 0 !== t.envMap && (r.envMap = e(t.envMap)), void 0 !== t.reflectivity && (r.reflectivity = t.reflectivity), void 0 !== t.lightMap && (r.lightMap = e(t.lightMap)), void 0 !== t.lightMapIntensity && (r.lightMapIntensity = t.lightMapIntensity), void 0 !== t.aoMap && (r.aoMap = e(t.aoMap)), void 0 !== t.aoMapIntensity && (r.aoMapIntensity = t.aoMapIntensity), void 0 !== t.gradientMap && (r.gradientMap = e(t.gradientMap)), r
            }
        }), Object.assign(fn.prototype, {
            load: function(t, e, i, n) {
                var r = this;
                new Fi(r.manager).load(t, function(t) {
                    e(r.parse(JSON.parse(t)))
                }, i, n)
            },
            parse: function(t) {
                var e = new Mt,
                    i = t.data.index;
                if (void 0 !== i) {
                    s = new ms[i.type](i.array);
                    e.setIndex(new ft(s, 1))
                }
                var n = t.data.attributes;
                for (var r in n) {
                    var a = n[r],
                        s = new ms[a.type](a.array);
                    e.addAttribute(r, new ft(s, a.itemSize, a.normalized))
                }
                var l = t.data.groups || t.data.drawcalls || t.data.offsets;
                if (void 0 !== l)
                    for (var c = 0, u = l.length; c !== u; ++c) {
                        var h = l[c];
                        e.addGroup(h.start, h.count, h.materialIndex)
                    }
                var d = t.data.boundingSphere;
                if (void 0 !== d) {
                    var p = new o;
                    void 0 !== d.center && p.fromArray(d.center), e.boundingSphere = new it(p, d.radius)
                }
                return e
            }
        });
        var ms = {
            Int8Array: Int8Array,
            Uint8Array: Uint8Array,
            Uint8ClampedArray: "undefined" != typeof Uint8ClampedArray ? Uint8ClampedArray : Uint8Array,
            Int16Array: Int16Array,
            Uint16Array: Uint16Array,
            Int32Array: Int32Array,
            Uint32Array: Uint32Array,
            Float32Array: Float32Array,
            Float64Array: Float64Array
        };
        mn.Handlers = {
            handlers: [],
            add: function(t, e) {
                this.handlers.push(t, e)
            },
            get: function(t) {
                for (var e = this.handlers, i = 0, n = e.length; i < n; i += 2) {
                    var r = e[i],
                        o = e[i + 1];
                    if (r.test(t)) return o
                }
                return null
            }
        }, Object.assign(mn.prototype, {
            crossOrigin: void 0,
            extractUrlBase: function(t) {
                var e = t.split("/");
                return 1 === e.length ? "./" : (e.pop(), e.join("/") + "/")
            },
            initMaterials: function(t, e, i) {
                for (var n = [], r = 0; r < t.length; ++r) n[r] = this.createMaterial(t[r], e, i);
                return n
            },
            createMaterial: function() {
                var t = {
                        NoBlending: $r,
                        NormalBlending: Kr,
                        AdditiveBlending: to,
                        SubtractiveBlending: eo,
                        MultiplyBlending: io,
                        CustomBlending: no
                    },
                    e = new q,
                    i = new ji,
                    n = new pn;
                return function(r, o, a) {
                    function s(t, e, n, r, s) {
                        var c, u = o + t,
                            h = mn.Handlers.get(u);
                        null !== h ? c = h.load(u) : (i.setCrossOrigin(a), c = i.load(u)), void 0 !== e && (c.repeat.fromArray(e), 1 !== e[0] && (c.wrapS = Vo), 1 !== e[1] && (c.wrapT = Vo)), void 0 !== n && c.offset.fromArray(n), void 0 !== r && ("repeat" === r[0] && (c.wrapS = Vo), "mirror" === r[0] && (c.wrapS = Xo), "repeat" === r[1] && (c.wrapT = Vo), "mirror" === r[1] && (c.wrapT = Xo)), void 0 !== s && (c.anisotropy = s);
                        var d = Ha.generateUUID();
                        return l[d] = c, d
                    }
                    var l = {},
                        c = {
                            uuid: Ha.generateUUID(),
                            type: "MeshLambertMaterial"
                        };
                    for (var u in r) {
                        var h = r[u];
                        switch (u) {
                            case "DbgColor":
                            case "DbgIndex":
                            case "opticalDensity":
                            case "illumination":
                                break;
                            case "DbgName":
                                c.name = h;
                                break;
                            case "blending":
                                c.blending = t[h];
                                break;
                            case "colorAmbient":
                            case "mapAmbient":
                                console.warn("THREE.Loader.createMaterial:", u, "is no longer supported.");
                                break;
                            case "colorDiffuse":
                                c.color = e.fromArray(h).getHex();
                                break;
                            case "colorSpecular":
                                c.specular = e.fromArray(h).getHex();
                                break;
                            case "colorEmissive":
                                c.emissive = e.fromArray(h).getHex();
                                break;
                            case "specularCoef":
                                c.shininess = h;
                                break;
                            case "shading":
                                "basic" === h.toLowerCase() && (c.type = "MeshBasicMaterial"), "phong" === h.toLowerCase() && (c.type = "MeshPhongMaterial"), "standard" === h.toLowerCase() && (c.type = "MeshStandardMaterial");
                                break;
                            case "mapDiffuse":
                                c.map = s(h, r.mapDiffuseRepeat, r.mapDiffuseOffset, r.mapDiffuseWrap, r.mapDiffuseAnisotropy);
                                break;
                            case "mapDiffuseRepeat":
                            case "mapDiffuseOffset":
                            case "mapDiffuseWrap":
                            case "mapDiffuseAnisotropy":
                                break;
                            case "mapEmissive":
                                c.emissiveMap = s(h, r.mapEmissiveRepeat, r.mapEmissiveOffset, r.mapEmissiveWrap, r.mapEmissiveAnisotropy);
                                break;
                            case "mapEmissiveRepeat":
                            case "mapEmissiveOffset":
                            case "mapEmissiveWrap":
                            case "mapEmissiveAnisotropy":
                                break;
                            case "mapLight":
                                c.lightMap = s(h, r.mapLightRepeat, r.mapLightOffset, r.mapLightWrap, r.mapLightAnisotropy);
                                break;
                            case "mapLightRepeat":
                            case "mapLightOffset":
                            case "mapLightWrap":
                            case "mapLightAnisotropy":
                                break;
                            case "mapAO":
                                c.aoMap = s(h, r.mapAORepeat, r.mapAOOffset, r.mapAOWrap, r.mapAOAnisotropy);
                                break;
                            case "mapAORepeat":
                            case "mapAOOffset":
                            case "mapAOWrap":
                            case "mapAOAnisotropy":
                                break;
                            case "mapBump":
                                c.bumpMap = s(h, r.mapBumpRepeat, r.mapBumpOffset, r.mapBumpWrap, r.mapBumpAnisotropy);
                                break;
                            case "mapBumpScale":
                                c.bumpScale = h;
                                break;
                            case "mapBumpRepeat":
                            case "mapBumpOffset":
                            case "mapBumpWrap":
                            case "mapBumpAnisotropy":
                                break;
                            case "mapNormal":
                                c.normalMap = s(h, r.mapNormalRepeat, r.mapNormalOffset, r.mapNormalWrap, r.mapNormalAnisotropy);
                                break;
                            case "mapNormalFactor":
                                c.normalScale = [h, h];
                                break;
                            case "mapNormalRepeat":
                            case "mapNormalOffset":
                            case "mapNormalWrap":
                            case "mapNormalAnisotropy":
                                break;
                            case "mapSpecular":
                                c.specularMap = s(h, r.mapSpecularRepeat, r.mapSpecularOffset, r.mapSpecularWrap, r.mapSpecularAnisotropy);
                                break;
                            case "mapSpecularRepeat":
                            case "mapSpecularOffset":
                            case "mapSpecularWrap":
                            case "mapSpecularAnisotropy":
                                break;
                            case "mapMetalness":
                                c.metalnessMap = s(h, r.mapMetalnessRepeat, r.mapMetalnessOffset, r.mapMetalnessWrap, r.mapMetalnessAnisotropy);
                                break;
                            case "mapMetalnessRepeat":
                            case "mapMetalnessOffset":
                            case "mapMetalnessWrap":
                            case "mapMetalnessAnisotropy":
                                break;
                            case "mapRoughness":
                                c.roughnessMap = s(h, r.mapRoughnessRepeat, r.mapRoughnessOffset, r.mapRoughnessWrap, r.mapRoughnessAnisotropy);
                                break;
                            case "mapRoughnessRepeat":
                            case "mapRoughnessOffset":
                            case "mapRoughnessWrap":
                            case "mapRoughnessAnisotropy":
                                break;
                            case "mapAlpha":
                                c.alphaMap = s(h, r.mapAlphaRepeat, r.mapAlphaOffset, r.mapAlphaWrap, r.mapAlphaAnisotropy);
                                break;
                            case "mapAlphaRepeat":
                            case "mapAlphaOffset":
                            case "mapAlphaWrap":
                            case "mapAlphaAnisotropy":
                                break;
                            case "flipSided":
                                c.side = qr;
                                break;
                            case "doubleSided":
                                c.side = Yr;
                                break;
                            case "transparency":
                                console.warn("THREE.Loader.createMaterial: transparency has been renamed to opacity"), c.opacity = h;
                                break;
                            case "depthTest":
                            case "depthWrite":
                            case "colorWrite":
                            case "opacity":
                            case "reflectivity":
                            case "transparent":
                            case "visible":
                            case "wireframe":
                                c[u] = h;
                                break;
                            case "vertexColors":
                                !0 === h && (c.vertexColors = Jr), "face" === h && (c.vertexColors = Zr);
                                break;
                            default:
                                console.error("THREE.Loader.createMaterial: Unsupported", u, h)
                        }
                    }
                    return "MeshBasicMaterial" === c.type && delete c.emissive, "MeshPhongMaterial" !== c.type && delete c.specular, c.opacity < 1 && (c.transparent = !0), n.setTextures(l), n.parse(c)
                }
            }()
        }), Object.assign(gn.prototype, {
            load: function(t, e, i, n) {
                var r = this,
                    o = this.texturePath && "string" == typeof this.texturePath ? this.texturePath : mn.prototype.extractUrlBase(t),
                    a = new Fi(this.manager);
                a.setWithCredentials(this.withCredentials), a.load(t, function(i) {
                    var n = JSON.parse(i),
                        a = n.metadata;
                    if (void 0 !== a) {
                        var s = a.type;
                        if (void 0 !== s) {
                            if ("object" === s.toLowerCase()) return void console.error("THREE.JSONLoader: " + t + " should be loaded with THREE.ObjectLoader instead.");
                            if ("scene" === s.toLowerCase()) return void console.error("THREE.JSONLoader: " + t + " should be loaded with THREE.SceneLoader instead.")
                        }
                    }
                    var l = r.parse(n, o);
                    e(l.geometry, l.materials)
                }, i, n)
            },
            setTexturePath: function(t) {
                this.texturePath = t
            },
            parse: function() {
                function t(t, e) {
                    function n(t, e) {
                        return t & 1 << e
                    }
                    var r, a, s, l, c, u, h, d, p, f, m, g, v, y, _, x, b, w, T, S, E, M, A, L, C, P = t.faces,
                        R = t.vertices,
                        O = t.normals,
                        I = t.colors,
                        D = t.scale,
                        N = 0;
                    if (void 0 !== t.uvs) {
                        for (r = 0; r < t.uvs.length; r++) t.uvs[r].length && N++;
                        for (r = 0; r < N; r++) e.faceVertexUvs[r] = []
                    }
                    for (l = 0, c = R.length; l < c;)(w = new o).x = R[l++] * D, w.y = R[l++] * D, w.z = R[l++] * D, e.vertices.push(w);
                    for (l = 0, c = P.length; l < c;)
                        if (f = P[l++], m = n(f, 0), g = n(f, 1), v = n(f, 3), y = n(f, 4), _ = n(f, 5), x = n(f, 6), b = n(f, 7), m) {
                            if (S = new dt, S.a = P[l], S.b = P[l + 1], S.c = P[l + 3], E = new dt, E.a = P[l + 1], E.b = P[l + 2], E.c = P[l + 3], l += 4, g && (p = P[l++], S.materialIndex = p, E.materialIndex = p), s = e.faces.length, v)
                                for (r = 0; r < N; r++)
                                    for (L = t.uvs[r], e.faceVertexUvs[r][s] = [], e.faceVertexUvs[r][s + 1] = [], a = 0; a < 4; a++) C = new i(L[2 * (d = P[l++])], L[2 * d + 1]), 2 !== a && e.faceVertexUvs[r][s].push(C), 0 !== a && e.faceVertexUvs[r][s + 1].push(C);
                            if (y && (h = 3 * P[l++], S.normal.set(O[h++], O[h++], O[h]), E.normal.copy(S.normal)), _)
                                for (r = 0; r < 4; r++) h = 3 * P[l++], A = new o(O[h++], O[h++], O[h]), 2 !== r && S.vertexNormals.push(A), 0 !== r && E.vertexNormals.push(A);
                            if (x && (M = I[u = P[l++]], S.color.setHex(M), E.color.setHex(M)), b)
                                for (r = 0; r < 4; r++) M = I[u = P[l++]], 2 !== r && S.vertexColors.push(new q(M)), 0 !== r && E.vertexColors.push(new q(M));
                            e.faces.push(S), e.faces.push(E)
                        } else {
                            if (T = new dt, T.a = P[l++], T.b = P[l++], T.c = P[l++], g && (p = P[l++], T.materialIndex = p), s = e.faces.length, v)
                                for (r = 0; r < N; r++)
                                    for (L = t.uvs[r], e.faceVertexUvs[r][s] = [], a = 0; a < 3; a++) C = new i(L[2 * (d = P[l++])], L[2 * d + 1]), e.faceVertexUvs[r][s].push(C);
                            if (y && (h = 3 * P[l++], T.normal.set(O[h++], O[h++], O[h])), _)
                                for (r = 0; r < 3; r++) h = 3 * P[l++], A = new o(O[h++], O[h++], O[h]), T.vertexNormals.push(A);
                            if (x && (u = P[l++], T.color.setHex(I[u])), b)
                                for (r = 0; r < 3; r++) u = P[l++], T.vertexColors.push(new q(I[u]));
                            e.faces.push(T)
                        }
                }

                function e(t, e) {
                    var i = void 0 !== t.influencesPerVertex ? t.influencesPerVertex : 2;
                    if (t.skinWeights)
                        for (var n = 0, r = t.skinWeights.length; n < r; n += i) {
                            var o = t.skinWeights[n],
                                a = i > 1 ? t.skinWeights[n + 1] : 0,
                                s = i > 2 ? t.skinWeights[n + 2] : 0,
                                c = i > 3 ? t.skinWeights[n + 3] : 0;
                            e.skinWeights.push(new l(o, a, s, c))
                        }
                    if (t.skinIndices)
                        for (var n = 0, r = t.skinIndices.length; n < r; n += i) {
                            var u = t.skinIndices[n],
                                h = i > 1 ? t.skinIndices[n + 1] : 0,
                                d = i > 2 ? t.skinIndices[n + 2] : 0,
                                p = i > 3 ? t.skinIndices[n + 3] : 0;
                            e.skinIndices.push(new l(u, h, d, p))
                        }
                    e.bones = t.bones, e.bones && e.bones.length > 0 && (e.skinWeights.length !== e.skinIndices.length || e.skinIndices.length !== e.vertices.length) && console.warn("When skinning, number of vertices (" + e.vertices.length + "), skinIndices (" + e.skinIndices.length + "), and skinWeights (" + e.skinWeights.length + ") should match.")
                }

                function n(t, e) {
                    var i = t.scale;
                    if (void 0 !== t.morphTargets)
                        for (var n = 0, r = t.morphTargets.length; n < r; n++) {
                            e.morphTargets[n] = {}, e.morphTargets[n].name = t.morphTargets[n].name, e.morphTargets[n].vertices = [];
                            for (var a = e.morphTargets[n].vertices, s = t.morphTargets[n].vertices, l = 0, c = s.length; l < c; l += 3) {
                                var u = new o;
                                u.x = s[l] * i, u.y = s[l + 1] * i, u.z = s[l + 2] * i, a.push(u)
                            }
                        }
                    if (void 0 !== t.morphColors && t.morphColors.length > 0) {
                        console.warn('THREE.JSONLoader: "morphColors" no longer supported. Using them as face colors.');
                        for (var h = e.faces, d = t.morphColors[0].colors, n = 0, r = h.length; n < r; n++) h[n].color.fromArray(d, 3 * n)
                    }
                }

                function r(t, e) {
                    var i = [],
                        n = [];
                    void 0 !== t.animation && n.push(t.animation), void 0 !== t.animations && (t.animations.length ? n = n.concat(t.animations) : n.push(t.animations));
                    for (var r = 0; r < n.length; r++) {
                        var o = dn.parseAnimation(n[r], e.bones);
                        o && i.push(o)
                    }
                    if (e.morphTargets) {
                        var a = dn.CreateClipsFromMorphTargetSequences(e.morphTargets, 10);
                        i = i.concat(a)
                    }
                    i.length > 0 && (e.animations = i)
                }
                return function(i, o) {
                    void 0 !== i.data && (i = i.data), void 0 !== i.scale ? i.scale = 1 / i.scale : i.scale = 1;
                    var a = new pt;
                    return t(i, a), e(i, a), n(i, a), r(i, a), a.computeFaceNormals(), a.computeBoundingSphere(), void 0 === i.materials || 0 === i.materials.length ? {
                        geometry: a
                    } : {
                        geometry: a,
                        materials: mn.prototype.initMaterials(i.materials, o, this.crossOrigin)
                    }
                }
            }()
        }), Object.assign(vn.prototype, {
            load: function(t, e, i, n) {
                "" === this.texturePath && (this.texturePath = t.substring(0, t.lastIndexOf("/") + 1));
                var r = this;
                new Fi(r.manager).load(t, function(i) {
                    var o = null;
                    try {
                        o = JSON.parse(i)
                    } catch (e) {
                        return void 0 !== n && n(e), void console.error("THREE:ObjectLoader: Can't parse " + t + ".", e.message)
                    }
                    var a = o.metadata;
                    void 0 !== a && void 0 !== a.type && "geometry" !== a.type.toLowerCase() ? r.parse(o, e) : console.error("THREE.ObjectLoader: Can't load " + t + ". Use THREE.JSONLoader instead.")
                }, i, n)
            },
            setTexturePath: function(t) {
                this.texturePath = t
            },
            setCrossOrigin: function(t) {
                this.crossOrigin = t
            },
            parse: function(t, e) {
                var i = this.parseGeometries(t.geometries),
                    n = this.parseImages(t.images, function() {
                        void 0 !== e && e(a)
                    }),
                    r = this.parseTextures(t.textures, n),
                    o = this.parseMaterials(t.materials, r),
                    a = this.parseObject(t.object, i, o);
                return t.animations && (a.animations = this.parseAnimations(t.animations)), void 0 !== t.images && 0 !== t.images.length || void 0 !== e && e(a), a
            },
            parseGeometries: function(t) {
                var e = {};
                if (void 0 !== t)
                    for (var i = new gn, n = new fn, r = 0, o = t.length; r < o; r++) {
                        var a, s = t[r];
                        switch (s.type) {
                            case "PlaneGeometry":
                            case "PlaneBufferGeometry":
                                a = new ls[s.type](s.width, s.height, s.widthSegments, s.heightSegments);
                                break;
                            case "BoxGeometry":
                            case "BoxBufferGeometry":
                            case "CubeGeometry":
                                a = new ls[s.type](s.width, s.height, s.depth, s.widthSegments, s.heightSegments, s.depthSegments);
                                break;
                            case "CircleGeometry":
                            case "CircleBufferGeometry":
                                a = new ls[s.type](s.radius, s.segments, s.thetaStart, s.thetaLength);
                                break;
                            case "CylinderGeometry":
                            case "CylinderBufferGeometry":
                                a = new ls[s.type](s.radiusTop, s.radiusBottom, s.height, s.radialSegments, s.heightSegments, s.openEnded, s.thetaStart, s.thetaLength);
                                break;
                            case "ConeGeometry":
                            case "ConeBufferGeometry":
                                a = new ls[s.type](s.radius, s.height, s.radialSegments, s.heightSegments, s.openEnded, s.thetaStart, s.thetaLength);
                                break;
                            case "SphereGeometry":
                            case "SphereBufferGeometry":
                                a = new ls[s.type](s.radius, s.widthSegments, s.heightSegments, s.phiStart, s.phiLength, s.thetaStart, s.thetaLength);
                                break;
                            case "DodecahedronGeometry":
                            case "DodecahedronBufferGeometry":
                            case "IcosahedronGeometry":
                            case "IcosahedronBufferGeometry":
                            case "OctahedronGeometry":
                            case "OctahedronBufferGeometry":
                            case "TetrahedronGeometry":
                            case "TetrahedronBufferGeometry":
                                a = new ls[s.type](s.radius, s.detail);
                                break;
                            case "RingGeometry":
                            case "RingBufferGeometry":
                                a = new ls[s.type](s.innerRadius, s.outerRadius, s.thetaSegments, s.phiSegments, s.thetaStart, s.thetaLength);
                                break;
                            case "TorusGeometry":
                            case "TorusBufferGeometry":
                                a = new ls[s.type](s.radius, s.tube, s.radialSegments, s.tubularSegments, s.arc);
                                break;
                            case "TorusKnotGeometry":
                            case "TorusKnotBufferGeometry":
                                a = new ls[s.type](s.radius, s.tube, s.tubularSegments, s.radialSegments, s.p, s.q);
                                break;
                            case "LatheGeometry":
                            case "LatheBufferGeometry":
                                a = new ls[s.type](s.points, s.segments, s.phiStart, s.phiLength);
                                break;
                            case "PolyhedronGeometry":
                            case "PolyhedronBufferGeometry":
                                a = new ls[s.type](s.vertices, s.indices, s.radius, s.details);
                                break;
                            case "BufferGeometry":
                                a = n.parse(s);
                                break;
                            case "Geometry":
                                a = i.parse(s, this.texturePath).geometry;
                                break;
                            default:
                                console.warn('THREE.ObjectLoader: Unsupported geometry type "' + s.type + '"');
                                continue
                        }
                        a.uuid = s.uuid, void 0 !== s.name && (a.name = s.name), e[s.uuid] = a
                    }
                return e
            },
            parseMaterials: function(t, e) {
                var i = {};
                if (void 0 !== t) {
                    var n = new pn;
                    n.setTextures(e);
                    for (var r = 0, o = t.length; r < o; r++) {
                        var a = t[r];
                        if ("MultiMaterial" === a.type) {
                            for (var s = [], l = 0; l < a.materials.length; l++) s.push(n.parse(a.materials[l]));
                            i[a.uuid] = s
                        } else i[a.uuid] = n.parse(a)
                    }
                }
                return i
            },
            parseAnimations: function(t) {
                for (var e = [], i = 0; i < t.length; i++) {
                    var n = dn.parse(t[i]);
                    e.push(n)
                }
                return e
            },
            parseImages: function(t, e) {
                var i = this,
                    n = {};
                if (void 0 !== t && t.length > 0) {
                    var r = new Bi(new Ni(e));
                    r.setCrossOrigin(this.crossOrigin);
                    for (var o = 0, a = t.length; o < a; o++) {
                        var s = t[o],
                            l = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(s.url) ? s.url : i.texturePath + s.url;
                        n[s.uuid] = function(t) {
                            return i.manager.itemStart(t), r.load(t, function() {
                                i.manager.itemEnd(t)
                            }, void 0, function() {
                                i.manager.itemEnd(t), i.manager.itemError(t)
                            })
                        }(l)
                    }
                }
                return n
            },
            parseTextures: function(t, e) {
                function i(t, e) {
                    return "number" == typeof t ? t : (console.warn("THREE.ObjectLoader.parseTexture: Constant should be in numeric form.", t), e[t])
                }
                var n = {};
                if (void 0 !== t)
                    for (var r = 0, o = t.length; r < o; r++) {
                        var a = t[r];
                        void 0 === a.image && console.warn('THREE.ObjectLoader: No "image" specified for', a.uuid), void 0 === e[a.image] && console.warn("THREE.ObjectLoader: Undefined image", a.image);
                        var l = new s(e[a.image]);
                        l.needsUpdate = !0, l.uuid = a.uuid, void 0 !== a.name && (l.name = a.name), void 0 !== a.mapping && (l.mapping = i(a.mapping, gs)), void 0 !== a.offset && l.offset.fromArray(a.offset), void 0 !== a.repeat && l.repeat.fromArray(a.repeat), void 0 !== a.center && l.center.fromArray(a.center), void 0 !== a.rotation && (l.rotation = a.rotation), void 0 !== a.wrap && (l.wrapS = i(a.wrap[0], vs), l.wrapT = i(a.wrap[1], vs)), void 0 !== a.minFilter && (l.minFilter = i(a.minFilter, ys)), void 0 !== a.magFilter && (l.magFilter = i(a.magFilter, ys)), void 0 !== a.anisotropy && (l.anisotropy = a.anisotropy), void 0 !== a.flipY && (l.flipY = a.flipY), n[a.uuid] = l
                    }
                return n
            },
            parseObject: function() {
                var t = new n;
                return function(e, i, n) {
                    function r(t) {
                        return void 0 === i[t] && console.warn("THREE.ObjectLoader: Undefined geometry", t), i[t]
                    }

                    function o(t) {
                        if (void 0 !== t) {
                            if (Array.isArray(t)) {
                                for (var e = [], i = 0, r = t.length; i < r; i++) {
                                    var o = t[i];
                                    void 0 === n[o] && console.warn("THREE.ObjectLoader: Undefined material", o), e.push(n[o])
                                }
                                return e
                            }
                            return void 0 === n[t] && console.warn("THREE.ObjectLoader: Undefined material", t), n[t]
                        }
                    }
                    var a;
                    switch (e.type) {
                        case "Scene":
                            a = new Se, void 0 !== e.background && Number.isInteger(e.background) && (a.background = new q(e.background)), void 0 !== e.fog && ("Fog" === e.fog.type ? a.fog = new Te(e.fog.color, e.fog.near, e.fog.far) : "FogExp2" === e.fog.type && (a.fog = new we(e.fog.color, e.fog.density)));
                            break;
                        case "PerspectiveCamera":
                            a = new me(e.fov, e.aspect, e.near, e.far), void 0 !== e.focus && (a.focus = e.focus), void 0 !== e.zoom && (a.zoom = e.zoom), void 0 !== e.filmGauge && (a.filmGauge = e.filmGauge), void 0 !== e.filmOffset && (a.filmOffset = e.filmOffset), void 0 !== e.view && (a.view = Object.assign({}, e.view));
                            break;
                        case "OrthographicCamera":
                            a = new ht(e.left, e.right, e.top, e.bottom, e.near, e.far);
                            break;
                        case "AmbientLight":
                            a = new Zi(e.color, e.intensity);
                            break;
                        case "DirectionalLight":
                            a = new Qi(e.color, e.intensity);
                            break;
                        case "PointLight":
                            a = new qi(e.color, e.intensity, e.distance, e.decay);
                            break;
                        case "RectAreaLight":
                            a = new Ji(e.color, e.intensity, e.width, e.height);
                            break;
                        case "SpotLight":
                            a = new Xi(e.color, e.intensity, e.distance, e.angle, e.penumbra, e.decay);
                            break;
                        case "HemisphereLight":
                            a = new Gi(e.color, e.groundColor, e.intensity);
                            break;
                        case "SkinnedMesh":
                            console.warn("THREE.ObjectLoader.parseObject() does not support SkinnedMesh yet.");
                        case "Mesh":
                            var s = r(e.geometry),
                                l = o(e.material);
                            a = s.bones && s.bones.length > 0 ? new Re(s, l) : new Ft(s, l);
                            break;
                        case "LOD":
                            a = new Le;
                            break;
                        case "Line":
                            a = new Ie(r(e.geometry), o(e.material), e.mode);
                            break;
                        case "LineLoop":
                            a = new Ne(r(e.geometry), o(e.material));
                            break;
                        case "LineSegments":
                            a = new De(r(e.geometry), o(e.material));
                            break;
                        case "PointCloud":
                        case "Points":
                            a = new ke(r(e.geometry), o(e.material));
                            break;
                        case "Sprite":
                            a = new Ae(o(e.material));
                            break;
                        case "Group":
                            a = new Ue;
                            break;
                        default:
                            a = new ct
                    }
                    if (a.uuid = e.uuid, void 0 !== e.name && (a.name = e.name), void 0 !== e.matrix ? (t.fromArray(e.matrix), t.decompose(a.position, a.quaternion, a.scale)) : (void 0 !== e.position && a.position.fromArray(e.position), void 0 !== e.rotation && a.rotation.fromArray(e.rotation), void 0 !== e.quaternion && a.quaternion.fromArray(e.quaternion), void 0 !== e.scale && a.scale.fromArray(e.scale)), void 0 !== e.castShadow && (a.castShadow = e.castShadow), void 0 !== e.receiveShadow && (a.receiveShadow = e.receiveShadow), e.shadow && (void 0 !== e.shadow.bias && (a.shadow.bias = e.shadow.bias), void 0 !== e.shadow.radius && (a.shadow.radius = e.shadow.radius), void 0 !== e.shadow.mapSize && a.shadow.mapSize.fromArray(e.shadow.mapSize), void 0 !== e.shadow.camera && (a.shadow.camera = this.parseObject(e.shadow.camera))), void 0 !== e.visible && (a.visible = e.visible), void 0 !== e.userData && (a.userData = e.userData), void 0 !== e.children)
                        for (var c = e.children, u = 0; u < c.length; u++) a.add(this.parseObject(c[u], i, n));
                    if ("LOD" === e.type)
                        for (var h = e.levels, d = 0; d < h.length; d++) {
                            var p = h[d],
                                f = a.getObjectByProperty("uuid", p.object);
                            void 0 !== f && a.addLevel(f, p.distance)
                        }
                    return a
                }
            }()
        });
        var gs = {
                UVMapping: 300,
                CubeReflectionMapping: ko,
                CubeRefractionMapping: Uo,
                EquirectangularReflectionMapping: Bo,
                EquirectangularRefractionMapping: zo,
                SphericalReflectionMapping: jo,
                CubeUVReflectionMapping: Ho,
                CubeUVRefractionMapping: Go
            },
            vs = {
                RepeatWrapping: Vo,
                ClampToEdgeWrapping: Wo,
                MirroredRepeatWrapping: Xo
            },
            ys = {
                NearestFilter: qo,
                NearestMipMapNearestFilter: Yo,
                NearestMipMapLinearFilter: Qo,
                LinearFilter: Zo,
                LinearMipMapNearestFilter: Jo,
                LinearMipMapLinearFilter: $o
            };
        Object.assign(Ln.prototype, {
            getPoint: function() {
                return console.warn("THREE.Curve: .getPoint() not implemented."), null
            },
            getPointAt: function(t, e) {
                var i = this.getUtoTmapping(t);
                return this.getPoint(i, e)
            },
            getPoints: function(t) {
                void 0 === t && (t = 5);
                for (var e = [], i = 0; i <= t; i++) e.push(this.getPoint(i / t));
                return e
            },
            getSpacedPoints: function(t) {
                void 0 === t && (t = 5);
                for (var e = [], i = 0; i <= t; i++) e.push(this.getPointAt(i / t));
                return e
            },
            getLength: function() {
                var t = this.getLengths();
                return t[t.length - 1]
            },
            getLengths: function(t) {
                if (void 0 === t && (t = this.arcLengthDivisions), this.cacheArcLengths && this.cacheArcLengths.length === t + 1 && !this.needsUpdate) return this.cacheArcLengths;
                this.needsUpdate = !1;
                var e, i, n = [],
                    r = this.getPoint(0),
                    o = 0;
                for (n.push(0), i = 1; i <= t; i++) o += (e = this.getPoint(i / t)).distanceTo(r), n.push(o), r = e;
                return this.cacheArcLengths = n, n
            },
            updateArcLengths: function() {
                this.needsUpdate = !0, this.getLengths()
            },
            getUtoTmapping: function(t, e) {
                var i, n = this.getLengths(),
                    r = 0,
                    o = n.length;
                i = e || t * n[o - 1];
                for (var a, s = 0, l = o - 1; s <= l;)
                    if (r = Math.floor(s + (l - s) / 2), (a = n[r] - i) < 0) s = r + 1;
                    else {
                        if (!(a > 0)) {
                            l = r;
                            break
                        }
                        l = r - 1
                    } if (r = l, n[r] === i) return r / (o - 1);
                var c = n[r];
                return (r + (i - c) / (n[r + 1] - c)) / (o - 1)
            },
            getTangent: function(t) {
                var e = t - 1e-4,
                    i = t + 1e-4;
                e < 0 && (e = 0), i > 1 && (i = 1);
                var n = this.getPoint(e);
                return this.getPoint(i).clone().sub(n).normalize()
            },
            getTangentAt: function(t) {
                var e = this.getUtoTmapping(t);
                return this.getTangent(e)
            },
            computeFrenetFrames: function(t, e) {
                var i, r, a, s = new o,
                    l = [],
                    c = [],
                    u = [],
                    h = new o,
                    d = new n;
                for (i = 0; i <= t; i++) r = i / t, l[i] = this.getTangentAt(r), l[i].normalize();
                c[0] = new o, u[0] = new o;
                var p = Number.MAX_VALUE,
                    f = Math.abs(l[0].x),
                    m = Math.abs(l[0].y),
                    g = Math.abs(l[0].z);
                for (f <= p && (p = f, s.set(1, 0, 0)), m <= p && (p = m, s.set(0, 1, 0)), g <= p && s.set(0, 0, 1), h.crossVectors(l[0], s).normalize(), c[0].crossVectors(l[0], h), u[0].crossVectors(l[0], c[0]), i = 1; i <= t; i++) c[i] = c[i - 1].clone(), u[i] = u[i - 1].clone(), h.crossVectors(l[i - 1], l[i]), h.length() > Number.EPSILON && (h.normalize(), a = Math.acos(Ha.clamp(l[i - 1].dot(l[i]), -1, 1)), c[i].applyMatrix4(d.makeRotationAxis(h, a))), u[i].crossVectors(l[i], c[i]);
                if (!0 === e)
                    for (a = Math.acos(Ha.clamp(c[0].dot(c[t]), -1, 1)), a /= t, l[0].dot(h.crossVectors(c[0], c[t])) > 0 && (a = -a), i = 1; i <= t; i++) c[i].applyMatrix4(d.makeRotationAxis(l[i], a * i)), u[i].crossVectors(l[i], c[i]);
                return {
                    tangents: l,
                    normals: c,
                    binormals: u
                }
            },
            clone: function() {
                return (new this.constructor).copy(this)
            },
            copy: function(t) {
                return this.arcLengthDivisions = t.arcLengthDivisions, this
            }
        }), (Cn.prototype = Object.create(Ln.prototype)).constructor = Cn, Cn.prototype.isLineCurve = !0, Cn.prototype.getPoint = function(t, e) {
            var n = e || new i;
            return 1 === t ? n.copy(this.v2) : (n.copy(this.v2).sub(this.v1), n.multiplyScalar(t).add(this.v1)), n
        }, Cn.prototype.getPointAt = function(t, e) {
            return this.getPoint(t, e)
        }, Cn.prototype.getTangent = function() {
            return this.v2.clone().sub(this.v1).normalize()
        }, Cn.prototype.copy = function(t) {
            return Ln.prototype.copy.call(this, t), this.v1.copy(t.v1), this.v2.copy(t.v2), this
        }, Pn.prototype = Object.assign(Object.create(Ln.prototype), {
            constructor: Pn,
            add: function(t) {
                this.curves.push(t)
            },
            closePath: function() {
                var t = this.curves[0].getPoint(0),
                    e = this.curves[this.curves.length - 1].getPoint(1);
                t.equals(e) || this.curves.push(new Cn(e, t))
            },
            getPoint: function(t) {
                for (var e = t * this.getLength(), i = this.getCurveLengths(), n = 0; n < i.length;) {
                    if (i[n] >= e) {
                        var r = i[n] - e,
                            o = this.curves[n],
                            a = o.getLength(),
                            s = 0 === a ? 0 : 1 - r / a;
                        return o.getPointAt(s)
                    }
                    n++
                }
                return null
            },
            getLength: function() {
                var t = this.getCurveLengths();
                return t[t.length - 1]
            },
            updateArcLengths: function() {
                this.needsUpdate = !0, this.cacheLengths = null, this.getCurveLengths()
            },
            getCurveLengths: function() {
                if (this.cacheLengths && this.cacheLengths.length === this.curves.length) return this.cacheLengths;
                for (var t = [], e = 0, i = 0, n = this.curves.length; i < n; i++) e += this.curves[i].getLength(), t.push(e);
                return this.cacheLengths = t, t
            },
            getSpacedPoints: function(t) {
                void 0 === t && (t = 40);
                for (var e = [], i = 0; i <= t; i++) e.push(this.getPoint(i / t));
                return this.autoClose && e.push(e[0]), e
            },
            getPoints: function(t) {
                t = t || 12;
                for (var e, i = [], n = 0, r = this.curves; n < r.length; n++)
                    for (var o = r[n], a = o && o.isEllipseCurve ? 2 * t : o && o.isLineCurve ? 1 : o && o.isSplineCurve ? t * o.points.length : t, s = o.getPoints(a), l = 0; l < s.length; l++) {
                        var c = s[l];
                        e && e.equals(c) || (i.push(c), e = c)
                    }
                return this.autoClose && i.length > 1 && !i[i.length - 1].equals(i[0]) && i.push(i[0]), i
            },
            copy: function(t) {
                Ln.prototype.copy.call(this, t), this.curves = [];
                for (var e = 0, i = t.curves.length; e < i; e++) {
                    var n = t.curves[e];
                    this.curves.push(n.clone())
                }
                return this.autoClose = t.autoClose, this
            }
        }), Rn.prototype = Object.create(Ln.prototype), Rn.prototype.constructor = Rn, Rn.prototype.isEllipseCurve = !0, Rn.prototype.getPoint = function(t, e) {
            for (var n = e || new i, r = 2 * Math.PI, o = this.aEndAngle - this.aStartAngle, a = Math.abs(o) < Number.EPSILON; o < 0;) o += r;
            for (; o > r;) o -= r;
            o < Number.EPSILON && (o = a ? 0 : r), !0 !== this.aClockwise || a || (o === r ? o = -r : o -= r);
            var s = this.aStartAngle + t * o,
                l = this.aX + this.xRadius * Math.cos(s),
                c = this.aY + this.yRadius * Math.sin(s);
            if (0 !== this.aRotation) {
                var u = Math.cos(this.aRotation),
                    h = Math.sin(this.aRotation),
                    d = l - this.aX,
                    p = c - this.aY;
                l = d * u - p * h + this.aX, c = d * h + p * u + this.aY
            }
            return n.set(l, c)
        }, Rn.prototype.copy = function(t) {
            return Ln.prototype.copy.call(this, t), this.aX = t.aX, this.aY = t.aY, this.xRadius = t.xRadius, this.yRadius = t.yRadius, this.aStartAngle = t.aStartAngle, this.aEndAngle = t.aEndAngle, this.aClockwise = t.aClockwise, this.aRotation = t.aRotation, this
        }, (On.prototype = Object.create(Ln.prototype)).constructor = On, On.prototype.isSplineCurve = !0, On.prototype.getPoint = function(t, e) {
            var n = e || new i,
                r = this.points,
                o = (r.length - 1) * t,
                a = Math.floor(o),
                s = o - a,
                l = r[0 === a ? a : a - 1],
                c = r[a],
                u = r[a > r.length - 2 ? r.length - 1 : a + 1],
                h = r[a > r.length - 3 ? r.length - 1 : a + 2];
            return n.set(yn(s, l.x, c.x, u.x, h.x), yn(s, l.y, c.y, u.y, h.y)), n
        }, On.prototype.copy = function(t) {
            Ln.prototype.copy.call(this, t), this.points = [];
            for (var e = 0, i = t.points.length; e < i; e++) {
                var n = t.points[e];
                this.points.push(n.clone())
            }
            return this
        }, (In.prototype = Object.create(Ln.prototype)).constructor = In, In.prototype.isCubicBezierCurve = !0, In.prototype.getPoint = function(t, e) {
            var n = e || new i,
                r = this.v0,
                o = this.v1,
                a = this.v2,
                s = this.v3;
            return n.set(An(t, r.x, o.x, a.x, s.x), An(t, r.y, o.y, a.y, s.y)), n
        }, In.prototype.copy = function(t) {
            return Ln.prototype.copy.call(this, t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t.v2), this.v3.copy(t.v3), this
        }, (Dn.prototype = Object.create(Ln.prototype)).constructor = Dn, Dn.prototype.isQuadraticBezierCurve = !0, Dn.prototype.getPoint = function(t, e) {
            var n = e || new i,
                r = this.v0,
                o = this.v1,
                a = this.v2;
            return n.set(wn(t, r.x, o.x, a.x), wn(t, r.y, o.y, a.y)), n
        }, Dn.prototype.copy = function(t) {
            return Ln.prototype.copy.call(this, t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t.v2), this
        };
        var _s = Object.assign(Object.create(Pn.prototype), {
            setFromPoints: function(t) {
                this.moveTo(t[0].x, t[0].y);
                for (var e = 1, i = t.length; e < i; e++) this.lineTo(t[e].x, t[e].y)
            },
            moveTo: function(t, e) {
                this.currentPoint.set(t, e)
            },
            lineTo: function(t, e) {
                var n = new Cn(this.currentPoint.clone(), new i(t, e));
                this.curves.push(n), this.currentPoint.set(t, e)
            },
            quadraticCurveTo: function(t, e, n, r) {
                var o = new Dn(this.currentPoint.clone(), new i(t, e), new i(n, r));
                this.curves.push(o), this.currentPoint.set(n, r)
            },
            bezierCurveTo: function(t, e, n, r, o, a) {
                var s = new In(this.currentPoint.clone(), new i(t, e), new i(n, r), new i(o, a));
                this.curves.push(s), this.currentPoint.set(o, a)
            },
            splineThru: function(t) {
                var e = new On([this.currentPoint.clone()].concat(t));
                this.curves.push(e), this.currentPoint.copy(t[t.length - 1])
            },
            arc: function(t, e, i, n, r, o) {
                var a = this.currentPoint.x,
                    s = this.currentPoint.y;
                this.absarc(t + a, e + s, i, n, r, o)
            },
            absarc: function(t, e, i, n, r, o) {
                this.absellipse(t, e, i, i, n, r, o)
            },
            ellipse: function(t, e, i, n, r, o, a, s) {
                var l = this.currentPoint.x,
                    c = this.currentPoint.y;
                this.absellipse(t + l, e + c, i, n, r, o, a, s)
            },
            absellipse: function(t, e, i, n, r, o, a, s) {
                var l = new Rn(t, e, i, n, r, o, a, s);
                if (this.curves.length > 0) {
                    var c = l.getPoint(0);
                    c.equals(this.currentPoint) || this.lineTo(c.x, c.y)
                }
                this.curves.push(l);
                var u = l.getPoint(1);
                this.currentPoint.copy(u)
            },
            copy: function(t) {
                return Pn.prototype.copy.call(this, t), this.currentPoint.copy(t.currentPoint), this
            }
        });
        Nn.prototype = _s, _s.constructor = Nn, Fn.prototype = Object.assign(Object.create(_s), {
            constructor: Fn,
            getPointsHoles: function(t) {
                for (var e = [], i = 0, n = this.holes.length; i < n; i++) e[i] = this.holes[i].getPoints(t);
                return e
            },
            extractPoints: function(t) {
                return {
                    shape: this.getPoints(t),
                    holes: this.getPointsHoles(t)
                }
            },
            copy: function(t) {
                Nn.prototype.copy.call(this, t), this.holes = [];
                for (var e = 0, i = t.holes.length; e < i; e++) {
                    var n = t.holes[e];
                    this.holes.push(n.clone())
                }
                return this
            }
        }), Object.assign(kn.prototype, {
            moveTo: function(t, e) {
                this.currentPath = new Nn, this.subPaths.push(this.currentPath), this.currentPath.moveTo(t, e)
            },
            lineTo: function(t, e) {
                this.currentPath.lineTo(t, e)
            },
            quadraticCurveTo: function(t, e, i, n) {
                this.currentPath.quadraticCurveTo(t, e, i, n)
            },
            bezierCurveTo: function(t, e, i, n, r, o) {
                this.currentPath.bezierCurveTo(t, e, i, n, r, o)
            },
            splineThru: function(t) {
                this.currentPath.splineThru(t)
            },
            toShapes: function(t, e) {
                function i(t) {
                    for (var e = [], i = 0, n = t.length; i < n; i++) {
                        var r = t[i],
                            o = new Fn;
                        o.curves = r.curves, e.push(o)
                    }
                    return e
                }
                var n = ss.isClockWise,
                    r = this.subPaths;
                if (0 === r.length) return [];
                if (!0 === e) return i(r);
                var o, a, s, l = [];
                if (1 === r.length) return a = r[0], s = new Fn, s.curves = a.curves, l.push(s), l;
                var c = !n(r[0].getPoints());
                c = t ? !c : c;
                var u, h = [],
                    d = [],
                    p = [],
                    f = 0;
                d[f] = void 0, p[f] = [];
                for (var m = 0, g = r.length; m < g; m++) o = n(u = (a = r[m]).getPoints()), (o = t ? !o : o) ? (!c && d[f] && f++, d[f] = {
                    s: new Fn,
                    p: u
                }, d[f].s.curves = a.curves, c && f++, p[f] = []) : p[f].push({
                    h: a,
                    p: u[0]
                });
                if (!d[0]) return i(r);
                if (d.length > 1) {
                    for (var v = !1, y = [], _ = 0, x = d.length; _ < x; _++) h[_] = [];
                    for (var _ = 0, x = d.length; _ < x; _++)
                        for (var b = p[_], w = 0; w < b.length; w++) {
                            for (var T = b[w], S = !0, E = 0; E < d.length; E++)(function(t, e) {
                                for (var i = e.length, n = !1, r = i - 1, o = 0; o < i; r = o++) {
                                    var a = e[r],
                                        s = e[o],
                                        l = s.x - a.x,
                                        c = s.y - a.y;
                                    if (Math.abs(c) > Number.EPSILON) {
                                        if (c < 0 && (a = e[o], l = -l, s = e[r], c = -c), t.y < a.y || t.y > s.y) continue;
                                        if (t.y === a.y) {
                                            if (t.x === a.x) return !0
                                        } else {
                                            var u = c * (t.x - a.x) - l * (t.y - a.y);
                                            if (0 === u) return !0;
                                            if (u < 0) continue;
                                            n = !n
                                        }
                                    } else {
                                        if (t.y !== a.y) continue;
                                        if (s.x <= t.x && t.x <= a.x || a.x <= t.x && t.x <= s.x) return !0
                                    }
                                }
                                return n
                            })(T.p, d[E].p) && (_ !== E && y.push({
                                froms: _,
                                tos: E,
                                hole: w
                            }), S ? (S = !1, h[E].push(T)) : v = !0);
                            S && h[_].push(T)
                        }
                    y.length > 0 && (v || (p = h))
                }
                for (var M, m = 0, A = d.length; m < A; m++) {
                    s = d[m].s, l.push(s);
                    for (var L = 0, C = (M = p[m]).length; L < C; L++) s.holes.push(M[L].h)
                }
                return l
            }
        }), Object.assign(Un.prototype, {
            isFont: !0,
            generateShapes: function(t, e, i) {
                function n(t, e, n, o) {
                    var a = r.glyphs[t] || r.glyphs["?"];
                    if (a) {
                        var s, l, c, u, h, d, p, f, m, g, v, y = new kn,
                            _ = [];
                        if (a.o)
                            for (var x = a._cachedOutline || (a._cachedOutline = a.o.split(" ")), b = 0, w = x.length; b < w;) switch (x[b++]) {
                                case "m":
                                    s = x[b++] * e + n, l = x[b++] * e + o, y.moveTo(s, l);
                                    break;
                                case "l":
                                    s = x[b++] * e + n, l = x[b++] * e + o, y.lineTo(s, l);
                                    break;
                                case "q":
                                    if (c = x[b++] * e + n, u = x[b++] * e + o, p = x[b++] * e + n, f = x[b++] * e + o, y.quadraticCurveTo(p, f, c, u), v = _[_.length - 1]) {
                                        h = v.x, d = v.y;
                                        for (T = 1; T <= i; T++) wn(S = T / i, h, p, c), wn(S, d, f, u)
                                    }
                                    break;
                                case "b":
                                    if (c = x[b++] * e + n, u = x[b++] * e + o, p = x[b++] * e + n, f = x[b++] * e + o, m = x[b++] * e + n, g = x[b++] * e + o, y.bezierCurveTo(p, f, m, g, c, u), v = _[_.length - 1]) {
                                        h = v.x, d = v.y;
                                        for (var T = 1; T <= i; T++) {
                                            var S = T / i;
                                            An(S, h, p, m, c), An(S, d, f, g, u)
                                        }
                                    }
                            }
                        return {
                            offsetX: a.ha * e,
                            path: y
                        }
                    }
                }
                void 0 === e && (e = 100), void 0 === i && (i = 4);
                for (var r = this.data, o = function(t) {
                        for (var i = String(t).split(""), o = e / r.resolution, a = (r.boundingBox.yMax - r.boundingBox.yMin + r.underlineThickness) * o, s = 0, l = 0, c = [], u = 0; u < i.length; u++) {
                            var h = i[u];
                            if ("\n" === h) s = 0, l -= a;
                            else {
                                var d = n(h, o, s, l);
                                s += d.offsetX, c.push(d.path)
                            }
                        }
                        return c
                    }(t), a = [], s = 0, l = o.length; s < l; s++) Array.prototype.push.apply(a, o[s].toShapes());
                return a
            }
        }), Object.assign(Bn.prototype, {
            load: function(t, e, i, n) {
                var r = this,
                    o = new Fi(this.manager);
                o.setPath(this.path), o.load(t, function(t) {
                    var i;
                    try {
                        i = JSON.parse(t)
                    } catch (e) {
                        console.warn("THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead."), i = JSON.parse(t.substring(65, t.length - 2))
                    }
                    var n = r.parse(i);
                    e && e(n)
                }, i, n)
            },
            parse: function(t) {
                return new Un(t)
            },
            setPath: function(t) {
                return this.path = t, this
            }
        });
        var xs, bs = {
            getContext: function() {
                return void 0 === xs && (xs = new(window.AudioContext || window.webkitAudioContext)), xs
            },
            setContext: function(t) {
                xs = t
            }
        };
        Object.assign(zn.prototype, {
            load: function(t, e, i, n) {
                var r = new Fi(this.manager);
                r.setResponseType("arraybuffer"), r.load(t, function(t) {
                    bs.getContext().decodeAudioData(t, function(t) {
                        e(t)
                    })
                }, i, n)
            }
        }), Object.assign(jn.prototype, {
            update: function() {
                var t, e, i, r, o, a, s, l, c = new n,
                    u = new n;
                return function(n) {
                    if (t !== this || e !== n.focus || i !== n.fov || r !== n.aspect * this.aspect || o !== n.near || a !== n.far || s !== n.zoom || l !== this.eyeSep) {
                        t = this, e = n.focus, i = n.fov, r = n.aspect * this.aspect, o = n.near, a = n.far, s = n.zoom;
                        var h, d, p = n.projectionMatrix.clone(),
                            f = (l = this.eyeSep / 2) * o / e,
                            m = o * Math.tan(Ha.DEG2RAD * i * .5) / s;
                        u.elements[12] = -l, c.elements[12] = l, h = -m * r + f, d = m * r + f, p.elements[0] = 2 * o / (d - h), p.elements[8] = (d + h) / (d - h), this.cameraL.projectionMatrix.copy(p), h = -m * r - f, d = m * r - f, p.elements[0] = 2 * o / (d - h), p.elements[8] = (d + h) / (d - h), this.cameraR.projectionMatrix.copy(p)
                    }
                    this.cameraL.matrixWorld.copy(n.matrixWorld).multiply(u), this.cameraR.matrixWorld.copy(n.matrixWorld).multiply(c)
                }
            }()
        }), (Hn.prototype = Object.create(ct.prototype)).constructor = Hn, Gn.prototype = Object.assign(Object.create(ct.prototype), {
            constructor: Gn,
            getInput: function() {
                return this.gain
            },
            removeFilter: function() {
                null !== this.filter && (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination), this.gain.connect(this.context.destination), this.filter = null)
            },
            getFilter: function() {
                return this.filter
            },
            setFilter: function(t) {
                null !== this.filter ? (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination)) : this.gain.disconnect(this.context.destination), this.filter = t, this.gain.connect(this.filter), this.filter.connect(this.context.destination)
            },
            getMasterVolume: function() {
                return this.gain.gain.value
            },
            setMasterVolume: function(t) {
                this.gain.gain.value = t
            },
            updateMatrixWorld: function() {
                var t = new o,
                    e = new r,
                    i = new o,
                    n = new o;
                return function(r) {
                    ct.prototype.updateMatrixWorld.call(this, r);
                    var o = this.context.listener,
                        a = this.up;
                    this.matrixWorld.decompose(t, e, i), n.set(0, 0, -1).applyQuaternion(e), o.positionX ? (o.positionX.setValueAtTime(t.x, this.context.currentTime), o.positionY.setValueAtTime(t.y, this.context.currentTime), o.positionZ.setValueAtTime(t.z, this.context.currentTime), o.forwardX.setValueAtTime(n.x, this.context.currentTime), o.forwardY.setValueAtTime(n.y, this.context.currentTime), o.forwardZ.setValueAtTime(n.z, this.context.currentTime), o.upX.setValueAtTime(a.x, this.context.currentTime), o.upY.setValueAtTime(a.y, this.context.currentTime), o.upZ.setValueAtTime(a.z, this.context.currentTime)) : (o.setPosition(t.x, t.y, t.z), o.setOrientation(n.x, n.y, n.z, a.x, a.y, a.z))
                }
            }()
        }), Vn.prototype = Object.assign(Object.create(ct.prototype), {
            constructor: Vn,
            getOutput: function() {
                return this.gain
            },
            setNodeSource: function(t) {
                return this.hasPlaybackControl = !1, this.sourceType = "audioNode", this.source = t, this.connect(), this
            },
            setBuffer: function(t) {
                return this.buffer = t, this.sourceType = "buffer", this.autoplay && this.play(), this
            },
            play: function() {
                if (!0 !== this.isPlaying) {
                    if (!1 !== this.hasPlaybackControl) {
                        var t = this.context.createBufferSource();
                        return t.buffer = this.buffer, t.loop = this.loop, t.onended = this.onEnded.bind(this), t.playbackRate.setValueAtTime(this.playbackRate, this.startTime), this.startTime = this.context.currentTime, t.start(this.startTime, this.offset), this.isPlaying = !0, this.source = t, this.connect()
                    }
                    console.warn("THREE.Audio: this Audio has no playback control.")
                } else console.warn("THREE.Audio: Audio is already playing.")
            },
            pause: function() {
                if (!1 !== this.hasPlaybackControl) return !0 === this.isPlaying && (this.source.stop(), this.offset += (this.context.currentTime - this.startTime) * this.playbackRate, this.isPlaying = !1), this;
                console.warn("THREE.Audio: this Audio has no playback control.")
            },
            stop: function() {
                if (!1 !== this.hasPlaybackControl) return this.source.stop(), this.offset = 0, this.isPlaying = !1, this;
                console.warn("THREE.Audio: this Audio has no playback control.")
            },
            connect: function() {
                if (this.filters.length > 0) {
                    this.source.connect(this.filters[0]);
                    for (var t = 1, e = this.filters.length; t < e; t++) this.filters[t - 1].connect(this.filters[t]);
                    this.filters[this.filters.length - 1].connect(this.getOutput())
                } else this.source.connect(this.getOutput());
                return this
            },
            disconnect: function() {
                if (this.filters.length > 0) {
                    this.source.disconnect(this.filters[0]);
                    for (var t = 1, e = this.filters.length; t < e; t++) this.filters[t - 1].disconnect(this.filters[t]);
                    this.filters[this.filters.length - 1].disconnect(this.getOutput())
                } else this.source.disconnect(this.getOutput());
                return this
            },
            getFilters: function() {
                return this.filters
            },
            setFilters: function(t) {
                return t || (t = []), !0 === this.isPlaying ? (this.disconnect(), this.filters = t, this.connect()) : this.filters = t, this
            },
            getFilter: function() {
                return this.getFilters()[0]
            },
            setFilter: function(t) {
                return this.setFilters(t ? [t] : [])
            },
            setPlaybackRate: function(t) {
                if (!1 !== this.hasPlaybackControl) return this.playbackRate = t, !0 === this.isPlaying && this.source.playbackRate.setValueAtTime(this.playbackRate, this.context.currentTime), this;
                console.warn("THREE.Audio: this Audio has no playback control.")
            },
            getPlaybackRate: function() {
                return this.playbackRate
            },
            onEnded: function() {
                this.isPlaying = !1
            },
            getLoop: function() {
                return !1 === this.hasPlaybackControl ? (console.warn("THREE.Audio: this Audio has no playback control."), !1) : this.loop
            },
            setLoop: function(t) {
                if (!1 !== this.hasPlaybackControl) return this.loop = t, !0 === this.isPlaying && (this.source.loop = this.loop), this;
                console.warn("THREE.Audio: this Audio has no playback control.")
            },
            getVolume: function() {
                return this.gain.gain.value
            },
            setVolume: function(t) {
                return this.gain.gain.value = t, this
            }
        }), Wn.prototype = Object.assign(Object.create(Vn.prototype), {
            constructor: Wn,
            getOutput: function() {
                return this.panner
            },
            getRefDistance: function() {
                return this.panner.refDistance
            },
            setRefDistance: function(t) {
                this.panner.refDistance = t
            },
            getRolloffFactor: function() {
                return this.panner.rolloffFactor
            },
            setRolloffFactor: function(t) {
                this.panner.rolloffFactor = t
            },
            getDistanceModel: function() {
                return this.panner.distanceModel
            },
            setDistanceModel: function(t) {
                this.panner.distanceModel = t
            },
            getMaxDistance: function() {
                return this.panner.maxDistance
            },
            setMaxDistance: function(t) {
                this.panner.maxDistance = t
            },
            updateMatrixWorld: function() {
                var t = new o;
                return function(e) {
                    ct.prototype.updateMatrixWorld.call(this, e), t.setFromMatrixPosition(this.matrixWorld), this.panner.setPosition(t.x, t.y, t.z)
                }
            }()
        }), Object.assign(Xn.prototype, {
            getFrequencyData: function() {
                return this.analyser.getByteFrequencyData(this.data), this.data
            },
            getAverageFrequency: function() {
                for (var t = 0, e = this.getFrequencyData(), i = 0; i < e.length; i++) t += e[i];
                return t / e.length
            }
        }), Object.assign(qn.prototype, {
            accumulate: function(t, e) {
                var i = this.buffer,
                    n = this.valueSize,
                    r = t * n + n,
                    o = this.cumulativeWeight;
                if (0 === o) {
                    for (var a = 0; a !== n; ++a) i[r + a] = i[a];
                    o = e
                } else {
                    var s = e / (o += e);
                    this._mixBufferRegion(i, r, 0, s, n)
                }
                this.cumulativeWeight = o
            },
            apply: function(t) {
                var e = this.valueSize,
                    i = this.buffer,
                    n = t * e + e,
                    r = this.cumulativeWeight,
                    o = this.binding;
                if (this.cumulativeWeight = 0, r < 1) {
                    var a = 3 * e;
                    this._mixBufferRegion(i, n, a, 1 - r, e)
                }
                for (var s = e, l = e + e; s !== l; ++s)
                    if (i[s] !== i[s + e]) {
                        o.setValue(i, n);
                        break
                    }
            },
            saveOriginalState: function() {
                var t = this.binding,
                    e = this.buffer,
                    i = this.valueSize,
                    n = 3 * i;
                t.getValue(e, n);
                for (var r = i, o = n; r !== o; ++r) e[r] = e[n + r % i];
                this.cumulativeWeight = 0
            },
            restoreOriginalState: function() {
                var t = 3 * this.valueSize;
                this.binding.setValue(this.buffer, t)
            },
            _select: function(t, e, i, n, r) {
                if (n >= .5)
                    for (var o = 0; o !== r; ++o) t[e + o] = t[i + o]
            },
            _slerp: function(t, e, i, n) {
                r.slerpFlat(t, e, t, e, t, i, n)
            },
            _lerp: function(t, e, i, n, r) {
                for (var o = 1 - n, a = 0; a !== r; ++a) {
                    var s = e + a;
                    t[s] = t[s] * o + t[i + a] * n
                }
            }
        }), Object.assign(Yn.prototype, {
            getValue: function(t, e) {
                this.bind();
                var i = this._targetGroup.nCachedObjects_,
                    n = this._bindings[i];
                void 0 !== n && n.getValue(t, e)
            },
            setValue: function(t, e) {
                for (var i = this._bindings, n = this._targetGroup.nCachedObjects_, r = i.length; n !== r; ++n) i[n].setValue(t, e)
            },
            bind: function() {
                for (var t = this._bindings, e = this._targetGroup.nCachedObjects_, i = t.length; e !== i; ++e) t[e].bind()
            },
            unbind: function() {
                for (var t = this._bindings, e = this._targetGroup.nCachedObjects_, i = t.length; e !== i; ++e) t[e].unbind()
            }
        }), Object.assign(Qn, {
            Composite: Yn,
            create: function(t, e, i) {
                return t && t.isAnimationObjectGroup ? new Qn.Composite(t, e, i) : new Qn(t, e, i)
            },
            sanitizeNodeName: function(t) {
                return t.replace(/\s/g, "_").replace(/[^\w-]/g, "")
            },
            parseTrackName: function() {
                var t = /((?:[\w-]+[\/:])*)/,
                    e = /([\w-\.]+)?/,
                    i = /(?:\.([\w-]+)(?:\[(.+)\])?)?/,
                    n = /\.([\w-]+)(?:\[(.+)\])?/,
                    r = new RegExp("^" + t.source + e.source + i.source + n.source + "$"),
                    o = ["material", "materials", "bones"];
                return function(t) {
                    var e = r.exec(t);
                    if (!e) throw new Error("PropertyBinding: Cannot parse trackName: " + t);
                    var i = {
                            nodeName: e[2],
                            objectName: e[3],
                            objectIndex: e[4],
                            propertyName: e[5],
                            propertyIndex: e[6]
                        },
                        n = i.nodeName && i.nodeName.lastIndexOf(".");
                    if (void 0 !== n && -1 !== n) {
                        var a = i.nodeName.substring(n + 1); - 1 !== o.indexOf(a) && (i.nodeName = i.nodeName.substring(0, n), i.objectName = a)
                    }
                    if (null === i.propertyName || 0 === i.propertyName.length) throw new Error("PropertyBinding: can not parse propertyName from trackName: " + t);
                    return i
                }
            }(),
            findNode: function(t, e) {
                if (!e || "" === e || "root" === e || "." === e || -1 === e || e === t.name || e === t.uuid) return t;
                if (t.skeleton) {
                    var i = function(t) {
                        for (var i = 0; i < t.bones.length; i++) {
                            var n = t.bones[i];
                            if (n.name === e) return n
                        }
                        return null
                    }(t.skeleton);
                    if (i) return i
                }
                if (t.children) {
                    var n = function(t) {
                            for (var i = 0; i < t.length; i++) {
                                var r = t[i];
                                if (r.name === e || r.uuid === e) return r;
                                var o = n(r.children);
                                if (o) return o
                            }
                            return null
                        },
                        r = n(t.children);
                    if (r) return r
                }
                return null
            }
        }), Object.assign(Qn.prototype, {
            _getValue_unavailable: function() {},
            _setValue_unavailable: function() {},
            BindingType: {
                Direct: 0,
                EntireArray: 1,
                ArrayElement: 2,
                HasFromToArray: 3
            },
            Versioning: {
                None: 0,
                NeedsUpdate: 1,
                MatrixWorldNeedsUpdate: 2
            },
            GetterByBindingType: [function(t, e) {
                t[e] = this.node[this.propertyName]
            }, function(t, e) {
                for (var i = this.resolvedProperty, n = 0, r = i.length; n !== r; ++n) t[e++] = i[n]
            }, function(t, e) {
                t[e] = this.resolvedProperty[this.propertyIndex]
            }, function(t, e) {
                this.resolvedProperty.toArray(t, e)
            }],
            SetterByBindingTypeAndVersioning: [
                [function(t, e) {
                    this.targetObject[this.propertyName] = t[e]
                }, function(t, e) {
                    this.targetObject[this.propertyName] = t[e], this.targetObject.needsUpdate = !0
                }, function(t, e) {
                    this.targetObject[this.propertyName] = t[e], this.targetObject.matrixWorldNeedsUpdate = !0
                }],
                [function(t, e) {
                    for (var i = this.resolvedProperty, n = 0, r = i.length; n !== r; ++n) i[n] = t[e++]
                }, function(t, e) {
                    for (var i = this.resolvedProperty, n = 0, r = i.length; n !== r; ++n) i[n] = t[e++];
                    this.targetObject.needsUpdate = !0
                }, function(t, e) {
                    for (var i = this.resolvedProperty, n = 0, r = i.length; n !== r; ++n) i[n] = t[e++];
                    this.targetObject.matrixWorldNeedsUpdate = !0
                }],
                [function(t, e) {
                    this.resolvedProperty[this.propertyIndex] = t[e]
                }, function(t, e) {
                    this.resolvedProperty[this.propertyIndex] = t[e], this.targetObject.needsUpdate = !0
                }, function(t, e) {
                    this.resolvedProperty[this.propertyIndex] = t[e], this.targetObject.matrixWorldNeedsUpdate = !0
                }],
                [function(t, e) {
                    this.resolvedProperty.fromArray(t, e)
                }, function(t, e) {
                    this.resolvedProperty.fromArray(t, e), this.targetObject.needsUpdate = !0
                }, function(t, e) {
                    this.resolvedProperty.fromArray(t, e), this.targetObject.matrixWorldNeedsUpdate = !0
                }]
            ],
            getValue: function(t, e) {
                this.bind(), this.getValue(t, e)
            },
            setValue: function(t, e) {
                this.bind(), this.setValue(t, e)
            },
            bind: function() {
                var t = this.node,
                    e = this.parsedPath,
                    i = e.objectName,
                    n = e.propertyName,
                    r = e.propertyIndex;
                if (t || (t = Qn.findNode(this.rootNode, e.nodeName) || this.rootNode, this.node = t), this.getValue = this._getValue_unavailable, this.setValue = this._setValue_unavailable, t) {
                    if (i) {
                        var o = e.objectIndex;
                        switch (i) {
                            case "materials":
                                if (!t.material) return void console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
                                if (!t.material.materials) return void console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this);
                                t = t.material.materials;
                                break;
                            case "bones":
                                if (!t.skeleton) return void console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this);
                                t = t.skeleton.bones;
                                for (c = 0; c < t.length; c++)
                                    if (t[c].name === o) {
                                        o = c;
                                        break
                                    } break;
                            default:
                                if (void 0 === t[i]) return void console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this);
                                t = t[i]
                        }
                        if (void 0 !== o) {
                            if (void 0 === t[o]) return void console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, t);
                            t = t[o]
                        }
                    }
                    var a = t[n];
                    if (void 0 !== a) {
                        var s = this.Versioning.None;
                        void 0 !== t.needsUpdate ? (s = this.Versioning.NeedsUpdate, this.targetObject = t) : void 0 !== t.matrixWorldNeedsUpdate && (s = this.Versioning.MatrixWorldNeedsUpdate, this.targetObject = t);
                        var l = this.BindingType.Direct;
                        if (void 0 !== r) {
                            if ("morphTargetInfluences" === n) {
                                if (!t.geometry) return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this);
                                if (t.geometry.isBufferGeometry) {
                                    if (!t.geometry.morphAttributes) return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this);
                                    for (c = 0; c < this.node.geometry.morphAttributes.position.length; c++)
                                        if (t.geometry.morphAttributes.position[c].name === r) {
                                            r = c;
                                            break
                                        }
                                } else {
                                    if (!t.geometry.morphTargets) return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphTargets.", this);
                                    for (var c = 0; c < this.node.geometry.morphTargets.length; c++)
                                        if (t.geometry.morphTargets[c].name === r) {
                                            r = c;
                                            break
                                        }
                                }
                            }
                            l = this.BindingType.ArrayElement, this.resolvedProperty = a, this.propertyIndex = r
                        } else void 0 !== a.fromArray && void 0 !== a.toArray ? (l = this.BindingType.HasFromToArray, this.resolvedProperty = a) : Array.isArray(a) ? (l = this.BindingType.EntireArray, this.resolvedProperty = a) : this.propertyName = n;
                        this.getValue = this.GetterByBindingType[l], this.setValue = this.SetterByBindingTypeAndVersioning[l][s]
                    } else {
                        var u = e.nodeName;
                        console.error("THREE.PropertyBinding: Trying to update property for track: " + u + "." + n + " but it wasn't found.", t)
                    }
                } else console.error("THREE.PropertyBinding: Trying to update node for track: " + this.path + " but it wasn't found.")
            },
            unbind: function() {
                this.node = null, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound
            }
        }), Object.assign(Qn.prototype, {
            _getValue_unbound: Qn.prototype.getValue,
            _setValue_unbound: Qn.prototype.setValue
        }), Object.assign(Zn.prototype, {
            isAnimationObjectGroup: !0,
            add: function() {
                for (var t = this._objects, e = t.length, i = this.nCachedObjects_, n = this._indicesByUUID, r = this._paths, o = this._parsedPaths, a = this._bindings, s = a.length, l = 0, c = arguments.length; l !== c; ++l) {
                    var u = arguments[l],
                        h = u.uuid,
                        d = n[h],
                        p = void 0;
                    if (void 0 === d) {
                        d = e++, n[h] = d, t.push(u);
                        for (var f = 0, m = s; f !== m; ++f) a[f].push(new Qn(u, r[f], o[f]))
                    } else if (d < i) {
                        p = t[d];
                        var g = --i,
                            v = t[g];
                        n[v.uuid] = d, t[d] = v, n[h] = g, t[g] = u;
                        for (var f = 0, m = s; f !== m; ++f) {
                            var y = a[f],
                                _ = y[g],
                                x = y[d];
                            y[d] = _, void 0 === x && (x = new Qn(u, r[f], o[f])), y[g] = x
                        }
                    } else t[d] !== p && console.error("THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.")
                }
                this.nCachedObjects_ = i
            },
            remove: function() {
                for (var t = this._objects, e = this.nCachedObjects_, i = this._indicesByUUID, n = this._bindings, r = n.length, o = 0, a = arguments.length; o !== a; ++o) {
                    var s = arguments[o],
                        l = s.uuid,
                        c = i[l];
                    if (void 0 !== c && c >= e) {
                        var u = e++,
                            h = t[u];
                        i[h.uuid] = c, t[c] = h, i[l] = u, t[u] = s;
                        for (var d = 0, p = r; d !== p; ++d) {
                            var f = n[d],
                                m = f[u],
                                g = f[c];
                            f[c] = m, f[u] = g
                        }
                    }
                }
                this.nCachedObjects_ = e
            },
            uncache: function() {
                for (var t = this._objects, e = t.length, i = this.nCachedObjects_, n = this._indicesByUUID, r = this._bindings, o = r.length, a = 0, s = arguments.length; a !== s; ++a) {
                    var l = arguments[a].uuid,
                        c = n[l];
                    if (void 0 !== c)
                        if (delete n[l], c < i) {
                            var u = --i,
                                h = t[u],
                                d = t[v = --e];
                            n[h.uuid] = c, t[c] = h, n[d.uuid] = u, t[u] = d, t.pop();
                            for (var p = 0, f = o; p !== f; ++p) {
                                var m = (y = r[p])[u],
                                    g = y[v];
                                y[c] = m, y[u] = g, y.pop()
                            }
                        } else {
                            var v = --e;
                            n[(d = t[v]).uuid] = c, t[c] = d, t.pop();
                            for (var p = 0, f = o; p !== f; ++p) {
                                var y = r[p];
                                y[c] = y[v], y.pop()
                            }
                        }
                }
                this.nCachedObjects_ = i
            },
            subscribe_: function(t, e) {
                var i = this._bindingsIndicesByPath,
                    n = i[t],
                    r = this._bindings;
                if (void 0 !== n) return r[n];
                var o = this._paths,
                    a = this._parsedPaths,
                    s = this._objects,
                    l = s.length,
                    c = this.nCachedObjects_,
                    u = new Array(l);
                n = r.length, i[t] = n, o.push(t), a.push(e), r.push(u);
                for (var h = c, d = s.length; h !== d; ++h) {
                    var p = s[h];
                    u[h] = new Qn(p, t, e)
                }
                return u
            },
            unsubscribe_: function(t) {
                var e = this._bindingsIndicesByPath,
                    i = e[t];
                if (void 0 !== i) {
                    var n = this._paths,
                        r = this._parsedPaths,
                        o = this._bindings,
                        a = o.length - 1,
                        s = o[a];
                    e[t[a]] = i, o[i] = s, o.pop(), r[i] = r[a], r.pop(), n[i] = n[a], n.pop()
                }
            }
        }), Object.assign(Jn.prototype, {
            play: function() {
                return this._mixer._activateAction(this), this
            },
            stop: function() {
                return this._mixer._deactivateAction(this), this.reset()
            },
            reset: function() {
                return this.paused = !1, this.enabled = !0, this.time = 0, this._loopCount = -1, this._startTime = null, this.stopFading().stopWarping()
            },
            isRunning: function() {
                return this.enabled && !this.paused && 0 !== this.timeScale && null === this._startTime && this._mixer._isActiveAction(this)
            },
            isScheduled: function() {
                return this._mixer._isActiveAction(this)
            },
            startAt: function(t) {
                return this._startTime = t, this
            },
            setLoop: function(t, e) {
                return this.loop = t, this.repetitions = e, this
            },
            setEffectiveWeight: function(t) {
                return this.weight = t, this._effectiveWeight = this.enabled ? t : 0, this.stopFading()
            },
            getEffectiveWeight: function() {
                return this._effectiveWeight
            },
            fadeIn: function(t) {
                return this._scheduleFading(t, 0, 1)
            },
            fadeOut: function(t) {
                return this._scheduleFading(t, 1, 0)
            },
            crossFadeFrom: function(t, e, i) {
                if (t.fadeOut(e), this.fadeIn(e), i) {
                    var n = this._clip.duration,
                        r = t._clip.duration,
                        o = r / n,
                        a = n / r;
                    t.warp(1, o, e), this.warp(a, 1, e)
                }
                return this
            },
            crossFadeTo: function(t, e, i) {
                return t.crossFadeFrom(this, e, i)
            },
            stopFading: function() {
                var t = this._weightInterpolant;
                return null !== t && (this._weightInterpolant = null, this._mixer._takeBackControlInterpolant(t)), this
            },
            setEffectiveTimeScale: function(t) {
                return this.timeScale = t, this._effectiveTimeScale = this.paused ? 0 : t, this.stopWarping()
            },
            getEffectiveTimeScale: function() {
                return this._effectiveTimeScale
            },
            setDuration: function(t) {
                return this.timeScale = this._clip.duration / t, this.stopWarping()
            },
            syncWith: function(t) {
                return this.time = t.time, this.timeScale = t.timeScale, this.stopWarping()
            },
            halt: function(t) {
                return this.warp(this._effectiveTimeScale, 0, t)
            },
            warp: function(t, e, i) {
                var n = this._mixer,
                    r = n.time,
                    o = this._timeScaleInterpolant,
                    a = this.timeScale;
                null === o && (o = n._lendControlInterpolant(), this._timeScaleInterpolant = o);
                var s = o.parameterPositions,
                    l = o.sampleValues;
                return s[0] = r, s[1] = r + i, l[0] = t / a, l[1] = e / a, this
            },
            stopWarping: function() {
                var t = this._timeScaleInterpolant;
                return null !== t && (this._timeScaleInterpolant = null, this._mixer._takeBackControlInterpolant(t)), this
            },
            getMixer: function() {
                return this._mixer
            },
            getClip: function() {
                return this._clip
            },
            getRoot: function() {
                return this._localRoot || this._mixer._root
            },
            _update: function(t, e, i, n) {
                if (this.enabled) {
                    var r = this._startTime;
                    if (null !== r) {
                        var o = (t - r) * i;
                        if (o < 0 || 0 === i) return;
                        this._startTime = null, e = i * o
                    }
                    e *= this._updateTimeScale(t);
                    var a = this._updateTime(e),
                        s = this._updateWeight(t);
                    if (s > 0)
                        for (var l = this._interpolants, c = this._propertyBindings, u = 0, h = l.length; u !== h; ++u) l[u].evaluate(a), c[u].accumulate(n, s)
                } else this._updateWeight(t)
            },
            _updateWeight: function(t) {
                var e = 0;
                if (this.enabled) {
                    e = this.weight;
                    var i = this._weightInterpolant;
                    if (null !== i) {
                        var n = i.evaluate(t)[0];
                        e *= n, t > i.parameterPositions[1] && (this.stopFading(), 0 === n && (this.enabled = !1))
                    }
                }
                return this._effectiveWeight = e, e
            },
            _updateTimeScale: function(t) {
                var e = 0;
                if (!this.paused) {
                    e = this.timeScale;
                    var i = this._timeScaleInterpolant;
                    null !== i && (e *= i.evaluate(t)[0], t > i.parameterPositions[1] && (this.stopWarping(), 0 === e ? this.paused = !0 : this.timeScale = e))
                }
                return this._effectiveTimeScale = e, e
            },
            _updateTime: function(t) {
                var e = this.time + t;
                if (0 === t) return e;
                var i = this._clip.duration,
                    n = this.loop,
                    r = this._loopCount;
                if (2200 === n) {
                    -1 === r && (this._loopCount = 0, this._setEndings(!0, !0, !1));
                    t: {
                        if (e >= i) e = i;
                        else {
                            if (!(e < 0)) break t;
                            e = 0
                        }
                        this.clampWhenFinished ? this.paused = !0 : this.enabled = !1,
                        this._mixer.dispatchEvent({
                            type: "finished",
                            action: this,
                            direction: t < 0 ? -1 : 1
                        })
                    }
                } else {
                    var o = 2202 === n;
                    if (-1 === r && (t >= 0 ? (r = 0, this._setEndings(!0, 0 === this.repetitions, o)) : this._setEndings(0 === this.repetitions, !0, o)), e >= i || e < 0) {
                        var a = Math.floor(e / i);
                        e -= i * a, r += Math.abs(a);
                        var s = this.repetitions - r;
                        if (s < 0) this.clampWhenFinished ? this.paused = !0 : this.enabled = !1, e = t > 0 ? i : 0, this._mixer.dispatchEvent({
                            type: "finished",
                            action: this,
                            direction: t > 0 ? 1 : -1
                        });
                        else {
                            if (0 === s) {
                                var l = t < 0;
                                this._setEndings(l, !l, o)
                            } else this._setEndings(!1, !1, o);
                            this._loopCount = r, this._mixer.dispatchEvent({
                                type: "loop",
                                action: this,
                                loopDelta: a
                            })
                        }
                    }
                    if (o && 1 == (1 & r)) return this.time = e, i - e
                }
                return this.time = e, e
            },
            _setEndings: function(t, e, i) {
                var n = this._interpolantSettings;
                i ? (n.endingStart = 2401, n.endingEnd = 2401) : (n.endingStart = t ? this.zeroSlopeAtStart ? 2401 : Ca : 2402, n.endingEnd = e ? this.zeroSlopeAtEnd ? 2401 : Ca : 2402)
            },
            _scheduleFading: function(t, e, i) {
                var n = this._mixer,
                    r = n.time,
                    o = this._weightInterpolant;
                null === o && (o = n._lendControlInterpolant(), this._weightInterpolant = o);
                var a = o.parameterPositions,
                    s = o.sampleValues;
                return a[0] = r, s[0] = e, a[1] = r + t, s[1] = i, this
            }
        }), Object.assign($n.prototype, e.prototype, {
            _bindAction: function(t, e) {
                var i = t._localRoot || this._root,
                    n = t._clip.tracks,
                    r = n.length,
                    o = t._propertyBindings,
                    a = t._interpolants,
                    s = i.uuid,
                    l = this._bindingsByRootAndName,
                    c = l[s];
                void 0 === c && (c = {}, l[s] = c);
                for (var u = 0; u !== r; ++u) {
                    var h = n[u],
                        d = h.name,
                        p = c[d];
                    if (void 0 !== p) o[u] = p;
                    else {
                        if (void 0 !== (p = o[u])) {
                            null === p._cacheIndex && (++p.referenceCount, this._addInactiveBinding(p, s, d));
                            continue
                        }
                        var f = e && e._propertyBindings[u].binding.parsedPath;
                        ++(p = new qn(Qn.create(i, d, f), h.ValueTypeName, h.getValueSize())).referenceCount, this._addInactiveBinding(p, s, d), o[u] = p
                    }
                    a[u].resultBuffer = p.buffer
                }
            },
            _activateAction: function(t) {
                if (!this._isActiveAction(t)) {
                    if (null === t._cacheIndex) {
                        var e = (t._localRoot || this._root).uuid,
                            i = t._clip.uuid,
                            n = this._actionsByClip[i];
                        this._bindAction(t, n && n.knownActions[0]), this._addInactiveAction(t, i, e)
                    }
                    for (var r = t._propertyBindings, o = 0, a = r.length; o !== a; ++o) {
                        var s = r[o];
                        0 == s.useCount++ && (this._lendBinding(s), s.saveOriginalState())
                    }
                    this._lendAction(t)
                }
            },
            _deactivateAction: function(t) {
                if (this._isActiveAction(t)) {
                    for (var e = t._propertyBindings, i = 0, n = e.length; i !== n; ++i) {
                        var r = e[i];
                        0 == --r.useCount && (r.restoreOriginalState(), this._takeBackBinding(r))
                    }
                    this._takeBackAction(t)
                }
            },
            _initMemoryManager: function() {
                this._actions = [], this._nActiveActions = 0, this._actionsByClip = {}, this._bindings = [], this._nActiveBindings = 0, this._bindingsByRootAndName = {}, this._controlInterpolants = [], this._nActiveControlInterpolants = 0;
                var t = this;
                this.stats = {
                    actions: {
                        get total() {
                            return t._actions.length
                        },
                        get inUse() {
                            return t._nActiveActions
                        }
                    },
                    bindings: {
                        get total() {
                            return t._bindings.length
                        },
                        get inUse() {
                            return t._nActiveBindings
                        }
                    },
                    controlInterpolants: {
                        get total() {
                            return t._controlInterpolants.length
                        },
                        get inUse() {
                            return t._nActiveControlInterpolants
                        }
                    }
                }
            },
            _isActiveAction: function(t) {
                var e = t._cacheIndex;
                return null !== e && e < this._nActiveActions
            },
            _addInactiveAction: function(t, e, i) {
                var n = this._actions,
                    r = this._actionsByClip,
                    o = r[e];
                if (void 0 === o) o = {
                    knownActions: [t],
                    actionByRoot: {}
                }, t._byClipCacheIndex = 0, r[e] = o;
                else {
                    var a = o.knownActions;
                    t._byClipCacheIndex = a.length, a.push(t)
                }
                t._cacheIndex = n.length, n.push(t), o.actionByRoot[i] = t
            },
            _removeInactiveAction: function(t) {
                var e = this._actions,
                    i = e[e.length - 1],
                    n = t._cacheIndex;
                i._cacheIndex = n, e[n] = i, e.pop(), t._cacheIndex = null;
                var r = t._clip.uuid,
                    o = this._actionsByClip,
                    a = o[r],
                    s = a.knownActions,
                    l = s[s.length - 1],
                    c = t._byClipCacheIndex;
                l._byClipCacheIndex = c, s[c] = l, s.pop(), t._byClipCacheIndex = null, delete a.actionByRoot[(t._localRoot || this._root).uuid], 0 === s.length && delete o[r], this._removeInactiveBindingsForAction(t)
            },
            _removeInactiveBindingsForAction: function(t) {
                for (var e = t._propertyBindings, i = 0, n = e.length; i !== n; ++i) {
                    var r = e[i];
                    0 == --r.referenceCount && this._removeInactiveBinding(r)
                }
            },
            _lendAction: function(t) {
                var e = this._actions,
                    i = t._cacheIndex,
                    n = this._nActiveActions++,
                    r = e[n];
                t._cacheIndex = n, e[n] = t, r._cacheIndex = i, e[i] = r
            },
            _takeBackAction: function(t) {
                var e = this._actions,
                    i = t._cacheIndex,
                    n = --this._nActiveActions,
                    r = e[n];
                t._cacheIndex = n, e[n] = t, r._cacheIndex = i, e[i] = r
            },
            _addInactiveBinding: function(t, e, i) {
                var n = this._bindingsByRootAndName,
                    r = n[e],
                    o = this._bindings;
                void 0 === r && (r = {}, n[e] = r), r[i] = t, t._cacheIndex = o.length, o.push(t)
            },
            _removeInactiveBinding: function(t) {
                var e = this._bindings,
                    i = t.binding,
                    n = i.rootNode.uuid,
                    r = i.path,
                    o = this._bindingsByRootAndName,
                    a = o[n],
                    s = e[e.length - 1],
                    l = t._cacheIndex;
                s._cacheIndex = l, e[l] = s, e.pop(), delete a[r];
                t: {
                    for (var c in a) break t;delete o[n]
                }
            },
            _lendBinding: function(t) {
                var e = this._bindings,
                    i = t._cacheIndex,
                    n = this._nActiveBindings++,
                    r = e[n];
                t._cacheIndex = n, e[n] = t, r._cacheIndex = i, e[i] = r
            },
            _takeBackBinding: function(t) {
                var e = this._bindings,
                    i = t._cacheIndex,
                    n = --this._nActiveBindings,
                    r = e[n];
                t._cacheIndex = n, e[n] = t, r._cacheIndex = i, e[i] = r
            },
            _lendControlInterpolant: function() {
                var t = this._controlInterpolants,
                    e = this._nActiveControlInterpolants++,
                    i = t[e];
                return void 0 === i && ((i = new tn(new Float32Array(2), new Float32Array(2), 1, this._controlInterpolantsResultBuffer)).__cacheIndex = e, t[e] = i), i
            },
            _takeBackControlInterpolant: function(t) {
                var e = this._controlInterpolants,
                    i = t.__cacheIndex,
                    n = --this._nActiveControlInterpolants,
                    r = e[n];
                t.__cacheIndex = n, e[n] = t, r.__cacheIndex = i, e[i] = r
            },
            _controlInterpolantsResultBuffer: new Float32Array(1),
            clipAction: function(t, e) {
                var i = e || this._root,
                    n = i.uuid,
                    r = "string" == typeof t ? dn.findByName(i, t) : t,
                    o = null !== r ? r.uuid : t,
                    a = this._actionsByClip[o],
                    s = null;
                if (void 0 !== a) {
                    var l = a.actionByRoot[n];
                    if (void 0 !== l) return l;
                    s = a.knownActions[0], null === r && (r = s._clip)
                }
                if (null === r) return null;
                var c = new Jn(this, r, e);
                return this._bindAction(c, s), this._addInactiveAction(c, o, n), c
            },
            existingAction: function(t, e) {
                var i = e || this._root,
                    n = i.uuid,
                    r = "string" == typeof t ? dn.findByName(i, t) : t,
                    o = r ? r.uuid : t,
                    a = this._actionsByClip[o];
                return void 0 !== a ? a.actionByRoot[n] || null : null
            },
            stopAllAction: function() {
                var t = this._actions,
                    e = this._nActiveActions,
                    i = this._bindings,
                    n = this._nActiveBindings;
                this._nActiveActions = 0, this._nActiveBindings = 0;
                for (r = 0; r !== e; ++r) t[r].reset();
                for (var r = 0; r !== n; ++r) i[r].useCount = 0;
                return this
            },
            update: function(t) {
                t *= this.timeScale;
                for (var e = this._actions, i = this._nActiveActions, n = this.time += t, r = Math.sign(t), o = this._accuIndex ^= 1, a = 0; a !== i; ++a) e[a]._update(n, t, r, o);
                for (var s = this._bindings, l = this._nActiveBindings, a = 0; a !== l; ++a) s[a].apply(o);
                return this
            },
            getRoot: function() {
                return this._root
            },
            uncacheClip: function(t) {
                var e = this._actions,
                    i = t.uuid,
                    n = this._actionsByClip,
                    r = n[i];
                if (void 0 !== r) {
                    for (var o = r.knownActions, a = 0, s = o.length; a !== s; ++a) {
                        var l = o[a];
                        this._deactivateAction(l);
                        var c = l._cacheIndex,
                            u = e[e.length - 1];
                        l._cacheIndex = null, l._byClipCacheIndex = null, u._cacheIndex = c, e[c] = u, e.pop(), this._removeInactiveBindingsForAction(l)
                    }
                    delete n[i]
                }
            },
            uncacheRoot: function(t) {
                var e = t.uuid,
                    i = this._actionsByClip;
                for (var n in i) {
                    var r = i[n].actionByRoot[e];
                    void 0 !== r && (this._deactivateAction(r), this._removeInactiveAction(r))
                }
                var o = this._bindingsByRootAndName[e];
                if (void 0 !== o)
                    for (var a in o) {
                        var s = o[a];
                        s.restoreOriginalState(), this._removeInactiveBinding(s)
                    }
            },
            uncacheAction: function(t, e) {
                var i = this.existingAction(t, e);
                null !== i && (this._deactivateAction(i), this._removeInactiveAction(i))
            }
        }), Kn.prototype.clone = function() {
            return new Kn(void 0 === this.value.clone ? this.value : this.value.clone())
        }, tr.prototype = Object.assign(Object.create(Mt.prototype), {
            constructor: tr,
            isInstancedBufferGeometry: !0,
            copy: function(t) {
                return Mt.prototype.copy.call(this, t), this.maxInstancedCount = t.maxInstancedCount, this
            },
            clone: function() {
                return (new this.constructor).copy(this)
            }
        }), Object.defineProperties(er.prototype, {
            count: {
                get: function() {
                    return this.data.count
                }
            },
            array: {
                get: function() {
                    return this.data.array
                }
            }
        }), Object.assign(er.prototype, {
            isInterleavedBufferAttribute: !0,
            setX: function(t, e) {
                return this.data.array[t * this.data.stride + this.offset] = e, this
            },
            setY: function(t, e) {
                return this.data.array[t * this.data.stride + this.offset + 1] = e, this
            },
            setZ: function(t, e) {
                return this.data.array[t * this.data.stride + this.offset + 2] = e, this
            },
            setW: function(t, e) {
                return this.data.array[t * this.data.stride + this.offset + 3] = e, this
            },
            getX: function(t) {
                return this.data.array[t * this.data.stride + this.offset]
            },
            getY: function(t) {
                return this.data.array[t * this.data.stride + this.offset + 1]
            },
            getZ: function(t) {
                return this.data.array[t * this.data.stride + this.offset + 2]
            },
            getW: function(t) {
                return this.data.array[t * this.data.stride + this.offset + 3]
            },
            setXY: function(t, e, i) {
                return t = t * this.data.stride + this.offset, this.data.array[t + 0] = e, this.data.array[t + 1] = i, this
            },
            setXYZ: function(t, e, i, n) {
                return t = t * this.data.stride + this.offset, this.data.array[t + 0] = e, this.data.array[t + 1] = i, this.data.array[t + 2] = n, this
            },
            setXYZW: function(t, e, i, n, r) {
                return t = t * this.data.stride + this.offset, this.data.array[t + 0] = e, this.data.array[t + 1] = i, this.data.array[t + 2] = n, this.data.array[t + 3] = r, this
            }
        }), Object.defineProperty(ir.prototype, "needsUpdate", {
            set: function(t) {
                !0 === t && this.version++
            }
        }), Object.assign(ir.prototype, {
            isInterleavedBuffer: !0,
            setArray: function(t) {
                if (Array.isArray(t)) throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
                this.count = void 0 !== t ? t.length / this.stride : 0, this.array = t
            },
            setDynamic: function(t) {
                return this.dynamic = t, this
            },
            copy: function(t) {
                return this.array = new t.array.constructor(t.array), this.count = t.count, this.stride = t.stride, this.dynamic = t.dynamic, this
            },
            copyAt: function(t, e, i) {
                t *= this.stride, i *= e.stride;
                for (var n = 0, r = this.stride; n < r; n++) this.array[t + n] = e.array[i + n];
                return this
            },
            set: function(t, e) {
                return void 0 === e && (e = 0), this.array.set(t, e), this
            },
            clone: function() {
                return (new this.constructor).copy(this)
            },
            onUpload: function(t) {
                return this.onUploadCallback = t, this
            }
        }), nr.prototype = Object.assign(Object.create(ir.prototype), {
            constructor: nr,
            isInstancedInterleavedBuffer: !0,
            copy: function(t) {
                return ir.prototype.copy.call(this, t), this.meshPerAttribute = t.meshPerAttribute, this
            }
        }), rr.prototype = Object.assign(Object.create(ft.prototype), {
            constructor: rr,
            isInstancedBufferAttribute: !0,
            copy: function(t) {
                return ft.prototype.copy.call(this, t), this.meshPerAttribute = t.meshPerAttribute, this
            }
        }), Object.assign(or.prototype, {
            linePrecision: 1,
            set: function(t, e) {
                this.ray.set(t, e)
            },
            setFromCamera: function(t, e) {
                e && e.isPerspectiveCamera ? (this.ray.origin.setFromMatrixPosition(e.matrixWorld), this.ray.direction.set(t.x, t.y, .5).unproject(e).sub(this.ray.origin).normalize()) : e && e.isOrthographicCamera ? (this.ray.origin.set(t.x, t.y, (e.near + e.far) / (e.near - e.far)).unproject(e), this.ray.direction.set(0, 0, -1).transformDirection(e.matrixWorld)) : console.error("THREE.Raycaster: Unsupported camera type.")
            },
            intersectObject: function(t, e) {
                var i = [];
                return sr(t, this, i, e), i.sort(ar), i
            },
            intersectObjects: function(t, e) {
                var i = [];
                if (!1 === Array.isArray(t)) return console.warn("THREE.Raycaster.intersectObjects: objects is not an Array."), i;
                for (var n = 0, r = t.length; n < r; n++) sr(t[n], this, i, e);
                return i.sort(ar), i
            }
        }), Object.assign(lr.prototype, {
            start: function() {
                this.startTime = ("undefined" == typeof performance ? Date : performance).now(), this.oldTime = this.startTime, this.elapsedTime = 0, this.running = !0
            },
            stop: function() {
                this.getElapsedTime(), this.running = !1, this.autoStart = !1
            },
            getElapsedTime: function() {
                return this.getDelta(), this.elapsedTime
            },
            getDelta: function() {
                var t = 0;
                if (this.autoStart && !this.running) return this.start(), 0;
                if (this.running) {
                    var e = ("undefined" == typeof performance ? Date : performance).now();
                    t = (e - this.oldTime) / 1e3, this.oldTime = e, this.elapsedTime += t
                }
                return t
            }
        }), Object.assign(cr.prototype, {
            set: function(t, e, i) {
                return this.radius = t, this.phi = e, this.theta = i, this
            },
            clone: function() {
                return (new this.constructor).copy(this)
            },
            copy: function(t) {
                return this.radius = t.radius, this.phi = t.phi, this.theta = t.theta, this
            },
            makeSafe: function() {
                return this.phi = Math.max(1e-6, Math.min(Math.PI - 1e-6, this.phi)), this
            },
            setFromVector3: function(t) {
                return this.radius = t.length(), 0 === this.radius ? (this.theta = 0, this.phi = 0) : (this.theta = Math.atan2(t.x, t.z), this.phi = Math.acos(Ha.clamp(t.y / this.radius, -1, 1))), this
            }
        }), Object.assign(ur.prototype, {
            set: function(t, e, i) {
                return this.radius = t, this.theta = e, this.y = i, this
            },
            clone: function() {
                return (new this.constructor).copy(this)
            },
            copy: function(t) {
                return this.radius = t.radius, this.theta = t.theta, this.y = t.y, this
            },
            setFromVector3: function(t) {
                return this.radius = Math.sqrt(t.x * t.x + t.z * t.z), this.theta = Math.atan2(t.x, t.z), this.y = t.y, this
            }
        }), (hr.prototype = Object.create(ct.prototype)).constructor = hr, hr.prototype.isImmediateRenderObject = !0, (dr.prototype = Object.create(De.prototype)).constructor = dr, dr.prototype.update = function() {
            var t = new o,
                e = new o,
                i = new a;
            return function() {
                var n = ["a", "b", "c"];
                this.object.updateMatrixWorld(!0), i.getNormalMatrix(this.object.matrixWorld);
                var r = this.object.matrixWorld,
                    o = this.geometry.attributes.position,
                    a = this.object.geometry;
                if (a && a.isGeometry)
                    for (var s = a.vertices, l = a.faces, c = 0, u = 0, h = l.length; u < h; u++)
                        for (var d = l[u], p = 0, f = d.vertexNormals.length; p < f; p++) {
                            var m = s[d[n[p]]],
                                g = d.vertexNormals[p];
                            t.copy(m).applyMatrix4(r), e.copy(g).applyMatrix3(i).normalize().multiplyScalar(this.size).add(t), o.setXYZ(c, t.x, t.y, t.z), c += 1, o.setXYZ(c, e.x, e.y, e.z), c += 1
                        } else if (a && a.isBufferGeometry)
                            for (var v = a.attributes.position, y = a.attributes.normal, c = 0, p = 0, f = v.count; p < f; p++) t.set(v.getX(p), v.getY(p), v.getZ(p)).applyMatrix4(r), e.set(y.getX(p), y.getY(p), y.getZ(p)), e.applyMatrix3(i).normalize().multiplyScalar(this.size).add(t), o.setXYZ(c, t.x, t.y, t.z), c += 1, o.setXYZ(c, e.x, e.y, e.z), c += 1;
                o.needsUpdate = !0
            }
        }(), (pr.prototype = Object.create(ct.prototype)).constructor = pr, pr.prototype.dispose = function() {
            this.cone.geometry.dispose(), this.cone.material.dispose()
        }, pr.prototype.update = function() {
            var t = new o,
                e = new o;
            return function() {
                this.light.updateMatrixWorld();
                var i = this.light.distance ? this.light.distance : 1e3,
                    n = i * Math.tan(this.light.angle);
                this.cone.scale.set(n, n, i), t.setFromMatrixPosition(this.light.matrixWorld), e.setFromMatrixPosition(this.light.target.matrixWorld), this.cone.lookAt(e.sub(t)), void 0 !== this.color ? this.cone.material.color.set(this.color) : this.cone.material.color.copy(this.light.color)
            }
        }(), (mr.prototype = Object.create(De.prototype)).constructor = mr, mr.prototype.updateMatrixWorld = function() {
            var t = new o,
                e = new n,
                i = new n;
            return function(n) {
                var r = this.bones,
                    o = this.geometry,
                    a = o.getAttribute("position");
                i.getInverse(this.root.matrixWorld);
                for (var s = 0, l = 0; s < r.length; s++) {
                    var c = r[s];
                    c.parent && c.parent.isBone && (e.multiplyMatrices(i, c.matrixWorld), t.setFromMatrixPosition(e), a.setXYZ(l, t.x, t.y, t.z), e.multiplyMatrices(i, c.parent.matrixWorld), t.setFromMatrixPosition(e), a.setXYZ(l + 1, t.x, t.y, t.z), l += 2)
                }
                o.getAttribute("position").needsUpdate = !0, ct.prototype.updateMatrixWorld.call(this, n)
            }
        }(), (gr.prototype = Object.create(Ft.prototype)).constructor = gr, gr.prototype.dispose = function() {
            this.geometry.dispose(), this.material.dispose()
        }, gr.prototype.update = function() {
            void 0 !== this.color ? this.material.color.set(this.color) : this.material.color.copy(this.light.color)
        }, (vr.prototype = Object.create(ct.prototype)).constructor = vr, vr.prototype.dispose = function() {
            this.children[0].geometry.dispose(), this.children[0].material.dispose()
        }, vr.prototype.update = function() {
            var t = .5 * this.light.width,
                e = .5 * this.light.height,
                i = this.line.geometry.attributes.position,
                n = i.array;
            n[0] = t, n[1] = -e, n[2] = 0, n[3] = t, n[4] = e, n[5] = 0, n[6] = -t, n[7] = e, n[8] = 0, n[9] = -t, n[10] = -e, n[11] = 0, n[12] = t, n[13] = -e, n[14] = 0, i.needsUpdate = !0, void 0 !== this.color ? this.line.material.color.set(this.color) : this.line.material.color.copy(this.light.color)
        }, (yr.prototype = Object.create(ct.prototype)).constructor = yr, yr.prototype.dispose = function() {
            this.children[0].geometry.dispose(), this.children[0].material.dispose()
        }, yr.prototype.update = function() {
            var t = new o,
                e = new q,
                i = new q;
            return function() {
                var n = this.children[0];
                if (void 0 !== this.color) this.material.color.set(this.color);
                else {
                    var r = n.geometry.getAttribute("color");
                    e.copy(this.light.color), i.copy(this.light.groundColor);
                    for (var o = 0, a = r.count; o < a; o++) {
                        var s = o < a / 2 ? e : i;
                        r.setXYZ(o, s.r, s.g, s.b)
                    }
                    r.needsUpdate = !0
                }
                n.lookAt(t.setFromMatrixPosition(this.light.matrixWorld).negate())
            }
        }(), (_r.prototype = Object.create(De.prototype)).constructor = _r, (xr.prototype = Object.create(De.prototype)).constructor = xr, (br.prototype = Object.create(De.prototype)).constructor = br, br.prototype.update = function() {
            var t = new o,
                e = new o,
                i = new a;
            return function() {
                this.object.updateMatrixWorld(!0), i.getNormalMatrix(this.object.matrixWorld);
                for (var n = this.object.matrixWorld, r = this.geometry.attributes.position, o = this.object.geometry, a = o.vertices, s = o.faces, l = 0, c = 0, u = s.length; c < u; c++) {
                    var h = s[c],
                        d = h.normal;
                    t.copy(a[h.a]).add(a[h.b]).add(a[h.c]).divideScalar(3).applyMatrix4(n), e.copy(d).applyMatrix3(i).normalize().multiplyScalar(this.size).add(t), r.setXYZ(l, t.x, t.y, t.z), l += 1, r.setXYZ(l, e.x, e.y, e.z), l += 1
                }
                r.needsUpdate = !0
            }
        }(), (wr.prototype = Object.create(ct.prototype)).constructor = wr, wr.prototype.dispose = function() {
            this.lightPlane.geometry.dispose(), this.lightPlane.material.dispose(), this.targetLine.geometry.dispose(), this.targetLine.material.dispose()
        }, wr.prototype.update = function() {
            var t = new o,
                e = new o,
                i = new o;
            return function() {
                t.setFromMatrixPosition(this.light.matrixWorld), e.setFromMatrixPosition(this.light.target.matrixWorld), i.subVectors(e, t), this.lightPlane.lookAt(i), void 0 !== this.color ? (this.lightPlane.material.color.set(this.color), this.targetLine.material.color.set(this.color)) : (this.lightPlane.material.color.copy(this.light.color), this.targetLine.material.color.copy(this.light.color)), this.targetLine.lookAt(i), this.targetLine.scale.z = i.length()
            }
        }(), (Tr.prototype = Object.create(De.prototype)).constructor = Tr, Tr.prototype.update = function() {
            function t(t, o, a, s) {
                n.set(o, a, s).unproject(r);
                var l = i[t];
                if (void 0 !== l)
                    for (var c = e.getAttribute("position"), u = 0, h = l.length; u < h; u++) c.setXYZ(l[u], n.x, n.y, n.z)
            }
            var e, i, n = new o,
                r = new ut;
            return function() {
                e = this.geometry, i = this.pointMap;
                r.projectionMatrix.copy(this.camera.projectionMatrix), t("c", 0, 0, -1), t("t", 0, 0, 1), t("n1", -1, -1, -1), t("n2", 1, -1, -1), t("n3", -1, 1, -1), t("n4", 1, 1, -1), t("f1", -1, -1, 1), t("f2", 1, -1, 1), t("f3", -1, 1, 1), t("f4", 1, 1, 1), t("u1", .7, 1.1, -1), t("u2", -.7, 1.1, -1), t("u3", 0, 2, -1), t("cf1", -1, 0, 1), t("cf2", 1, 0, 1), t("cf3", 0, -1, 1), t("cf4", 0, 1, 1), t("cn1", -1, 0, -1), t("cn2", 1, 0, -1), t("cn3", 0, -1, -1), t("cn4", 0, 1, -1), e.getAttribute("position").needsUpdate = !0
            }
        }(), Sr.prototype = Object.create(De.prototype), Sr.prototype.constructor = Sr, Sr.prototype.update = function() {
            var t = new et;
            return function(e) {
                if (void 0 !== e && console.warn("THREE.BoxHelper: .update() has no longer arguments."), void 0 !== this.object && t.setFromObject(this.object), !t.isEmpty()) {
                    var i = t.min,
                        n = t.max,
                        r = this.geometry.attributes.position,
                        o = r.array;
                    o[0] = n.x, o[1] = n.y, o[2] = n.z, o[3] = i.x, o[4] = n.y, o[5] = n.z, o[6] = i.x, o[7] = i.y, o[8] = n.z, o[9] = n.x, o[10] = i.y, o[11] = n.z, o[12] = n.x, o[13] = n.y, o[14] = i.z, o[15] = i.x, o[16] = n.y, o[17] = i.z, o[18] = i.x, o[19] = i.y, o[20] = i.z, o[21] = n.x, o[22] = i.y, o[23] = i.z, r.needsUpdate = !0, this.geometry.computeBoundingSphere()
                }
            }
        }(), Sr.prototype.setFromObject = function(t) {
            return this.object = t, this.update(), this
        }, (Er.prototype = Object.create(De.prototype)).constructor = Er, Er.prototype.updateMatrixWorld = function(t) {
            var e = this.box;
            e.isEmpty() || (e.getCenter(this.position), e.getSize(this.scale), this.scale.multiplyScalar(.5), ct.prototype.updateMatrixWorld.call(this, t))
        }, (Mr.prototype = Object.create(Ie.prototype)).constructor = Mr, Mr.prototype.updateMatrixWorld = function(t) {
            var e = -this.plane.constant;
            Math.abs(e) < 1e-8 && (e = 1e-8), this.scale.set(.5 * this.size, .5 * this.size, e), this.lookAt(this.plane.normal), ct.prototype.updateMatrixWorld.call(this, t)
        };
        var ws, Ts;
        (Ar.prototype = Object.create(ct.prototype)).constructor = Ar, Ar.prototype.setDirection = function() {
            var t, e = new o;
            return function(i) {
                i.y > .99999 ? this.quaternion.set(0, 0, 0, 1) : i.y < -.99999 ? this.quaternion.set(1, 0, 0, 0) : (e.set(i.z, 0, -i.x).normalize(), t = Math.acos(i.y), this.quaternion.setFromAxisAngle(e, t))
            }
        }(), Ar.prototype.setLength = function(t, e, i) {
            void 0 === e && (e = .2 * t), void 0 === i && (i = .2 * e), this.line.scale.set(1, Math.max(0, t - e), 1), this.line.updateMatrix(), this.cone.scale.set(i, e, i), this.cone.position.y = t, this.cone.updateMatrix()
        }, Ar.prototype.setColor = function(t) {
            this.line.material.color.copy(t), this.cone.material.color.copy(t)
        }, Lr.prototype = Object.create(De.prototype), Lr.prototype.constructor = Lr;
        var Ss = new o,
            Es = new Cr,
            Ms = new Cr,
            As = new Cr;
        Pr.prototype = Object.create(Ln.prototype), Pr.prototype.constructor = Pr, Pr.prototype.isCatmullRomCurve3 = !0, Pr.prototype.getPoint = function(t, e) {
            var i = e || new o,
                n = this.points,
                r = n.length,
                a = (r - (this.closed ? 0 : 1)) * t,
                s = Math.floor(a),
                l = a - s;
            this.closed ? s += s > 0 ? 0 : (Math.floor(Math.abs(s) / n.length) + 1) * n.length : 0 === l && s === r - 1 && (s = r - 2, l = 1);
            var c, u, h, d;
            if (this.closed || s > 0 ? c = n[(s - 1) % r] : (Ss.subVectors(n[0], n[1]).add(n[0]), c = Ss), u = n[s % r], h = n[(s + 1) % r], this.closed || s + 2 < r ? d = n[(s + 2) % r] : (Ss.subVectors(n[r - 1], n[r - 2]).add(n[r - 1]), d = Ss), "centripetal" === this.curveType || "chordal" === this.curveType) {
                var p = "chordal" === this.curveType ? .5 : .25,
                    f = Math.pow(c.distanceToSquared(u), p),
                    m = Math.pow(u.distanceToSquared(h), p),
                    g = Math.pow(h.distanceToSquared(d), p);
                m < 1e-4 && (m = 1), f < 1e-4 && (f = m), g < 1e-4 && (g = m), Es.initNonuniformCatmullRom(c.x, u.x, h.x, d.x, f, m, g), Ms.initNonuniformCatmullRom(c.y, u.y, h.y, d.y, f, m, g), As.initNonuniformCatmullRom(c.z, u.z, h.z, d.z, f, m, g)
            } else "catmullrom" === this.curveType && (Es.initCatmullRom(c.x, u.x, h.x, d.x, this.tension), Ms.initCatmullRom(c.y, u.y, h.y, d.y, this.tension), As.initCatmullRom(c.z, u.z, h.z, d.z, this.tension));
            return i.set(Es.calc(l), Ms.calc(l), As.calc(l)), i
        }, Pr.prototype.copy = function(t) {
            Ln.prototype.copy.call(this, t), this.points = [];
            for (var e = 0, i = t.points.length; e < i; e++) {
                var n = t.points[e];
                this.points.push(n.clone())
            }
            return this.closed = t.closed, this.curveType = t.curveType, this.tension = t.tension, this
        }, (Rr.prototype = Object.create(Ln.prototype)).constructor = Rr, Rr.prototype.isCubicBezierCurve3 = !0, Rr.prototype.getPoint = function(t, e) {
            var i = e || new o,
                n = this.v0,
                r = this.v1,
                a = this.v2,
                s = this.v3;
            return i.set(An(t, n.x, r.x, a.x, s.x), An(t, n.y, r.y, a.y, s.y), An(t, n.z, r.z, a.z, s.z)), i
        }, Rr.prototype.copy = function(t) {
            return Ln.prototype.copy.call(this, t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t.v2), this.v3.copy(t.v3), this
        }, (Or.prototype = Object.create(Ln.prototype)).constructor = Or, Or.prototype.isQuadraticBezierCurve3 = !0, Or.prototype.getPoint = function(t, e) {
            var i = e || new o,
                n = this.v0,
                r = this.v1,
                a = this.v2;
            return i.set(wn(t, n.x, r.x, a.x), wn(t, n.y, r.y, a.y), wn(t, n.z, r.z, a.z)), i
        }, Or.prototype.copy = function(t) {
            return Ln.prototype.copy.call(this, t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t.v2), this
        }, (Ir.prototype = Object.create(Ln.prototype)).constructor = Ir, Ir.prototype.isLineCurve3 = !0, Ir.prototype.getPoint = function(t, e) {
            var i = e || new o;
            return 1 === t ? i.copy(this.v2) : (i.copy(this.v2).sub(this.v1), i.multiplyScalar(t).add(this.v1)), i
        }, Ir.prototype.getPointAt = function(t, e) {
            return this.getPoint(t, e)
        }, Ir.prototype.copy = function(t) {
            return Ln.prototype.copy.call(this, t), this.v1.copy(t.v1), this.v2.copy(t.v2), this
        }, (Dr.prototype = Object.create(Rn.prototype)).constructor = Dr, Dr.prototype.isArcCurve = !0;
        var Ls = {
            createMultiMaterialObject: function(t, e) {
                for (var i = new Ue, n = 0, r = e.length; n < r; n++) i.add(new Ft(t, e[n]));
                return i
            },
            detach: function(t, e, i) {
                t.applyMatrix(e.matrixWorld), e.remove(t), i.add(t)
            },
            attach: function(t, e, i) {
                t.applyMatrix((new n).getInverse(i.matrixWorld)), e.remove(t), i.add(t)
            }
        };
        Ln.create = function(t, e) {
            return console.log("THREE.Curve.create() has been deprecated"), t.prototype = Object.create(Ln.prototype), t.prototype.constructor = t, t.prototype.getPoint = e, t
        }, Object.assign(Pn.prototype, {
            createPointsGeometry: function(t) {
                console.warn("THREE.CurvePath: .createPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.");
                var e = this.getPoints(t);
                return this.createGeometry(e)
            },
            createSpacedPointsGeometry: function(t) {
                console.warn("THREE.CurvePath: .createSpacedPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.");
                var e = this.getSpacedPoints(t);
                return this.createGeometry(e)
            },
            createGeometry: function(t) {
                console.warn("THREE.CurvePath: .createGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.");
                for (var e = new pt, i = 0, n = t.length; i < n; i++) {
                    var r = t[i];
                    e.vertices.push(new o(r.x, r.y, r.z || 0))
                }
                return e
            }
        }), Object.assign(Nn.prototype, {
            fromPoints: function(t) {
                console.warn("THREE.Path: .fromPoints() has been renamed to .setFromPoints()."), this.setFromPoints(t)
            }
        }), Nr.prototype = Object.create(Pr.prototype), Fr.prototype = Object.create(Pr.prototype), kr.prototype = Object.create(Pr.prototype), Object.assign(kr.prototype, {
            initFromArray: function() {
                console.error("THREE.Spline: .initFromArray() has been removed.")
            },
            getControlPointsArray: function() {
                console.error("THREE.Spline: .getControlPointsArray() has been removed.")
            },
            reparametrizeByArcLength: function() {
                console.error("THREE.Spline: .reparametrizeByArcLength() has been removed.")
            }
        }), _r.prototype.setColors = function() {
            console.error("THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.")
        }, mr.prototype.update = function() {
            console.error("THREE.SkeletonHelper: update() no longer needs to be called.")
        }, Object.assign(Y.prototype, {
            center: function(t) {
                return console.warn("THREE.Box2: .center() has been renamed to .getCenter()."), this.getCenter(t)
            },
            empty: function() {
                return console.warn("THREE.Box2: .empty() has been renamed to .isEmpty()."), this.isEmpty()
            },
            isIntersectionBox: function(t) {
                return console.warn("THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(t)
            },
            size: function(t) {
                return console.warn("THREE.Box2: .size() has been renamed to .getSize()."), this.getSize(t)
            }
        }), Object.assign(et.prototype, {
            center: function(t) {
                return console.warn("THREE.Box3: .center() has been renamed to .getCenter()."), this.getCenter(t)
            },
            empty: function() {
                return console.warn("THREE.Box3: .empty() has been renamed to .isEmpty()."), this.isEmpty()
            },
            isIntersectionBox: function(t) {
                return console.warn("THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(t)
            },
            isIntersectionSphere: function(t) {
                return console.warn("THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere()."), this.intersectsSphere(t)
            },
            size: function(t) {
                return console.warn("THREE.Box3: .size() has been renamed to .getSize()."), this.getSize(t)
            }
        }), Dt.prototype.center = function(t) {
            return console.warn("THREE.Line3: .center() has been renamed to .getCenter()."), this.getCenter(t)
        }, Object.assign(Ha, {
            random16: function() {
                return console.warn("THREE.Math: .random16() has been deprecated. Use Math.random() instead."), Math.random()
            },
            nearestPowerOfTwo: function(t) {
                return console.warn("THREE.Math: .nearestPowerOfTwo() has been renamed to .floorPowerOfTwo()."), Ha.floorPowerOfTwo(t)
            },
            nextPowerOfTwo: function(t) {
                return console.warn("THREE.Math: .nextPowerOfTwo() has been renamed to .ceilPowerOfTwo()."), Ha.ceilPowerOfTwo(t)
            }
        }), Object.assign(a.prototype, {
            flattenToArrayOffset: function(t, e) {
                return console.warn("THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."), this.toArray(t, e)
            },
            multiplyVector3: function(t) {
                return console.warn("THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead."), t.applyMatrix3(this)
            },
            multiplyVector3Array: function() {
                console.error("THREE.Matrix3: .multiplyVector3Array() has been removed.")
            },
            applyToBuffer: function(t) {
                return console.warn("THREE.Matrix3: .applyToBuffer() has been removed. Use matrix.applyToBufferAttribute( attribute ) instead."), this.applyToBufferAttribute(t)
            },
            applyToVector3Array: function() {
                console.error("THREE.Matrix3: .applyToVector3Array() has been removed.")
            }
        }), Object.assign(n.prototype, {
            extractPosition: function(t) {
                return console.warn("THREE.Matrix4: .extractPosition() has been renamed to .copyPosition()."), this.copyPosition(t)
            },
            flattenToArrayOffset: function(t, e) {
                return console.warn("THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."), this.toArray(t, e)
            },
            getPosition: function() {
                var t;
                return function() {
                    return void 0 === t && (t = new o), console.warn("THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead."), t.setFromMatrixColumn(this, 3)
                }
            }(),
            setRotationFromQuaternion: function(t) {
                return console.warn("THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion()."), this.makeRotationFromQuaternion(t)
            },
            multiplyToArray: function() {
                console.warn("THREE.Matrix4: .multiplyToArray() has been removed.")
            },
            multiplyVector3: function(t) {
                return console.warn("THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead."), t.applyMatrix4(this)
            },
            multiplyVector4: function(t) {
                return console.warn("THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead."), t.applyMatrix4(this)
            },
            multiplyVector3Array: function() {
                console.error("THREE.Matrix4: .multiplyVector3Array() has been removed.")
            },
            rotateAxis: function(t) {
                console.warn("THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead."), t.transformDirection(this)
            },
            crossVector: function(t) {
                return console.warn("THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead."), t.applyMatrix4(this)
            },
            translate: function() {
                console.error("THREE.Matrix4: .translate() has been removed.")
            },
            rotateX: function() {
                console.error("THREE.Matrix4: .rotateX() has been removed.")
            },
            rotateY: function() {
                console.error("THREE.Matrix4: .rotateY() has been removed.")
            },
            rotateZ: function() {
                console.error("THREE.Matrix4: .rotateZ() has been removed.")
            },
            rotateByAxis: function() {
                console.error("THREE.Matrix4: .rotateByAxis() has been removed.")
            },
            applyToBuffer: function(t) {
                return console.warn("THREE.Matrix4: .applyToBuffer() has been removed. Use matrix.applyToBufferAttribute( attribute ) instead."), this.applyToBufferAttribute(t)
            },
            applyToVector3Array: function() {
                console.error("THREE.Matrix4: .applyToVector3Array() has been removed.")
            },
            makeFrustum: function(t, e, i, n, r, o) {
                return console.warn("THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead."), this.makePerspective(t, e, n, i, r, o)
            }
        }), nt.prototype.isIntersectionLine = function(t) {
            return console.warn("THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine()."), this.intersectsLine(t)
        }, r.prototype.multiplyVector3 = function(t) {
            return console.warn("THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead."), t.applyQuaternion(this)
        }, Object.assign(It.prototype, {
            isIntersectionBox: function(t) {
                return console.warn("THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(t)
            },
            isIntersectionPlane: function(t) {
                return console.warn("THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane()."), this.intersectsPlane(t)
            },
            isIntersectionSphere: function(t) {
                return console.warn("THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere()."), this.intersectsSphere(t)
            }
        }), Object.assign(Fn.prototype, {
            extractAllPoints: function(t) {
                return console.warn("THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead."), this.extractPoints(t)
            },
            extrude: function(t) {
                return console.warn("THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead."), new si(this, t)
            },
            makeGeometry: function(t) {
                return console.warn("THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead."), new vi(this, t)
            }
        }), Object.assign(i.prototype, {
            fromAttribute: function(t, e, i) {
                return console.warn("THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(t, e, i)
            },
            distanceToManhattan: function(t) {
                return console.warn("THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."), this.manhattanDistanceTo(t)
            },
            lengthManhattan: function() {
                return console.warn("THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength()
            }
        }), Object.assign(o.prototype, {
            setEulerFromRotationMatrix: function() {
                console.error("THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.")
            },
            setEulerFromQuaternion: function() {
                console.error("THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.")
            },
            getPositionFromMatrix: function(t) {
                return console.warn("THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition()."), this.setFromMatrixPosition(t)
            },
            getScaleFromMatrix: function(t) {
                return console.warn("THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale()."), this.setFromMatrixScale(t)
            },
            getColumnFromMatrix: function(t, e) {
                return console.warn("THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn()."), this.setFromMatrixColumn(e, t)
            },
            applyProjection: function(t) {
                return console.warn("THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead."), this.applyMatrix4(t)
            },
            fromAttribute: function(t, e, i) {
                return console.warn("THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(t, e, i)
            },
            distanceToManhattan: function(t) {
                return console.warn("THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."), this.manhattanDistanceTo(t)
            },
            lengthManhattan: function() {
                return console.warn("THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength()
            }
        }), Object.assign(l.prototype, {
            fromAttribute: function(t, e, i) {
                return console.warn("THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(t, e, i)
            },
            lengthManhattan: function() {
                return console.warn("THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength()
            }
        }), pt.prototype.computeTangents = function() {
            console.warn("THREE.Geometry: .computeTangents() has been removed.")
        }, Object.assign(ct.prototype, {
            getChildByName: function(t) {
                return console.warn("THREE.Object3D: .getChildByName() has been renamed to .getObjectByName()."), this.getObjectByName(t)
            },
            renderDepth: function() {
                console.warn("THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.")
            },
            translate: function(t, e) {
                return console.warn("THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead."), this.translateOnAxis(e, t)
            }
        }), Object.defineProperties(ct.prototype, {
            eulerOrder: {
                get: function() {
                    return console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."), this.rotation.order
                },
                set: function(t) {
                    console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."), this.rotation.order = t
                }
            },
            useQuaternion: {
                get: function() {
                    console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")
                },
                set: function() {
                    console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")
                }
            }
        }), Object.defineProperties(Le.prototype, {
            objects: {
                get: function() {
                    return console.warn("THREE.LOD: .objects has been renamed to .levels."), this.levels
                }
            }
        }), Object.defineProperty(Ce.prototype, "useVertexTexture", {
            get: function() {
                console.warn("THREE.Skeleton: useVertexTexture has been removed.")
            },
            set: function() {
                console.warn("THREE.Skeleton: useVertexTexture has been removed.")
            }
        }), Object.defineProperty(Ln.prototype, "__arcLengthDivisions", {
            get: function() {
                return console.warn("THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions."), this.arcLengthDivisions
            },
            set: function(t) {
                console.warn("THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions."), this.arcLengthDivisions = t
            }
        }), me.prototype.setLens = function(t, e) {
            console.warn("THREE.PerspectiveCamera.setLens is deprecated. Use .setFocalLength and .filmGauge for a photographic setup."), void 0 !== e && (this.filmGauge = e), this.setFocalLength(t)
        }, Object.defineProperties(Hi.prototype, {
            onlyShadow: {
                set: function() {
                    console.warn("THREE.Light: .onlyShadow has been removed.")
                }
            },
            shadowCameraFov: {
                set: function(t) {
                    console.warn("THREE.Light: .shadowCameraFov is now .shadow.camera.fov."), this.shadow.camera.fov = t
                }
            },
            shadowCameraLeft: {
                set: function(t) {
                    console.warn("THREE.Light: .shadowCameraLeft is now .shadow.camera.left."), this.shadow.camera.left = t
                }
            },
            shadowCameraRight: {
                set: function(t) {
                    console.warn("THREE.Light: .shadowCameraRight is now .shadow.camera.right."), this.shadow.camera.right = t
                }
            },
            shadowCameraTop: {
                set: function(t) {
                    console.warn("THREE.Light: .shadowCameraTop is now .shadow.camera.top."), this.shadow.camera.top = t
                }
            },
            shadowCameraBottom: {
                set: function(t) {
                    console.warn("THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom."), this.shadow.camera.bottom = t
                }
            },
            shadowCameraNear: {
                set: function(t) {
                    console.warn("THREE.Light: .shadowCameraNear is now .shadow.camera.near."), this.shadow.camera.near = t
                }
            },
            shadowCameraFar: {
                set: function(t) {
                    console.warn("THREE.Light: .shadowCameraFar is now .shadow.camera.far."), this.shadow.camera.far = t
                }
            },
            shadowCameraVisible: {
                set: function() {
                    console.warn("THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.")
                }
            },
            shadowBias: {
                set: function(t) {
                    console.warn("THREE.Light: .shadowBias is now .shadow.bias."), this.shadow.bias = t
                }
            },
            shadowDarkness: {
                set: function() {
                    console.warn("THREE.Light: .shadowDarkness has been removed.")
                }
            },
            shadowMapWidth: {
                set: function(t) {
                    console.warn("THREE.Light: .shadowMapWidth is now .shadow.mapSize.width."), this.shadow.mapSize.width = t
                }
            },
            shadowMapHeight: {
                set: function(t) {
                    console.warn("THREE.Light: .shadowMapHeight is now .shadow.mapSize.height."), this.shadow.mapSize.height = t
                }
            }
        }), Object.defineProperties(ft.prototype, {
            length: {
                get: function() {
                    return console.warn("THREE.BufferAttribute: .length has been deprecated. Use .count instead."), this.array.length
                }
            }
        }), Object.assign(Mt.prototype, {
            addIndex: function(t) {
                console.warn("THREE.BufferGeometry: .addIndex() has been renamed to .setIndex()."), this.setIndex(t)
            },
            addDrawCall: function(t, e, i) {
                void 0 !== i && console.warn("THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset."), console.warn("THREE.BufferGeometry: .addDrawCall() is now .addGroup()."), this.addGroup(t, e)
            },
            clearDrawCalls: function() {
                console.warn("THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups()."), this.clearGroups()
            },
            computeTangents: function() {
                console.warn("THREE.BufferGeometry: .computeTangents() has been removed.")
            },
            computeOffsets: function() {
                console.warn("THREE.BufferGeometry: .computeOffsets() has been removed.")
            }
        }), Object.defineProperties(Mt.prototype, {
            drawcalls: {
                get: function() {
                    return console.error("THREE.BufferGeometry: .drawcalls has been renamed to .groups."), this.groups
                }
            },
            offsets: {
                get: function() {
                    return console.warn("THREE.BufferGeometry: .offsets has been renamed to .groups."), this.groups
                }
            }
        }), Object.defineProperties(Kn.prototype, {
            dynamic: {
                set: function() {
                    console.warn("THREE.Uniform: .dynamic has been removed. Use object.onBeforeRender() instead.")
                }
            },
            onUpdate: {
                value: function() {
                    return console.warn("THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead."), this
                }
            }
        }), Object.defineProperties($.prototype, {
            wrapAround: {
                get: function() {
                    console.warn("THREE.Material: .wrapAround has been removed.")
                },
                set: function() {
                    console.warn("THREE.Material: .wrapAround has been removed.")
                }
            },
            wrapRGB: {
                get: function() {
                    return console.warn("THREE.Material: .wrapRGB has been removed."), new q
                }
            },
            shading: {
                get: function() {
                    console.error("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead.")
                },
                set: function(t) {
                    console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead."), this.flatShading = 1 === t
                }
            }
        }), Object.defineProperties(Pi.prototype, {
            metal: {
                get: function() {
                    return console.warn("THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead."), !1
                },
                set: function() {
                    console.warn("THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead")
                }
            }
        }), Object.defineProperties(Ot.prototype, {
            derivatives: {
                get: function() {
                    return console.warn("THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives."), this.extensions.derivatives
                },
                set: function(t) {
                    console.warn("THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives."), this.extensions.derivatives = t
                }
            }
        }), Object.assign(be.prototype, {
            getCurrentRenderTarget: function() {
                return console.warn("THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget()."), this.getRenderTarget()
            },
            getMaxAnisotropy: function() {
                return console.warn("THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy()."), this.capabilities.getMaxAnisotropy()
            },
            getPrecision: function() {
                return console.warn("THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision."), this.capabilities.precision
            },
            resetGLState: function() {
                return console.warn("THREE.WebGLRenderer: .resetGLState() is now .state.reset()."), this.state.reset()
            },
            supportsFloatTextures: function() {
                return console.warn("THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' )."), this.extensions.get("OES_texture_float")
            },
            supportsHalfFloatTextures: function() {
                return console.warn("THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' )."), this.extensions.get("OES_texture_half_float")
            },
            supportsStandardDerivatives: function() {
                return console.warn("THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' )."), this.extensions.get("OES_standard_derivatives")
            },
            supportsCompressedTextureS3TC: function() {
                return console.warn("THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' )."), this.extensions.get("WEBGL_compressed_texture_s3tc")
            },
            supportsCompressedTexturePVRTC: function() {
                return console.warn("THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' )."), this.extensions.get("WEBGL_compressed_texture_pvrtc")
            },
            supportsBlendMinMax: function() {
                return console.warn("THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' )."), this.extensions.get("EXT_blend_minmax")
            },
            supportsVertexTextures: function() {
                return console.warn("THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures."), this.capabilities.vertexTextures
            },
            supportsInstancedArrays: function() {
                return console.warn("THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' )."), this.extensions.get("ANGLE_instanced_arrays")
            },
            enableScissorTest: function(t) {
                console.warn("THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest()."), this.setScissorTest(t)
            },
            initMaterial: function() {
                console.warn("THREE.WebGLRenderer: .initMaterial() has been removed.")
            },
            addPrePlugin: function() {
                console.warn("THREE.WebGLRenderer: .addPrePlugin() has been removed.")
            },
            addPostPlugin: function() {
                console.warn("THREE.WebGLRenderer: .addPostPlugin() has been removed.")
            },
            updateShadowMap: function() {
                console.warn("THREE.WebGLRenderer: .updateShadowMap() has been removed.")
            }
        }), Object.defineProperties(be.prototype, {
            shadowMapEnabled: {
                get: function() {
                    return this.shadowMap.enabled
                },
                set: function(t) {
                    console.warn("THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled."), this.shadowMap.enabled = t
                }
            },
            shadowMapType: {
                get: function() {
                    return this.shadowMap.type
                },
                set: function(t) {
                    console.warn("THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type."), this.shadowMap.type = t
                }
            },
            shadowMapCullFace: {
                get: function() {
                    return this.shadowMap.cullFace
                },
                set: function(t) {
                    console.warn("THREE.WebGLRenderer: .shadowMapCullFace is now .shadowMap.cullFace."), this.shadowMap.cullFace = t
                }
            }
        }), Object.defineProperties(ot.prototype, {
            cullFace: {
                get: function() {
                    return this.renderReverseSided ? Hr : jr
                },
                set: function(t) {
                    var e = t !== jr;
                    console.warn("WebGLRenderer: .shadowMap.cullFace is deprecated. Set .shadowMap.renderReverseSided to " + e + "."), this.renderReverseSided = e
                }
            }
        }), Object.defineProperties(c.prototype, {
            wrapS: {
                get: function() {
                    return console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."), this.texture.wrapS
                },
                set: function(t) {
                    console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."), this.texture.wrapS = t
                }
            },
            wrapT: {
                get: function() {
                    return console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."), this.texture.wrapT
                },
                set: function(t) {
                    console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."), this.texture.wrapT = t
                }
            },
            magFilter: {
                get: function() {
                    return console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."), this.texture.magFilter
                },
                set: function(t) {
                    console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."), this.texture.magFilter = t
                }
            },
            minFilter: {
                get: function() {
                    return console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."), this.texture.minFilter
                },
                set: function(t) {
                    console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."), this.texture.minFilter = t
                }
            },
            anisotropy: {
                get: function() {
                    return console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."), this.texture.anisotropy
                },
                set: function(t) {
                    console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."), this.texture.anisotropy = t
                }
            },
            offset: {
                get: function() {
                    return console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."), this.texture.offset
                },
                set: function(t) {
                    console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."), this.texture.offset = t
                }
            },
            repeat: {
                get: function() {
                    return console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."), this.texture.repeat
                },
                set: function(t) {
                    console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."), this.texture.repeat = t
                }
            },
            format: {
                get: function() {
                    return console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."), this.texture.format
                },
                set: function(t) {
                    console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."), this.texture.format = t
                }
            },
            type: {
                get: function() {
                    return console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."), this.texture.type
                },
                set: function(t) {
                    console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."), this.texture.type = t
                }
            },
            generateMipmaps: {
                get: function() {
                    return console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."), this.texture.generateMipmaps
                },
                set: function(t) {
                    console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."), this.texture.generateMipmaps = t
                }
            }
        }), Vn.prototype.load = function(t) {
            console.warn("THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.");
            var e = this;
            return (new zn).load(t, function(t) {
                e.setBuffer(t)
            }), this
        }, Xn.prototype.getData = function() {
            return console.warn("THREE.AudioAnalyser: .getData() is now .getFrequencyData()."), this.getFrequencyData()
        }, Hn.prototype.updateCubeMap = function(t, e) {
            return console.warn("THREE.CubeCamera: .updateCubeMap() is now .update()."), this.update(t, e)
        };
        var Cs = {
                merge: function(t, e, i) {
                    console.warn("THREE.GeometryUtils: .merge() has been moved to Geometry. Use geometry.merge( geometry2, matrix, materialIndexOffset ) instead.");
                    var n;
                    e.isMesh && (e.matrixAutoUpdate && e.updateMatrix(), n = e.matrix, e = e.geometry), t.merge(e, n, i)
                },
                center: function(t) {
                    return console.warn("THREE.GeometryUtils: .center() has been moved to Geometry. Use geometry.center() instead."), t.center()
                }
            },
            Ps = {
                crossOrigin: void 0,
                loadTexture: function(t, e, i, n) {
                    console.warn("THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.");
                    var r = new ji;
                    r.setCrossOrigin(this.crossOrigin);
                    var o = r.load(t, i, void 0, n);
                    return e && (o.mapping = e), o
                },
                loadTextureCube: function(t, e, i, n) {
                    console.warn("THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.");
                    var r = new zi;
                    r.setCrossOrigin(this.crossOrigin);
                    var o = r.load(t, i, void 0, n);
                    return e && (o.mapping = e), o
                },
                loadCompressedTexture: function() {
                    console.error("THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.")
                },
                loadCompressedTextureCube: function() {
                    console.error("THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.")
                }
            };
        t.WebGLRenderTargetCube = u, t.WebGLRenderTarget = c, t.WebGLRenderer = be, t.ShaderLib = es, t.UniformsLib = $a, t.UniformsUtils = Ka, t.ShaderChunk = ts, t.FogExp2 = we, t.Fog = Te, t.Scene = Se, t.LensFlare = Ee, t.Sprite = Ae, t.LOD = Le, t.SkinnedMesh = Re, t.Skeleton = Ce, t.Bone = Pe, t.Mesh = Ft, t.LineSegments = De, t.LineLoop = Ne, t.Line = Ie, t.Points = ke, t.Group = Ue, t.VideoTexture = Be, t.DataTexture = h, t.CompressedTexture = ze, t.CubeTexture = d, t.CanvasTexture = Z, t.DepthTexture = je, t.Texture = s, t.CompressedTextureLoader = ki, t.DataTextureLoader = Ui, t.CubeTextureLoader = zi, t.TextureLoader = ji, t.ObjectLoader = vn, t.MaterialLoader = pn, t.BufferGeometryLoader = fn, t.DefaultLoadingManager = hs, t.LoadingManager = Ni, t.JSONLoader = gn, t.ImageLoader = Bi, t.FontLoader = Bn, t.FileLoader = Fi, t.Loader = mn, t.Cache = us, t.AudioLoader = zn, t.SpotLightShadow = Wi, t.SpotLight = Xi, t.PointLight = qi, t.RectAreaLight = Ji, t.HemisphereLight = Gi, t.DirectionalLightShadow = Yi, t.DirectionalLight = Qi, t.AmbientLight = Zi, t.LightShadow = Vi, t.Light = Hi, t.StereoCamera = jn, t.PerspectiveCamera = me, t.OrthographicCamera = ht, t.CubeCamera = Hn, t.ArrayCamera = ge, t.Camera = ut, t.AudioListener = Gn, t.PositionalAudio = Wn, t.AudioContext = bs, t.AudioAnalyser = Xn, t.Audio = Vn, t.VectorKeyframeTrack = rn, t.StringKeyframeTrack = ln, t.QuaternionKeyframeTrack = an, t.NumberKeyframeTrack = sn, t.ColorKeyframeTrack = un, t.BooleanKeyframeTrack = cn, t.PropertyMixer = qn, t.PropertyBinding = Qn, t.KeyframeTrack = hn, t.AnimationUtils = ps, t.AnimationObjectGroup = Zn, t.AnimationMixer = $n, t.AnimationClip = dn, t.Uniform = Kn, t.InstancedBufferGeometry = tr, t.BufferGeometry = Mt, t.Geometry = pt, t.InterleavedBufferAttribute = er, t.InstancedInterleavedBuffer = nr, t.InterleavedBuffer = ir, t.InstancedBufferAttribute = rr, t.Face3 = dt, t.Object3D = ct, t.Raycaster = or, t.Layers = lt, t.EventDispatcher = e, t.Clock = lr, t.QuaternionLinearInterpolant = on, t.LinearInterpolant = tn, t.DiscreteInterpolant = en, t.CubicInterpolant = Ki, t.Interpolant = $i, t.Triangle = Nt, t.Math = Ha, t.Spherical = cr, t.Cylindrical = ur, t.Plane = nt, t.Frustum = rt, t.Sphere = it, t.Ray = It, t.Matrix4 = n, t.Matrix3 = a, t.Box3 = et, t.Box2 = Y, t.Line3 = Dt, t.Euler = st, t.Vector4 = l, t.Vector3 = o, t.Vector2 = i, t.Quaternion = r, t.Color = q, t.ImmediateRenderObject = hr, t.VertexNormalsHelper = dr, t.SpotLightHelper = pr, t.SkeletonHelper = mr, t.PointLightHelper = gr, t.RectAreaLightHelper = vr, t.HemisphereLightHelper = yr, t.GridHelper = _r, t.PolarGridHelper = xr, t.FaceNormalsHelper = br, t.DirectionalLightHelper = wr, t.CameraHelper = Tr, t.BoxHelper = Sr, t.Box3Helper = Er, t.PlaneHelper = Mr, t.ArrowHelper = Ar, t.AxesHelper = Lr, t.CatmullRomCurve3 = Pr, t.CubicBezierCurve3 = Rr, t.QuadraticBezierCurve3 = Or, t.LineCurve3 = Ir, t.ArcCurve = Dr, t.EllipseCurve = Rn, t.SplineCurve = On, t.CubicBezierCurve = In, t.QuadraticBezierCurve = Dn, t.LineCurve = Cn, t.Shape = Fn, t.Path = Nn, t.ShapePath = kn, t.Font = Un, t.CurvePath = Pn, t.Curve = Ln, t.ShapeUtils = ss, t.SceneUtils = Ls, t.WebGLUtils = xe, t.WireframeGeometry = He, t.ParametricGeometry = Ge, t.ParametricBufferGeometry = Ve, t.TetrahedronGeometry = qe, t.TetrahedronBufferGeometry = Ye, t.OctahedronGeometry = Qe, t.OctahedronBufferGeometry = Ze, t.IcosahedronGeometry = Je, t.IcosahedronBufferGeometry = $e, t.DodecahedronGeometry = Ke, t.DodecahedronBufferGeometry = ti, t.PolyhedronGeometry = We, t.PolyhedronBufferGeometry = Xe, t.TubeGeometry = ei, t.TubeBufferGeometry = ii, t.TorusKnotGeometry = ni, t.TorusKnotBufferGeometry = ri, t.TorusGeometry = oi, t.TorusBufferGeometry = ai, t.TextGeometry = ci, t.TextBufferGeometry = ui, t.SphereGeometry = hi, t.SphereBufferGeometry = di, t.RingGeometry = pi, t.RingBufferGeometry = fi, t.PlaneGeometry = Ct, t.PlaneBufferGeometry = Pt, t.LatheGeometry = mi, t.LatheBufferGeometry = gi, t.ShapeGeometry = vi, t.ShapeBufferGeometry = yi, t.ExtrudeGeometry = si, t.ExtrudeBufferGeometry = li, t.EdgesGeometry = _i, t.ConeGeometry = wi, t.ConeBufferGeometry = Ti, t.CylinderGeometry = xi, t.CylinderBufferGeometry = bi, t.CircleGeometry = Si, t.CircleBufferGeometry = Ei, t.BoxGeometry = At, t.BoxBufferGeometry = Lt, t.ShadowMaterial = Mi, t.SpriteMaterial = Me, t.RawShaderMaterial = Ai, t.ShaderMaterial = Ot, t.PointsMaterial = Fe, t.MeshPhysicalMaterial = Ci, t.MeshStandardMaterial = Li, t.MeshPhongMaterial = Pi, t.MeshToonMaterial = Ri, t.MeshNormalMaterial = Oi, t.MeshLambertMaterial = Ii, t.MeshDepthMaterial = K, t.MeshDistanceMaterial = tt, t.MeshBasicMaterial = Rt, t.LineDashedMaterial = Di, t.LineBasicMaterial = Oe, t.Material = $, t.Float64BufferAttribute = Tt, t.Float32BufferAttribute = wt, t.Uint32BufferAttribute = bt, t.Int32BufferAttribute = xt, t.Uint16BufferAttribute = _t, t.Int16BufferAttribute = yt, t.Uint8ClampedBufferAttribute = vt, t.Uint8BufferAttribute = gt, t.Int8BufferAttribute = mt, t.BufferAttribute = ft, t.REVISION = Ur, t.MOUSE = Br, t.CullFaceNone = zr, t.CullFaceBack = jr, t.CullFaceFront = Hr, t.CullFaceFrontBack = 3, t.FrontFaceDirectionCW = Gr, t.FrontFaceDirectionCCW = 1, t.BasicShadowMap = 0, t.PCFShadowMap = Vr, t.PCFSoftShadowMap = Wr, t.FrontSide = Xr, t.BackSide = qr, t.DoubleSide = Yr, t.FlatShading = 1, t.SmoothShading = 2, t.NoColors = Qr, t.FaceColors = Zr, t.VertexColors = Jr, t.NoBlending = $r, t.NormalBlending = Kr, t.AdditiveBlending = to, t.SubtractiveBlending = eo, t.MultiplyBlending = io, t.CustomBlending = no, t.AddEquation = ro, t.SubtractEquation = oo, t.ReverseSubtractEquation = ao, t.MinEquation = so, t.MaxEquation = lo, t.ZeroFactor = co, t.OneFactor = uo, t.SrcColorFactor = ho, t.OneMinusSrcColorFactor = po, t.SrcAlphaFactor = fo, t.OneMinusSrcAlphaFactor = mo, t.DstAlphaFactor = go, t.OneMinusDstAlphaFactor = vo, t.DstColorFactor = yo, t.OneMinusDstColorFactor = _o, t.SrcAlphaSaturateFactor = xo, t.NeverDepth = bo, t.AlwaysDepth = wo, t.LessDepth = To, t.LessEqualDepth = So, t.EqualDepth = Eo, t.GreaterEqualDepth = Mo, t.GreaterDepth = Ao, t.NotEqualDepth = Lo, t.MultiplyOperation = Co, t.MixOperation = Po, t.AddOperation = Ro, t.NoToneMapping = Oo, t.LinearToneMapping = Io, t.ReinhardToneMapping = Do, t.Uncharted2ToneMapping = No, t.CineonToneMapping = Fo, t.UVMapping = 300, t.CubeReflectionMapping = ko, t.CubeRefractionMapping = Uo, t.EquirectangularReflectionMapping = Bo, t.EquirectangularRefractionMapping = zo, t.SphericalReflectionMapping = jo, t.CubeUVReflectionMapping = Ho, t.CubeUVRefractionMapping = Go, t.RepeatWrapping = Vo, t.ClampToEdgeWrapping = Wo, t.MirroredRepeatWrapping = Xo, t.NearestFilter = qo, t.NearestMipMapNearestFilter = Yo, t.NearestMipMapLinearFilter = Qo, t.LinearFilter = Zo, t.LinearMipMapNearestFilter = Jo, t.LinearMipMapLinearFilter = $o, t.UnsignedByteType = Ko, t.ByteType = ta, t.ShortType = ea, t.UnsignedShortType = ia, t.IntType = na, t.UnsignedIntType = ra, t.FloatType = oa, t.HalfFloatType = aa, t.UnsignedShort4444Type = sa, t.UnsignedShort5551Type = la, t.UnsignedShort565Type = ca, t.UnsignedInt248Type = ua, t.AlphaFormat = ha, t.RGBFormat = da, t.RGBAFormat = pa, t.LuminanceFormat = fa, t.LuminanceAlphaFormat = ma, t.RGBEFormat = ga, t.DepthFormat = va, t.DepthStencilFormat = ya, t.RGB_S3TC_DXT1_Format = _a, t.RGBA_S3TC_DXT1_Format = xa, t.RGBA_S3TC_DXT3_Format = ba, t.RGBA_S3TC_DXT5_Format = wa, t.RGB_PVRTC_4BPPV1_Format = Ta, t.RGB_PVRTC_2BPPV1_Format = Sa, t.RGBA_PVRTC_4BPPV1_Format = Ea, t.RGBA_PVRTC_2BPPV1_Format = Ma, t.RGB_ETC1_Format = Aa, t.LoopOnce = 2200, t.LoopRepeat = La, t.LoopPingPong = 2202, t.InterpolateDiscrete = 2300, t.InterpolateLinear = 2301, t.InterpolateSmooth = 2302, t.ZeroCurvatureEnding = Ca, t.ZeroSlopeEnding = 2401, t.WrapAroundEnding = 2402, t.TrianglesDrawMode = Pa, t.TriangleStripDrawMode = Ra, t.TriangleFanDrawMode = Oa, t.LinearEncoding = Ia, t.sRGBEncoding = Da, t.GammaEncoding = Na, t.RGBEEncoding = Fa, t.LogLuvEncoding = 3003, t.RGBM7Encoding = ka, t.RGBM16Encoding = Ua, t.RGBDEncoding = Ba, t.BasicDepthPacking = za, t.RGBADepthPacking = ja, t.CubeGeometry = At, t.Face4 = function(t, e, i, n, r, o, a) {
            return console.warn("THREE.Face4 has been removed. A THREE.Face3 will be created instead."), new dt(t, e, i, r, o, a)
        }, t.LineStrip = 0, t.LinePieces = 1, t.MeshFaceMaterial = function(t) {
            return console.warn("THREE.MeshFaceMaterial has been removed. Use an Array instead."), t
        }, t.MultiMaterial = function(t) {
            return void 0 === t && (t = []), console.warn("THREE.MultiMaterial has been removed. Use an Array instead."), t.isMultiMaterial = !0, t.materials = t, t.clone = function() {
                return t.slice()
            }, t
        }, t.PointCloud = function(t, e) {
            return console.warn("THREE.PointCloud has been renamed to THREE.Points."), new ke(t, e)
        }, t.Particle = function(t) {
            return console.warn("THREE.Particle has been renamed to THREE.Sprite."), new Ae(t)
        }, t.ParticleSystem = function(t, e) {
            return console.warn("THREE.ParticleSystem has been renamed to THREE.Points."), new ke(t, e)
        }, t.PointCloudMaterial = function(t) {
            return console.warn("THREE.PointCloudMaterial has been renamed to THREE.PointsMaterial."), new Fe(t)
        }, t.ParticleBasicMaterial = function(t) {
            return console.warn("THREE.ParticleBasicMaterial has been renamed to THREE.PointsMaterial."), new Fe(t)
        }, t.ParticleSystemMaterial = function(t) {
            return console.warn("THREE.ParticleSystemMaterial has been renamed to THREE.PointsMaterial."), new Fe(t)
        }, t.Vertex = function(t, e, i) {
            return console.warn("THREE.Vertex has been removed. Use THREE.Vector3 instead."), new o(t, e, i)
        }, t.DynamicBufferAttribute = function(t, e) {
            return console.warn("THREE.DynamicBufferAttribute has been removed. Use new THREE.BufferAttribute().setDynamic( true ) instead."), new ft(t, e).setDynamic(!0)
        }, t.Int8Attribute = function(t, e) {
            return console.warn("THREE.Int8Attribute has been removed. Use new THREE.Int8BufferAttribute() instead."), new mt(t, e)
        }, t.Uint8Attribute = function(t, e) {
            return console.warn("THREE.Uint8Attribute has been removed. Use new THREE.Uint8BufferAttribute() instead."), new gt(t, e)
        }, t.Uint8ClampedAttribute = function(t, e) {
            return console.warn("THREE.Uint8ClampedAttribute has been removed. Use new THREE.Uint8ClampedBufferAttribute() instead."), new vt(t, e)
        }, t.Int16Attribute = function(t, e) {
            return console.warn("THREE.Int16Attribute has been removed. Use new THREE.Int16BufferAttribute() instead."), new yt(t, e)
        }, t.Uint16Attribute = function(t, e) {
            return console.warn("THREE.Uint16Attribute has been removed. Use new THREE.Uint16BufferAttribute() instead."), new _t(t, e)
        }, t.Int32Attribute = function(t, e) {
            return console.warn("THREE.Int32Attribute has been removed. Use new THREE.Int32BufferAttribute() instead."), new xt(t, e)
        }, t.Uint32Attribute = function(t, e) {
            return console.warn("THREE.Uint32Attribute has been removed. Use new THREE.Uint32BufferAttribute() instead."), new bt(t, e)
        }, t.Float32Attribute = function(t, e) {
            return console.warn("THREE.Float32Attribute has been removed. Use new THREE.Float32BufferAttribute() instead."), new wt(t, e)
        }, t.Float64Attribute = function(t, e) {
            return console.warn("THREE.Float64Attribute has been removed. Use new THREE.Float64BufferAttribute() instead."), new Tt(t, e)
        }, t.ClosedSplineCurve3 = Nr, t.SplineCurve3 = Fr, t.Spline = kr, t.AxisHelper = function(t) {
            return console.warn("THREE.AxisHelper has been renamed to THREE.AxesHelper."), new Lr(t)
        }, t.BoundingBoxHelper = function(t, e) {
            return console.warn("THREE.BoundingBoxHelper has been deprecated. Creating a THREE.BoxHelper instead."), new Sr(t, e)
        }, t.EdgesHelper = function(t, e) {
            return console.warn("THREE.EdgesHelper has been removed. Use THREE.EdgesGeometry instead."), new De(new _i(t.geometry), new Oe({
                color: void 0 !== e ? e : 16777215
            }))
        }, t.WireframeHelper = function(t, e) {
            return console.warn("THREE.WireframeHelper has been removed. Use THREE.WireframeGeometry instead."), new De(new He(t.geometry), new Oe({
                color: void 0 !== e ? e : 16777215
            }))
        }, t.XHRLoader = function(t) {
            return console.warn("THREE.XHRLoader has been renamed to THREE.FileLoader."), new Fi(t)
        }, t.BinaryTextureLoader = function(t) {
            return console.warn("THREE.BinaryTextureLoader has been renamed to THREE.DataTextureLoader."), new Ui(t)
        }, t.GeometryUtils = Cs, t.ImageUtils = Ps, t.Projector = function() {
            console.error("THREE.Projector has been moved to /examples/js/renderers/Projector.js."), this.projectVector = function(t, e) {
                console.warn("THREE.Projector: .projectVector() is now vector.project()."), t.project(e)
            }, this.unprojectVector = function(t, e) {
                console.warn("THREE.Projector: .unprojectVector() is now vector.unproject()."), t.unproject(e)
            }, this.pickingRay = function() {
                console.error("THREE.Projector: .pickingRay() is now raycaster.setFromCamera().")
            }
        }, t.CanvasRenderer = function() {
            console.error("THREE.CanvasRenderer has been moved to /examples/js/renderers/CanvasRenderer.js"), this.domElement = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas"), this.clear = function() {}, this.render = function() {}, this.setClearColor = function() {}, this.setSize = function() {}
        }, Object.defineProperty(t, "__esModule", {
            value: !0
        })
    })
}, function(t, e, i) {
    var n, r;
    (function(o) {
        var a = void 0 !== t && t.exports && void 0 !== o ? o : this || window;
        (a._gsQueue || (a._gsQueue = [])).push(function() {
                "use strict";
                a._gsDefine("TweenMax", ["core.Animation", "core.SimpleTimeline", "TweenLite"], function(t, e, i) {
                        var n = function(t) {
                                var e, i = [],
                                    n = t.length;
                                for (e = 0; e !== n; i.push(t[e++]));
                                return i
                            },
                            r = function(t, e, i) {
                                var n, r, o = t.cycle;
                                for (n in o) r = o[n], t[n] = "function" == typeof r ? r(i, e[i]) : r[i % r.length];
                                delete t.cycle
                            },
                            o = function(t, e, n) {
                                i.call(this, t, e, n), this._cycle = 0, this._yoyo = !0 === this.vars.yoyo, this._repeat = this.vars.repeat || 0, this._repeatDelay = this.vars.repeatDelay || 0, this._dirty = !0, this.render = o.prototype.render
                            },
                            a = i._internals,
                            s = a.isSelector,
                            l = a.isArray,
                            c = o.prototype = i.to({}, .1, {}),
                            u = [];
                        o.version = "1.19.1", c.constructor = o, c.kill()._gc = !1, o.killTweensOf = o.killDelayedCallsTo = i.killTweensOf, o.getTweensOf = i.getTweensOf, o.lagSmoothing = i.lagSmoothing, o.ticker = i.ticker, o.render = i.render, c.invalidate = function() {
                            return this._yoyo = !0 === this.vars.yoyo, this._repeat = this.vars.repeat || 0, this._repeatDelay = this.vars.repeatDelay || 0, this._uncache(!0), i.prototype.invalidate.call(this)
                        }, c.updateTo = function(t, e) {
                            var n, r = this.ratio,
                                o = this.vars.immediateRender || t.immediateRender;
                            e && this._startTime < this._timeline._time && (this._startTime = this._timeline._time, this._uncache(!1), this._gc ? this._enabled(!0, !1) : this._timeline.insert(this, this._startTime - this._delay));
                            for (n in t) this.vars[n] = t[n];
                            if (this._initted || o)
                                if (e) this._initted = !1, o && this.render(0, !0, !0);
                                else if (this._gc && this._enabled(!0, !1), this._notifyPluginsOfEnabled && this._firstPT && i._onPluginEvent("_onDisable", this), this._time / this._duration > .998) {
                                var a = this._totalTime;
                                this.render(0, !0, !1), this._initted = !1, this.render(a, !0, !1)
                            } else if (this._initted = !1, this._init(), this._time > 0 || o)
                                for (var s, l = 1 / (1 - r), c = this._firstPT; c;) s = c.s + c.c, c.c *= l, c.s = s - c.c, c = c._next;
                            return this
                        }, c.render = function(t, e, i) {
                            this._initted || 0 === this._duration && this.vars.repeat && this.invalidate();
                            var n, r, o, s, l, c, u, h, d = this._dirty ? this.totalDuration() : this._totalDuration,
                                p = this._time,
                                f = this._totalTime,
                                m = this._cycle,
                                g = this._duration,
                                v = this._rawPrevTime;
                            if (t >= d - 1e-7 && t >= 0 ? (this._totalTime = d, this._cycle = this._repeat, this._yoyo && 0 != (1 & this._cycle) ? (this._time = 0, this.ratio = this._ease._calcEnd ? this._ease.getRatio(0) : 0) : (this._time = g, this.ratio = this._ease._calcEnd ? this._ease.getRatio(1) : 1), this._reversed || (n = !0, r = "onComplete", i = i || this._timeline.autoRemoveChildren), 0 === g && (this._initted || !this.vars.lazy || i) && (this._startTime === this._timeline._duration && (t = 0), (v < 0 || t <= 0 && t >= -1e-7 || 1e-10 === v && "isPause" !== this.data) && v !== t && (i = !0, v > 1e-10 && (r = "onReverseComplete")), this._rawPrevTime = h = !e || t || v === t ? t : 1e-10)) : t < 1e-7 ? (this._totalTime = this._time = this._cycle = 0, this.ratio = this._ease._calcEnd ? this._ease.getRatio(0) : 0, (0 !== f || 0 === g && v > 0) && (r = "onReverseComplete", n = this._reversed), t < 0 && (this._active = !1, 0 === g && (this._initted || !this.vars.lazy || i) && (v >= 0 && (i = !0), this._rawPrevTime = h = !e || t || v === t ? t : 1e-10)), this._initted || (i = !0)) : (this._totalTime = this._time = t, 0 !== this._repeat && (s = g + this._repeatDelay, this._cycle = this._totalTime / s >> 0, 0 !== this._cycle && this._cycle === this._totalTime / s && f <= t && this._cycle--, this._time = this._totalTime - this._cycle * s, this._yoyo && 0 != (1 & this._cycle) && (this._time = g - this._time), this._time > g ? this._time = g : this._time < 0 && (this._time = 0)), this._easeType ? (l = this._time / g, c = this._easeType, u = this._easePower, (1 === c || 3 === c && l >= .5) && (l = 1 - l), 3 === c && (l *= 2), 1 === u ? l *= l : 2 === u ? l *= l * l : 3 === u ? l *= l * l * l : 4 === u && (l *= l * l * l * l), 1 === c ? this.ratio = 1 - l : 2 === c ? this.ratio = l : this._time / g < .5 ? this.ratio = l / 2 : this.ratio = 1 - l / 2) : this.ratio = this._ease.getRatio(this._time / g)), p !== this._time || i || m !== this._cycle) {
                                if (!this._initted) {
                                    if (this._init(), !this._initted || this._gc) return;
                                    if (!i && this._firstPT && (!1 !== this.vars.lazy && this._duration || this.vars.lazy && !this._duration)) return this._time = p, this._totalTime = f, this._rawPrevTime = v, this._cycle = m, a.lazyTweens.push(this), void(this._lazy = [t, e]);
                                    this._time && !n ? this.ratio = this._ease.getRatio(this._time / g) : n && this._ease._calcEnd && (this.ratio = this._ease.getRatio(0 === this._time ? 0 : 1))
                                }
                                for (!1 !== this._lazy && (this._lazy = !1), this._active || !this._paused && this._time !== p && t >= 0 && (this._active = !0), 0 === f && (2 === this._initted && t > 0 && this._init(), this._startAt && (t >= 0 ? this._startAt.render(t, e, i) : r || (r = "_dummyGS")), this.vars.onStart && (0 === this._totalTime && 0 !== g || e || this._callback("onStart"))), o = this._firstPT; o;) o.f ? o.t[o.p](o.c * this.ratio + o.s) : o.t[o.p] = o.c * this.ratio + o.s, o = o._next;
                                this._onUpdate && (t < 0 && this._startAt && this._startTime && this._startAt.render(t, e, i), e || (this._totalTime !== f || r) && this._callback("onUpdate")), this._cycle !== m && (e || this._gc || this.vars.onRepeat && this._callback("onRepeat")), r && (this._gc && !i || (t < 0 && this._startAt && !this._onUpdate && this._startTime && this._startAt.render(t, e, i), n && (this._timeline.autoRemoveChildren && this._enabled(!1, !1), this._active = !1), !e && this.vars[r] && this._callback(r), 0 === g && 1e-10 === this._rawPrevTime && 1e-10 !== h && (this._rawPrevTime = 0)))
                            } else f !== this._totalTime && this._onUpdate && (e || this._callback("onUpdate"))
                        }, o.to = function(t, e, i) {
                            return new o(t, e, i)
                        }, o.from = function(t, e, i) {
                            return i.runBackwards = !0, i.immediateRender = 0 != i.immediateRender, new o(t, e, i)
                        }, o.fromTo = function(t, e, i, n) {
                            return n.startAt = i, n.immediateRender = 0 != n.immediateRender && 0 != i.immediateRender, new o(t, e, n)
                        }, o.staggerTo = o.allTo = function(t, e, a, c, h, d, p) {
                            c = c || 0;
                            var f, m, g, v, y = 0,
                                _ = [],
                                x = a.cycle,
                                b = a.startAt && a.startAt.cycle;
                            for (l(t) || ("string" == typeof t && (t = i.selector(t) || t), s(t) && (t = n(t))), t = t || [], c < 0 && ((t = n(t)).reverse(), c *= -1), f = t.length - 1, g = 0; g <= f; g++) {
                                m = {};
                                for (v in a) m[v] = a[v];
                                if (x && (r(m, t, g), null != m.duration && (e = m.duration, delete m.duration)), b) {
                                    b = m.startAt = {};
                                    for (v in a.startAt) b[v] = a.startAt[v];
                                    r(m.startAt, t, g)
                                }
                                m.delay = y + (m.delay || 0), g === f && h && (m.onComplete = function() {
                                    a.onComplete && a.onComplete.apply(a.onCompleteScope || this, arguments), h.apply(p || a.callbackScope || this, d || u)
                                }), _[g] = new o(t[g], e, m), y += c
                            }
                            return _
                        }, o.staggerFrom = o.allFrom = function(t, e, i, n, r, a, s) {
                            return i.runBackwards = !0, i.immediateRender = 0 != i.immediateRender, o.staggerTo(t, e, i, n, r, a, s)
                        }, o.staggerFromTo = o.allFromTo = function(t, e, i, n, r, a, s, l) {
                            return n.startAt = i, n.immediateRender = 0 != n.immediateRender && 0 != i.immediateRender, o.staggerTo(t, e, n, r, a, s, l)
                        }, o.delayedCall = function(t, e, i, n, r) {
                            return new o(e, 0, {
                                delay: t,
                                onComplete: e,
                                onCompleteParams: i,
                                callbackScope: n,
                                onReverseComplete: e,
                                onReverseCompleteParams: i,
                                immediateRender: !1,
                                useFrames: r,
                                overwrite: 0
                            })
                        }, o.set = function(t, e) {
                            return new o(t, 0, e)
                        }, o.isTweening = function(t) {
                            return i.getTweensOf(t, !0).length > 0
                        };
                        var h = function(t, e) {
                                for (var n = [], r = 0, o = t._first; o;) o instanceof i ? n[r++] = o : (e && (n[r++] = o), r = (n = n.concat(h(o, e))).length), o = o._next;
                                return n
                            },
                            d = o.getAllTweens = function(e) {
                                return h(t._rootTimeline, e).concat(h(t._rootFramesTimeline, e))
                            };
                        o.killAll = function(t, i, n, r) {
                            null == i && (i = !0), null == n && (n = !0);
                            var o, a, s, l = d(0 != r),
                                c = l.length,
                                u = i && n && r;
                            for (s = 0; s < c; s++) a = l[s], (u || a instanceof e || (o = a.target === a.vars.onComplete) && n || i && !o) && (t ? a.totalTime(a._reversed ? 0 : a.totalDuration()) : a._enabled(!1, !1))
                        }, o.killChildTweensOf = function(t, e) {
                            if (null != t) {
                                var r, c, u, h, d, p = a.tweenLookup;
                                if ("string" == typeof t && (t = i.selector(t) || t), s(t) && (t = n(t)), l(t))
                                    for (h = t.length; --h > -1;) o.killChildTweensOf(t[h], e);
                                else {
                                    r = [];
                                    for (u in p)
                                        for (c = p[u].target.parentNode; c;) c === t && (r = r.concat(p[u].tweens)), c = c.parentNode;
                                    for (d = r.length, h = 0; h < d; h++) e && r[h].totalTime(r[h].totalDuration()), r[h]._enabled(!1, !1)
                                }
                            }
                        };
                        var p = function(t, i, n, r) {
                            i = !1 !== i, n = !1 !== n;
                            for (var o, a, s = d(r = !1 !== r), l = i && n && r, c = s.length; --c > -1;) a = s[c], (l || a instanceof e || (o = a.target === a.vars.onComplete) && n || i && !o) && a.paused(t)
                        };
                        return o.pauseAll = function(t, e, i) {
                            p(!0, t, e, i)
                        }, o.resumeAll = function(t, e, i) {
                            p(!1, t, e, i)
                        }, o.globalTimeScale = function(e) {
                            var n = t._rootTimeline,
                                r = i.ticker.time;
                            return arguments.length ? (e = e || 1e-10, n._startTime = r - (r - n._startTime) * n._timeScale / e, n = t._rootFramesTimeline, r = i.ticker.frame, n._startTime = r - (r - n._startTime) * n._timeScale / e, n._timeScale = t._rootTimeline._timeScale = e, e) : n._timeScale
                        }, c.progress = function(t, e) {
                            return arguments.length ? this.totalTime(this.duration() * (this._yoyo && 0 != (1 & this._cycle) ? 1 - t : t) + this._cycle * (this._duration + this._repeatDelay), e) : this._time / this.duration()
                        }, c.totalProgress = function(t, e) {
                            return arguments.length ? this.totalTime(this.totalDuration() * t, e) : this._totalTime / this.totalDuration()
                        }, c.time = function(t, e) {
                            return arguments.length ? (this._dirty && this.totalDuration(), t > this._duration && (t = this._duration), this._yoyo && 0 != (1 & this._cycle) ? t = this._duration - t + this._cycle * (this._duration + this._repeatDelay) : 0 !== this._repeat && (t += this._cycle * (this._duration + this._repeatDelay)), this.totalTime(t, e)) : this._time
                        }, c.duration = function(e) {
                            return arguments.length ? t.prototype.duration.call(this, e) : this._duration
                        }, c.totalDuration = function(t) {
                            return arguments.length ? -1 === this._repeat ? this : this.duration((t - this._repeat * this._repeatDelay) / (this._repeat + 1)) : (this._dirty && (this._totalDuration = -1 === this._repeat ? 999999999999 : this._duration * (this._repeat + 1) + this._repeatDelay * this._repeat, this._dirty = !1), this._totalDuration)
                        }, c.repeat = function(t) {
                            return arguments.length ? (this._repeat = t, this._uncache(!0)) : this._repeat
                        }, c.repeatDelay = function(t) {
                            return arguments.length ? (this._repeatDelay = t, this._uncache(!0)) : this._repeatDelay
                        }, c.yoyo = function(t) {
                            return arguments.length ? (this._yoyo = t, this) : this._yoyo
                        }, o
                    }, !0), a._gsDefine("TimelineLite", ["core.Animation", "core.SimpleTimeline", "TweenLite"], function(t, e, i) {
                        var n = function(t) {
                                e.call(this, t), this._labels = {}, this.autoRemoveChildren = !0 === this.vars.autoRemoveChildren, this.smoothChildTiming = !0 === this.vars.smoothChildTiming, this._sortChildren = !0, this._onUpdate = this.vars.onUpdate;
                                var i, n, r = this.vars;
                                for (n in r) i = r[n], l(i) && -1 !== i.join("").indexOf("{self}") && (r[n] = this._swapSelfInParams(i));
                                l(r.tweens) && this.add(r.tweens, 0, r.align, r.stagger)
                            },
                            r = i._internals,
                            o = n._internals = {},
                            s = r.isSelector,
                            l = r.isArray,
                            c = r.lazyTweens,
                            u = r.lazyRender,
                            h = a._gsDefine.globals,
                            d = function(t) {
                                var e, i = {};
                                for (e in t) i[e] = t[e];
                                return i
                            },
                            p = function(t, e, i) {
                                var n, r, o = t.cycle;
                                for (n in o) r = o[n], t[n] = "function" == typeof r ? r(i, e[i]) : r[i % r.length];
                                delete t.cycle
                            },
                            f = o.pauseCallback = function() {},
                            m = function(t) {
                                var e, i = [],
                                    n = t.length;
                                for (e = 0; e !== n; i.push(t[e++]));
                                return i
                            },
                            g = n.prototype = new e;
                        return n.version = "1.19.1", g.constructor = n, g.kill()._gc = g._forcingPlayhead = g._hasPause = !1, g.to = function(t, e, n, r) {
                            var o = n.repeat && h.TweenMax || i;
                            return e ? this.add(new o(t, e, n), r) : this.set(t, n, r)
                        }, g.from = function(t, e, n, r) {
                            return this.add((n.repeat && h.TweenMax || i).from(t, e, n), r)
                        }, g.fromTo = function(t, e, n, r, o) {
                            var a = r.repeat && h.TweenMax || i;
                            return e ? this.add(a.fromTo(t, e, n, r), o) : this.set(t, r, o)
                        }, g.staggerTo = function(t, e, r, o, a, l, c, u) {
                            var h, f, g = new n({
                                    onComplete: l,
                                    onCompleteParams: c,
                                    callbackScope: u,
                                    smoothChildTiming: this.smoothChildTiming
                                }),
                                v = r.cycle;
                            for ("string" == typeof t && (t = i.selector(t) || t), s(t = t || []) && (t = m(t)), (o = o || 0) < 0 && ((t = m(t)).reverse(), o *= -1), f = 0; f < t.length; f++)(h = d(r)).startAt && (h.startAt = d(h.startAt), h.startAt.cycle && p(h.startAt, t, f)), v && (p(h, t, f), null != h.duration && (e = h.duration, delete h.duration)), g.to(t[f], e, h, f * o);
                            return this.add(g, a)
                        }, g.staggerFrom = function(t, e, i, n, r, o, a, s) {
                            return i.immediateRender = 0 != i.immediateRender, i.runBackwards = !0, this.staggerTo(t, e, i, n, r, o, a, s)
                        }, g.staggerFromTo = function(t, e, i, n, r, o, a, s, l) {
                            return n.startAt = i, n.immediateRender = 0 != n.immediateRender && 0 != i.immediateRender, this.staggerTo(t, e, n, r, o, a, s, l)
                        }, g.call = function(t, e, n, r) {
                            return this.add(i.delayedCall(0, t, e, n), r)
                        }, g.set = function(t, e, n) {
                            return n = this._parseTimeOrLabel(n, 0, !0), null == e.immediateRender && (e.immediateRender = n === this._time && !this._paused), this.add(new i(t, 0, e), n)
                        }, n.exportRoot = function(t, e) {
                            null == (t = t || {}).smoothChildTiming && (t.smoothChildTiming = !0);
                            var r, o, a = new n(t),
                                s = a._timeline;
                            for (null == e && (e = !0), s._remove(a, !0), a._startTime = 0, a._rawPrevTime = a._time = a._totalTime = s._time, r = s._first; r;) o = r._next, e && r instanceof i && r.target === r.vars.onComplete || a.add(r, r._startTime - r._delay), r = o;
                            return s.add(a, 0), a
                        }, g.add = function(r, o, a, s) {
                            var c, u, h, d, p, f;
                            if ("number" != typeof o && (o = this._parseTimeOrLabel(o, 0, !0, r)), !(r instanceof t)) {
                                if (r instanceof Array || r && r.push && l(r)) {
                                    for (a = a || "normal", s = s || 0, c = o, u = r.length, h = 0; h < u; h++) l(d = r[h]) && (d = new n({
                                        tweens: d
                                    })), this.add(d, c), "string" != typeof d && "function" != typeof d && ("sequence" === a ? c = d._startTime + d.totalDuration() / d._timeScale : "start" === a && (d._startTime -= d.delay())), c += s;
                                    return this._uncache(!0)
                                }
                                if ("string" == typeof r) return this.addLabel(r, o);
                                if ("function" != typeof r) throw "Cannot add " + r + " into the timeline; it is not a tween, timeline, function, or string.";
                                r = i.delayedCall(0, r)
                            }
                            if (e.prototype.add.call(this, r, o), (this._gc || this._time === this._duration) && !this._paused && this._duration < this.duration())
                                for (f = (p = this).rawTime() > r._startTime; p._timeline;) f && p._timeline.smoothChildTiming ? p.totalTime(p._totalTime, !0) : p._gc && p._enabled(!0, !1), p = p._timeline;
                            return this
                        }, g.remove = function(e) {
                            if (e instanceof t) {
                                this._remove(e, !1);
                                var i = e._timeline = e.vars.useFrames ? t._rootFramesTimeline : t._rootTimeline;
                                return e._startTime = (e._paused ? e._pauseTime : i._time) - (e._reversed ? e.totalDuration() - e._totalTime : e._totalTime) / e._timeScale, this
                            }
                            if (e instanceof Array || e && e.push && l(e)) {
                                for (var n = e.length; --n > -1;) this.remove(e[n]);
                                return this
                            }
                            return "string" == typeof e ? this.removeLabel(e) : this.kill(null, e)
                        }, g._remove = function(t, i) {
                            return e.prototype._remove.call(this, t, i), this._last ? this._time > this.duration() && (this._time = this._duration, this._totalTime = this._totalDuration) : this._time = this._totalTime = this._duration = this._totalDuration = 0, this
                        }, g.append = function(t, e) {
                            return this.add(t, this._parseTimeOrLabel(null, e, !0, t))
                        }, g.insert = g.insertMultiple = function(t, e, i, n) {
                            return this.add(t, e || 0, i, n)
                        }, g.appendMultiple = function(t, e, i, n) {
                            return this.add(t, this._parseTimeOrLabel(null, e, !0, t), i, n)
                        }, g.addLabel = function(t, e) {
                            return this._labels[t] = this._parseTimeOrLabel(e), this
                        }, g.addPause = function(t, e, n, r) {
                            var o = i.delayedCall(0, f, n, r || this);
                            return o.vars.onComplete = o.vars.onReverseComplete = e, o.data = "isPause", this._hasPause = !0, this.add(o, t)
                        }, g.removeLabel = function(t) {
                            return delete this._labels[t], this
                        }, g.getLabelTime = function(t) {
                            return null != this._labels[t] ? this._labels[t] : -1
                        }, g._parseTimeOrLabel = function(e, i, n, r) {
                            var o;
                            if (r instanceof t && r.timeline === this) this.remove(r);
                            else if (r && (r instanceof Array || r.push && l(r)))
                                for (o = r.length; --o > -1;) r[o] instanceof t && r[o].timeline === this && this.remove(r[o]);
                            if ("string" == typeof i) return this._parseTimeOrLabel(i, n && "number" == typeof e && null == this._labels[i] ? e - this.duration() : 0, n);
                            if (i = i || 0, "string" != typeof e || !isNaN(e) && null == this._labels[e]) null == e && (e = this.duration());
                            else {
                                if (-1 === (o = e.indexOf("="))) return null == this._labels[e] ? n ? this._labels[e] = this.duration() + i : i : this._labels[e] + i;
                                i = parseInt(e.charAt(o - 1) + "1", 10) * Number(e.substr(o + 1)), e = o > 1 ? this._parseTimeOrLabel(e.substr(0, o - 1), 0, n) : this.duration()
                            }
                            return Number(e) + i
                        }, g.seek = function(t, e) {
                            return this.totalTime("number" == typeof t ? t : this._parseTimeOrLabel(t), !1 !== e)
                        }, g.stop = function() {
                            return this.paused(!0)
                        }, g.gotoAndPlay = function(t, e) {
                            return this.play(t, e)
                        }, g.gotoAndStop = function(t, e) {
                            return this.pause(t, e)
                        }, g.render = function(t, e, i) {
                            this._gc && this._enabled(!0, !1);
                            var n, r, o, a, s, l, h, d = this._dirty ? this.totalDuration() : this._totalDuration,
                                p = this._time,
                                f = this._startTime,
                                m = this._timeScale,
                                g = this._paused;
                            if (t >= d - 1e-7 && t >= 0) this._totalTime = this._time = d, this._reversed || this._hasPausedChild() || (r = !0, a = "onComplete", s = !!this._timeline.autoRemoveChildren, 0 === this._duration && (t <= 0 && t >= -1e-7 || this._rawPrevTime < 0 || 1e-10 === this._rawPrevTime) && this._rawPrevTime !== t && this._first && (s = !0, this._rawPrevTime > 1e-10 && (a = "onReverseComplete"))), this._rawPrevTime = this._duration || !e || t || this._rawPrevTime === t ? t : 1e-10, t = d + 1e-4;
                            else if (t < 1e-7)
                                if (this._totalTime = this._time = 0, (0 !== p || 0 === this._duration && 1e-10 !== this._rawPrevTime && (this._rawPrevTime > 0 || t < 0 && this._rawPrevTime >= 0)) && (a = "onReverseComplete", r = this._reversed), t < 0) this._active = !1, this._timeline.autoRemoveChildren && this._reversed ? (s = r = !0, a = "onReverseComplete") : this._rawPrevTime >= 0 && this._first && (s = !0), this._rawPrevTime = t;
                                else {
                                    if (this._rawPrevTime = this._duration || !e || t || this._rawPrevTime === t ? t : 1e-10, 0 === t && r)
                                        for (n = this._first; n && 0 === n._startTime;) n._duration || (r = !1), n = n._next;
                                    t = 0, this._initted || (s = !0)
                                }
                            else {
                                if (this._hasPause && !this._forcingPlayhead && !e) {
                                    if (t >= p)
                                        for (n = this._first; n && n._startTime <= t && !l;) n._duration || "isPause" !== n.data || n.ratio || 0 === n._startTime && 0 === this._rawPrevTime || (l = n), n = n._next;
                                    else
                                        for (n = this._last; n && n._startTime >= t && !l;) n._duration || "isPause" === n.data && n._rawPrevTime > 0 && (l = n), n = n._prev;
                                    l && (this._time = t = l._startTime, this._totalTime = t + this._cycle * (this._totalDuration + this._repeatDelay))
                                }
                                this._totalTime = this._time = this._rawPrevTime = t
                            }
                            if (this._time !== p && this._first || i || s || l) {
                                if (this._initted || (this._initted = !0), this._active || !this._paused && this._time !== p && t > 0 && (this._active = !0), 0 === p && this.vars.onStart && (0 === this._time && this._duration || e || this._callback("onStart")), (h = this._time) >= p)
                                    for (n = this._first; n && (o = n._next, h === this._time && (!this._paused || g));)(n._active || n._startTime <= h && !n._paused && !n._gc) && (l === n && this.pause(), n._reversed ? n.render((n._dirty ? n.totalDuration() : n._totalDuration) - (t - n._startTime) * n._timeScale, e, i) : n.render((t - n._startTime) * n._timeScale, e, i)), n = o;
                                else
                                    for (n = this._last; n && (o = n._prev, h === this._time && (!this._paused || g));) {
                                        if (n._active || n._startTime <= p && !n._paused && !n._gc) {
                                            if (l === n) {
                                                for (l = n._prev; l && l.endTime() > this._time;) l.render(l._reversed ? l.totalDuration() - (t - l._startTime) * l._timeScale : (t - l._startTime) * l._timeScale, e, i), l = l._prev;
                                                l = null, this.pause()
                                            }
                                            n._reversed ? n.render((n._dirty ? n.totalDuration() : n._totalDuration) - (t - n._startTime) * n._timeScale, e, i) : n.render((t - n._startTime) * n._timeScale, e, i)
                                        }
                                        n = o
                                    }
                                this._onUpdate && (e || (c.length && u(), this._callback("onUpdate"))), a && (this._gc || f !== this._startTime && m === this._timeScale || (0 === this._time || d >= this.totalDuration()) && (r && (c.length && u(), this._timeline.autoRemoveChildren && this._enabled(!1, !1), this._active = !1), !e && this.vars[a] && this._callback(a)))
                            }
                        }, g._hasPausedChild = function() {
                            for (var t = this._first; t;) {
                                if (t._paused || t instanceof n && t._hasPausedChild()) return !0;
                                t = t._next
                            }
                            return !1
                        }, g.getChildren = function(t, e, n, r) {
                            r = r || -9999999999;
                            for (var o = [], a = this._first, s = 0; a;) a._startTime < r || (a instanceof i ? !1 !== e && (o[s++] = a) : (!1 !== n && (o[s++] = a), !1 !== t && (s = (o = o.concat(a.getChildren(!0, e, n))).length))), a = a._next;
                            return o
                        }, g.getTweensOf = function(t, e) {
                            var n, r, o = this._gc,
                                a = [],
                                s = 0;
                            for (o && this._enabled(!0, !0), r = (n = i.getTweensOf(t)).length; --r > -1;)(n[r].timeline === this || e && this._contains(n[r])) && (a[s++] = n[r]);
                            return o && this._enabled(!1, !0), a
                        }, g.recent = function() {
                            return this._recent
                        }, g._contains = function(t) {
                            for (var e = t.timeline; e;) {
                                if (e === this) return !0;
                                e = e.timeline
                            }
                            return !1
                        }, g.shiftChildren = function(t, e, i) {
                            i = i || 0;
                            for (var n, r = this._first, o = this._labels; r;) r._startTime >= i && (r._startTime += t), r = r._next;
                            if (e)
                                for (n in o) o[n] >= i && (o[n] += t);
                            return this._uncache(!0)
                        }, g._kill = function(t, e) {
                            if (!t && !e) return this._enabled(!1, !1);
                            for (var i = e ? this.getTweensOf(e) : this.getChildren(!0, !0, !1), n = i.length, r = !1; --n > -1;) i[n]._kill(t, e) && (r = !0);
                            return r
                        }, g.clear = function(t) {
                            var e = this.getChildren(!1, !0, !0),
                                i = e.length;
                            for (this._time = this._totalTime = 0; --i > -1;) e[i]._enabled(!1, !1);
                            return !1 !== t && (this._labels = {}), this._uncache(!0)
                        }, g.invalidate = function() {
                            for (var e = this._first; e;) e.invalidate(), e = e._next;
                            return t.prototype.invalidate.call(this)
                        }, g._enabled = function(t, i) {
                            if (t === this._gc)
                                for (var n = this._first; n;) n._enabled(t, !0), n = n._next;
                            return e.prototype._enabled.call(this, t, i)
                        }, g.totalTime = function(e, i, n) {
                            this._forcingPlayhead = !0;
                            var r = t.prototype.totalTime.apply(this, arguments);
                            return this._forcingPlayhead = !1, r
                        }, g.duration = function(t) {
                            return arguments.length ? (0 !== this.duration() && 0 !== t && this.timeScale(this._duration / t), this) : (this._dirty && this.totalDuration(), this._duration)
                        }, g.totalDuration = function(t) {
                            if (!arguments.length) {
                                if (this._dirty) {
                                    for (var e, i, n = 0, r = this._last, o = 999999999999; r;) e = r._prev, r._dirty && r.totalDuration(), r._startTime > o && this._sortChildren && !r._paused ? this.add(r, r._startTime - r._delay) : o = r._startTime, r._startTime < 0 && !r._paused && (n -= r._startTime, this._timeline.smoothChildTiming && (this._startTime += r._startTime / this._timeScale), this.shiftChildren(-r._startTime, !1, -9999999999), o = 0), (i = r._startTime + r._totalDuration / r._timeScale) > n && (n = i), r = e;
                                    this._duration = this._totalDuration = n, this._dirty = !1
                                }
                                return this._totalDuration
                            }
                            return t && this.totalDuration() ? this.timeScale(this._totalDuration / t) : this
                        }, g.paused = function(e) {
                            if (!e)
                                for (var i = this._first, n = this._time; i;) i._startTime === n && "isPause" === i.data && (i._rawPrevTime = 0), i = i._next;
                            return t.prototype.paused.apply(this, arguments)
                        }, g.usesFrames = function() {
                            for (var e = this._timeline; e._timeline;) e = e._timeline;
                            return e === t._rootFramesTimeline
                        }, g.rawTime = function(t) {
                            return t && (this._paused || this._repeat && this.time() > 0 && this.totalProgress() < 1) ? this._totalTime % (this._duration + this._repeatDelay) : this._paused ? this._totalTime : (this._timeline.rawTime(t) - this._startTime) * this._timeScale
                        }, n
                    }, !0), a._gsDefine("TimelineMax", ["TimelineLite", "TweenLite", "easing.Ease"], function(t, e, i) {
                        var n = function(e) {
                                t.call(this, e), this._repeat = this.vars.repeat || 0, this._repeatDelay = this.vars.repeatDelay || 0, this._cycle = 0, this._yoyo = !0 === this.vars.yoyo, this._dirty = !0
                            },
                            r = e._internals,
                            o = r.lazyTweens,
                            s = r.lazyRender,
                            l = a._gsDefine.globals,
                            c = new i(null, null, 1, 0),
                            u = n.prototype = new t;
                        return u.constructor = n, u.kill()._gc = !1, n.version = "1.19.1", u.invalidate = function() {
                            return this._yoyo = !0 === this.vars.yoyo, this._repeat = this.vars.repeat || 0, this._repeatDelay = this.vars.repeatDelay || 0, this._uncache(!0), t.prototype.invalidate.call(this)
                        }, u.addCallback = function(t, i, n, r) {
                            return this.add(e.delayedCall(0, t, n, r), i)
                        }, u.removeCallback = function(t, e) {
                            if (t)
                                if (null == e) this._kill(null, t);
                                else
                                    for (var i = this.getTweensOf(t, !1), n = i.length, r = this._parseTimeOrLabel(e); --n > -1;) i[n]._startTime === r && i[n]._enabled(!1, !1);
                            return this
                        }, u.removePause = function(e) {
                            return this.removeCallback(t._internals.pauseCallback, e)
                        }, u.tweenTo = function(t, i) {
                            i = i || {};
                            var n, r, o, a = {
                                    ease: c,
                                    useFrames: this.usesFrames(),
                                    immediateRender: !1
                                },
                                s = i.repeat && l.TweenMax || e;
                            for (r in i) a[r] = i[r];
                            return a.time = this._parseTimeOrLabel(t), n = Math.abs(Number(a.time) - this._time) / this._timeScale || .001, o = new s(this, n, a), a.onStart = function() {
                                o.target.paused(!0), o.vars.time !== o.target.time() && n === o.duration() && o.duration(Math.abs(o.vars.time - o.target.time()) / o.target._timeScale), i.onStart && i.onStart.apply(i.onStartScope || i.callbackScope || o, i.onStartParams || [])
                            }, o
                        }, u.tweenFromTo = function(t, e, i) {
                            i = i || {}, t = this._parseTimeOrLabel(t), i.startAt = {
                                onComplete: this.seek,
                                onCompleteParams: [t],
                                callbackScope: this
                            }, i.immediateRender = !1 !== i.immediateRender;
                            var n = this.tweenTo(e, i);
                            return n.duration(Math.abs(n.vars.time - t) / this._timeScale || .001)
                        }, u.render = function(t, e, i) {
                            this._gc && this._enabled(!0, !1);
                            var n, r, a, l, c, u, h, d, p = this._dirty ? this.totalDuration() : this._totalDuration,
                                f = this._duration,
                                m = this._time,
                                g = this._totalTime,
                                v = this._startTime,
                                y = this._timeScale,
                                _ = this._rawPrevTime,
                                x = this._paused,
                                b = this._cycle;
                            if (t >= p - 1e-7 && t >= 0) this._locked || (this._totalTime = p, this._cycle = this._repeat), this._reversed || this._hasPausedChild() || (r = !0, l = "onComplete", c = !!this._timeline.autoRemoveChildren, 0 === this._duration && (t <= 0 && t >= -1e-7 || _ < 0 || 1e-10 === _) && _ !== t && this._first && (c = !0, _ > 1e-10 && (l = "onReverseComplete"))), this._rawPrevTime = this._duration || !e || t || this._rawPrevTime === t ? t : 1e-10, this._yoyo && 0 != (1 & this._cycle) ? this._time = t = 0 : (this._time = f, t = f + 1e-4);
                            else if (t < 1e-7)
                                if (this._locked || (this._totalTime = this._cycle = 0), this._time = 0, (0 !== m || 0 === f && 1e-10 !== _ && (_ > 0 || t < 0 && _ >= 0) && !this._locked) && (l = "onReverseComplete", r = this._reversed), t < 0) this._active = !1, this._timeline.autoRemoveChildren && this._reversed ? (c = r = !0, l = "onReverseComplete") : _ >= 0 && this._first && (c = !0), this._rawPrevTime = t;
                                else {
                                    if (this._rawPrevTime = f || !e || t || this._rawPrevTime === t ? t : 1e-10, 0 === t && r)
                                        for (n = this._first; n && 0 === n._startTime;) n._duration || (r = !1), n = n._next;
                                    t = 0, this._initted || (c = !0)
                                }
                            else if (0 === f && _ < 0 && (c = !0), this._time = this._rawPrevTime = t, this._locked || (this._totalTime = t, 0 !== this._repeat && (u = f + this._repeatDelay, this._cycle = this._totalTime / u >> 0, 0 !== this._cycle && this._cycle === this._totalTime / u && g <= t && this._cycle--, this._time = this._totalTime - this._cycle * u, this._yoyo && 0 != (1 & this._cycle) && (this._time = f - this._time), this._time > f ? (this._time = f, t = f + 1e-4) : this._time < 0 ? this._time = t = 0 : t = this._time)), this._hasPause && !this._forcingPlayhead && !e && t < f) {
                                if ((t = this._time) >= m || this._repeat && b !== this._cycle)
                                    for (n = this._first; n && n._startTime <= t && !h;) n._duration || "isPause" !== n.data || n.ratio || 0 === n._startTime && 0 === this._rawPrevTime || (h = n), n = n._next;
                                else
                                    for (n = this._last; n && n._startTime >= t && !h;) n._duration || "isPause" === n.data && n._rawPrevTime > 0 && (h = n), n = n._prev;
                                h && (this._time = t = h._startTime, this._totalTime = t + this._cycle * (this._totalDuration + this._repeatDelay))
                            }
                            if (this._cycle !== b && !this._locked) {
                                var w = this._yoyo && 0 != (1 & b),
                                    T = w === (this._yoyo && 0 != (1 & this._cycle)),
                                    S = this._totalTime,
                                    E = this._cycle,
                                    M = this._rawPrevTime,
                                    A = this._time;
                                if (this._totalTime = b * f, this._cycle < b ? w = !w : this._totalTime += f, this._time = m, this._rawPrevTime = 0 === f ? _ - 1e-4 : _, this._cycle = b, this._locked = !0, m = w ? 0 : f, this.render(m, e, 0 === f), e || this._gc || this.vars.onRepeat && (this._cycle = E, this._locked = !1, this._callback("onRepeat")), m !== this._time) return;
                                if (T && (this._cycle = b, this._locked = !0, m = w ? f + 1e-4 : -1e-4, this.render(m, !0, !1)), this._locked = !1, this._paused && !x) return;
                                this._time = A, this._totalTime = S, this._cycle = E, this._rawPrevTime = M
                            }
                            if (this._time !== m && this._first || i || c || h) {
                                if (this._initted || (this._initted = !0), this._active || !this._paused && this._totalTime !== g && t > 0 && (this._active = !0), 0 === g && this.vars.onStart && (0 === this._totalTime && this._totalDuration || e || this._callback("onStart")), (d = this._time) >= m)
                                    for (n = this._first; n && (a = n._next, d === this._time && (!this._paused || x));)(n._active || n._startTime <= this._time && !n._paused && !n._gc) && (h === n && this.pause(), n._reversed ? n.render((n._dirty ? n.totalDuration() : n._totalDuration) - (t - n._startTime) * n._timeScale, e, i) : n.render((t - n._startTime) * n._timeScale, e, i)), n = a;
                                else
                                    for (n = this._last; n && (a = n._prev, d === this._time && (!this._paused || x));) {
                                        if (n._active || n._startTime <= m && !n._paused && !n._gc) {
                                            if (h === n) {
                                                for (h = n._prev; h && h.endTime() > this._time;) h.render(h._reversed ? h.totalDuration() - (t - h._startTime) * h._timeScale : (t - h._startTime) * h._timeScale, e, i), h = h._prev;
                                                h = null, this.pause()
                                            }
                                            n._reversed ? n.render((n._dirty ? n.totalDuration() : n._totalDuration) - (t - n._startTime) * n._timeScale, e, i) : n.render((t - n._startTime) * n._timeScale, e, i)
                                        }
                                        n = a
                                    }
                                this._onUpdate && (e || (o.length && s(), this._callback("onUpdate"))), l && (this._locked || this._gc || v !== this._startTime && y === this._timeScale || (0 === this._time || p >= this.totalDuration()) && (r && (o.length && s(), this._timeline.autoRemoveChildren && this._enabled(!1, !1), this._active = !1), !e && this.vars[l] && this._callback(l)))
                            } else g !== this._totalTime && this._onUpdate && (e || this._callback("onUpdate"))
                        }, u.getActive = function(t, e, i) {
                            null == t && (t = !0), null == e && (e = !0), null == i && (i = !1);
                            var n, r, o = [],
                                a = this.getChildren(t, e, i),
                                s = 0,
                                l = a.length;
                            for (n = 0; n < l; n++)(r = a[n]).isActive() && (o[s++] = r);
                            return o
                        }, u.getLabelAfter = function(t) {
                            t || 0 !== t && (t = this._time);
                            var e, i = this.getLabelsArray(),
                                n = i.length;
                            for (e = 0; e < n; e++)
                                if (i[e].time > t) return i[e].name;
                            return null
                        }, u.getLabelBefore = function(t) {
                            null == t && (t = this._time);
                            for (var e = this.getLabelsArray(), i = e.length; --i > -1;)
                                if (e[i].time < t) return e[i].name;
                            return null
                        }, u.getLabelsArray = function() {
                            var t, e = [],
                                i = 0;
                            for (t in this._labels) e[i++] = {
                                time: this._labels[t],
                                name: t
                            };
                            return e.sort(function(t, e) {
                                return t.time - e.time
                            }), e
                        }, u.invalidate = function() {
                            return this._locked = !1, t.prototype.invalidate.call(this)
                        }, u.progress = function(t, e) {
                            return arguments.length ? this.totalTime(this.duration() * (this._yoyo && 0 != (1 & this._cycle) ? 1 - t : t) + this._cycle * (this._duration + this._repeatDelay), e) : this._time / this.duration()
                        }, u.totalProgress = function(t, e) {
                            return arguments.length ? this.totalTime(this.totalDuration() * t, e) : this._totalTime / this.totalDuration()
                        }, u.totalDuration = function(e) {
                            return arguments.length ? -1 !== this._repeat && e ? this.timeScale(this.totalDuration() / e) : this : (this._dirty && (t.prototype.totalDuration.call(this), this._totalDuration = -1 === this._repeat ? 999999999999 : this._duration * (this._repeat + 1) + this._repeatDelay * this._repeat), this._totalDuration)
                        }, u.time = function(t, e) {
                            return arguments.length ? (this._dirty && this.totalDuration(), t > this._duration && (t = this._duration), this._yoyo && 0 != (1 & this._cycle) ? t = this._duration - t + this._cycle * (this._duration + this._repeatDelay) : 0 !== this._repeat && (t += this._cycle * (this._duration + this._repeatDelay)), this.totalTime(t, e)) : this._time
                        }, u.repeat = function(t) {
                            return arguments.length ? (this._repeat = t, this._uncache(!0)) : this._repeat
                        }, u.repeatDelay = function(t) {
                            return arguments.length ? (this._repeatDelay = t, this._uncache(!0)) : this._repeatDelay
                        }, u.yoyo = function(t) {
                            return arguments.length ? (this._yoyo = t, this) : this._yoyo
                        }, u.currentLabel = function(t) {
                            return arguments.length ? this.seek(t, !0) : this.getLabelBefore(this._time + 1e-8)
                        }, n
                    }, !0),
                    function() {
                        var t = 180 / Math.PI,
                            e = [],
                            i = [],
                            n = [],
                            r = {},
                            o = a._gsDefine.globals,
                            s = function(t, e, i, n) {
                                i === n && (i = n - (n - e) / 1e6), t === e && (e = t + (i - t) / 1e6), this.a = t, this.b = e, this.c = i, this.d = n, this.da = n - t, this.ca = i - t, this.ba = e - t
                            },
                            l = function(t, e, i, n) {
                                var r = {
                                        a: t
                                    },
                                    o = {},
                                    a = {},
                                    s = {
                                        c: n
                                    },
                                    l = (t + e) / 2,
                                    c = (e + i) / 2,
                                    u = (i + n) / 2,
                                    h = (l + c) / 2,
                                    d = (c + u) / 2,
                                    p = (d - h) / 8;
                                return r.b = l + (t - l) / 4, o.b = h + p, r.c = o.a = (r.b + o.b) / 2, o.c = a.a = (h + d) / 2, a.b = d - p, s.b = u + (n - u) / 4, a.c = s.a = (a.b + s.b) / 2, [r, o, a, s]
                            },
                            c = function(t, r, o, a, s) {
                                var c, u, h, d, p, f, m, g, v, y, _, x, b, w = t.length - 1,
                                    T = 0,
                                    S = t[0].a;
                                for (c = 0; c < w; c++) u = (p = t[T]).a, h = p.d, d = t[T + 1].d, s ? (_ = e[c], b = ((x = i[c]) + _) * r * .25 / (a ? .5 : n[c] || .5), g = h - ((f = h - (h - u) * (a ? .5 * r : 0 !== _ ? b / _ : 0)) + (((m = h + (d - h) * (a ? .5 * r : 0 !== x ? b / x : 0)) - f) * (3 * _ / (_ + x) + .5) / 4 || 0))) : g = h - ((f = h - (h - u) * r * .5) + (m = h + (d - h) * r * .5)) / 2, f += g, m += g, p.c = v = f, p.b = 0 !== c ? S : S = p.a + .6 * (p.c - p.a), p.da = h - u, p.ca = v - u, p.ba = S - u, o ? (y = l(u, S, v, h), t.splice(T, 1, y[0], y[1], y[2], y[3]), T += 4) : T++, S = m;
                                (p = t[T]).b = S, p.c = S + .4 * (p.d - S), p.da = p.d - p.a, p.ca = p.c - p.a, p.ba = S - p.a, o && (y = l(p.a, S, p.c, p.d), t.splice(T, 1, y[0], y[1], y[2], y[3]))
                            },
                            u = function(t, n, r, o) {
                                var a, l, c, u, h, d, p = [];
                                if (o)
                                    for (l = (t = [o].concat(t)).length; --l > -1;) "string" == typeof(d = t[l][n]) && "=" === d.charAt(1) && (t[l][n] = o[n] + Number(d.charAt(0) + d.substr(2)));
                                if ((a = t.length - 2) < 0) return p[0] = new s(t[0][n], 0, 0, t[a < -1 ? 0 : 1][n]), p;
                                for (l = 0; l < a; l++) c = t[l][n], u = t[l + 1][n], p[l] = new s(c, 0, 0, u), r && (h = t[l + 2][n], e[l] = (e[l] || 0) + (u - c) * (u - c), i[l] = (i[l] || 0) + (h - u) * (h - u));
                                return p[l] = new s(t[l][n], 0, 0, t[l + 1][n]), p
                            },
                            h = function(t, o, a, s, l, h) {
                                var d, p, f, m, g, v, y, _, x = {},
                                    b = [],
                                    w = h || t[0];
                                l = "string" == typeof l ? "," + l + "," : ",x,y,z,left,top,right,bottom,marginTop,marginLeft,marginRight,marginBottom,paddingLeft,paddingTop,paddingRight,paddingBottom,backgroundPosition,backgroundPosition_y,", null == o && (o = 1);
                                for (p in t[0]) b.push(p);
                                if (t.length > 1) {
                                    for (_ = t[t.length - 1], y = !0, d = b.length; --d > -1;)
                                        if (p = b[d], Math.abs(w[p] - _[p]) > .05) {
                                            y = !1;
                                            break
                                        } y && (t = t.concat(), h && t.unshift(h), t.push(t[1]), h = t[t.length - 3])
                                }
                                for (e.length = i.length = n.length = 0, d = b.length; --d > -1;) p = b[d], r[p] = -1 !== l.indexOf("," + p + ","), x[p] = u(t, p, r[p], h);
                                for (d = e.length; --d > -1;) e[d] = Math.sqrt(e[d]), i[d] = Math.sqrt(i[d]);
                                if (!s) {
                                    for (d = b.length; --d > -1;)
                                        if (r[p])
                                            for (v = (f = x[b[d]]).length - 1, m = 0; m < v; m++) g = f[m + 1].da / i[m] + f[m].da / e[m] || 0, n[m] = (n[m] || 0) + g * g;
                                    for (d = n.length; --d > -1;) n[d] = Math.sqrt(n[d])
                                }
                                for (d = b.length, m = a ? 4 : 1; --d > -1;) f = x[p = b[d]], c(f, o, a, s, r[p]), y && (f.splice(0, m), f.splice(f.length - m, m));
                                return x
                            },
                            d = function(t, e, i) {
                                var n, r, o, a, l, c, u, h, d, p, f, m = {},
                                    g = "cubic" === (e = e || "soft") ? 3 : 2,
                                    v = "soft" === e,
                                    y = [];
                                if (v && i && (t = [i].concat(t)), null == t || t.length < g + 1) throw "invalid Bezier data";
                                for (d in t[0]) y.push(d);
                                for (c = y.length; --c > -1;) {
                                    for (m[d = y[c]] = l = [], p = 0, h = t.length, u = 0; u < h; u++) n = null == i ? t[u][d] : "string" == typeof(f = t[u][d]) && "=" === f.charAt(1) ? i[d] + Number(f.charAt(0) + f.substr(2)) : Number(f), v && u > 1 && u < h - 1 && (l[p++] = (n + l[p - 2]) / 2), l[p++] = n;
                                    for (h = p - g + 1, p = 0, u = 0; u < h; u += g) n = l[u], r = l[u + 1], o = l[u + 2], a = 2 === g ? 0 : l[u + 3], l[p++] = f = 3 === g ? new s(n, r, o, a) : new s(n, (2 * r + n) / 3, (2 * r + o) / 3, o);
                                    l.length = p
                                }
                                return m
                            },
                            p = function(t, e, i) {
                                for (var n, r, o, a, s, l, c, u, h, d, p, f = 1 / i, m = t.length; --m > -1;)
                                    for (o = (d = t[m]).a, a = d.d - o, s = d.c - o, l = d.b - o, n = r = 0, u = 1; u <= i; u++) n = r - (r = ((c = f * u) * c * a + 3 * (h = 1 - c) * (c * s + h * l)) * c), e[p = m * i + u - 1] = (e[p] || 0) + n * n
                            },
                            f = function(t, e) {
                                var i, n, r, o, a = [],
                                    s = [],
                                    l = 0,
                                    c = 0,
                                    u = (e = e >> 0 || 6) - 1,
                                    h = [],
                                    d = [];
                                for (i in t) p(t[i], a, e);
                                for (r = a.length, n = 0; n < r; n++) l += Math.sqrt(a[n]), d[o = n % e] = l, o === u && (c += l, h[o = n / e >> 0] = d, s[o] = c, l = 0, d = []);
                                return {
                                    length: c,
                                    lengths: s,
                                    segments: h
                                }
                            },
                            m = a._gsDefine.plugin({
                                propName: "bezier",
                                priority: -1,
                                version: "1.3.7",
                                API: 2,
                                global: !0,
                                init: function(t, e, i) {
                                    this._target = t, e instanceof Array && (e = {
                                        values: e
                                    }), this._func = {}, this._mod = {}, this._props = [], this._timeRes = null == e.timeResolution ? 6 : parseInt(e.timeResolution, 10);
                                    var n, r, o, a, s, l = e.values || [],
                                        c = {},
                                        u = l[0],
                                        p = e.autoRotate || i.vars.orientToBezier;
                                    this._autoRotate = p ? p instanceof Array ? p : [
                                        ["x", "y", "rotation", !0 === p ? 0 : Number(p) || 0]
                                    ] : null;
                                    for (n in u) this._props.push(n);
                                    for (o = this._props.length; --o > -1;) n = this._props[o], this._overwriteProps.push(n), r = this._func[n] = "function" == typeof t[n], c[n] = r ? t[n.indexOf("set") || "function" != typeof t["get" + n.substr(3)] ? n : "get" + n.substr(3)]() : parseFloat(t[n]), s || c[n] !== l[0][n] && (s = c);
                                    if (this._beziers = "cubic" !== e.type && "quadratic" !== e.type && "soft" !== e.type ? h(l, isNaN(e.curviness) ? 1 : e.curviness, !1, "thruBasic" === e.type, e.correlate, s) : d(l, e.type, c), this._segCount = this._beziers[n].length, this._timeRes) {
                                        var m = f(this._beziers, this._timeRes);
                                        this._length = m.length, this._lengths = m.lengths, this._segments = m.segments, this._l1 = this._li = this._s1 = this._si = 0, this._l2 = this._lengths[0], this._curSeg = this._segments[0], this._s2 = this._curSeg[0], this._prec = 1 / this._curSeg.length
                                    }
                                    if (p = this._autoRotate)
                                        for (this._initialRotations = [], p[0] instanceof Array || (this._autoRotate = p = [p]), o = p.length; --o > -1;) {
                                            for (a = 0; a < 3; a++) n = p[o][a], this._func[n] = "function" == typeof t[n] && t[n.indexOf("set") || "function" != typeof t["get" + n.substr(3)] ? n : "get" + n.substr(3)];
                                            n = p[o][2], this._initialRotations[o] = (this._func[n] ? this._func[n].call(this._target) : this._target[n]) || 0, this._overwriteProps.push(n)
                                        }
                                    return this._startRatio = i.vars.runBackwards ? 1 : 0, !0
                                },
                                set: function(e) {
                                    var i, n, r, o, a, s, l, c, u, h, d = this._segCount,
                                        p = this._func,
                                        f = this._target,
                                        m = e !== this._startRatio;
                                    if (this._timeRes) {
                                        if (u = this._lengths, h = this._curSeg, e *= this._length, r = this._li, e > this._l2 && r < d - 1) {
                                            for (c = d - 1; r < c && (this._l2 = u[++r]) <= e;);
                                            this._l1 = u[r - 1], this._li = r, this._curSeg = h = this._segments[r], this._s2 = h[this._s1 = this._si = 0]
                                        } else if (e < this._l1 && r > 0) {
                                            for (; r > 0 && (this._l1 = u[--r]) >= e;);
                                            0 === r && e < this._l1 ? this._l1 = 0 : r++, this._l2 = u[r], this._li = r, this._curSeg = h = this._segments[r], this._s1 = h[(this._si = h.length - 1) - 1] || 0, this._s2 = h[this._si]
                                        }
                                        if (i = r, e -= this._l1, r = this._si, e > this._s2 && r < h.length - 1) {
                                            for (c = h.length - 1; r < c && (this._s2 = h[++r]) <= e;);
                                            this._s1 = h[r - 1], this._si = r
                                        } else if (e < this._s1 && r > 0) {
                                            for (; r > 0 && (this._s1 = h[--r]) >= e;);
                                            0 === r && e < this._s1 ? this._s1 = 0 : r++, this._s2 = h[r], this._si = r
                                        }
                                        s = (r + (e - this._s1) / (this._s2 - this._s1)) * this._prec || 0
                                    } else s = (e - (i = e < 0 ? 0 : e >= 1 ? d - 1 : d * e >> 0) * (1 / d)) * d;
                                    for (n = 1 - s, r = this._props.length; --r > -1;) o = this._props[r], l = (s * s * (a = this._beziers[o][i]).da + 3 * n * (s * a.ca + n * a.ba)) * s + a.a, this._mod[o] && (l = this._mod[o](l, f)), p[o] ? f[o](l) : f[o] = l;
                                    if (this._autoRotate) {
                                        var g, v, y, _, x, b, w, T = this._autoRotate;
                                        for (r = T.length; --r > -1;) o = T[r][2], b = T[r][3] || 0, w = !0 === T[r][4] ? 1 : t, a = this._beziers[T[r][0]], g = this._beziers[T[r][1]], a && g && (a = a[i], g = g[i], v = a.a + (a.b - a.a) * s, v += ((_ = a.b + (a.c - a.b) * s) - v) * s, _ += (a.c + (a.d - a.c) * s - _) * s, y = g.a + (g.b - g.a) * s, y += ((x = g.b + (g.c - g.b) * s) - y) * s, x += (g.c + (g.d - g.c) * s - x) * s, l = m ? Math.atan2(x - y, _ - v) * w + b : this._initialRotations[r], this._mod[o] && (l = this._mod[o](l, f)), p[o] ? f[o](l) : f[o] = l)
                                    }
                                }
                            }),
                            g = m.prototype;
                        m.bezierThrough = h, m.cubicToQuadratic = l, m._autoCSS = !0, m.quadraticToCubic = function(t, e, i) {
                            return new s(t, (2 * e + t) / 3, (2 * e + i) / 3, i)
                        }, m._cssRegister = function() {
                            var t = o.CSSPlugin;
                            if (t) {
                                var e = t._internals,
                                    i = e._parseToProxy,
                                    n = e._setPluginRatio,
                                    r = e.CSSPropTween;
                                e._registerComplexSpecialProp("bezier", {
                                    parser: function(t, e, o, a, s, l) {
                                        e instanceof Array && (e = {
                                            values: e
                                        }), l = new m;
                                        var c, u, h, d = e.values,
                                            p = d.length - 1,
                                            f = [],
                                            g = {};
                                        if (p < 0) return s;
                                        for (c = 0; c <= p; c++) h = i(t, d[c], a, s, l, p !== c), f[c] = h.end;
                                        for (u in e) g[u] = e[u];
                                        return g.values = f, s = new r(t, "bezier", 0, 0, h.pt, 2), s.data = h, s.plugin = l, s.setRatio = n, 0 === g.autoRotate && (g.autoRotate = !0), !g.autoRotate || g.autoRotate instanceof Array || (c = !0 === g.autoRotate ? 0 : Number(g.autoRotate), g.autoRotate = null != h.end.left ? [
                                            ["left", "top", "rotation", c, !1]
                                        ] : null != h.end.x && [
                                            ["x", "y", "rotation", c, !1]
                                        ]), g.autoRotate && (a._transform || a._enableTransforms(!1), h.autoRotate = a._target._gsTransform, h.proxy.rotation = h.autoRotate.rotation || 0, a._overwriteProps.push("rotation")), l._onInitTween(h.proxy, g, a._tween), s
                                    }
                                })
                            }
                        }, g._mod = function(t) {
                            for (var e, i = this._overwriteProps, n = i.length; --n > -1;)(e = t[i[n]]) && "function" == typeof e && (this._mod[i[n]] = e)
                        }, g._kill = function(t) {
                            var e, i, n = this._props;
                            for (e in this._beziers)
                                if (e in t)
                                    for (delete this._beziers[e], delete this._func[e], i = n.length; --i > -1;) n[i] === e && n.splice(i, 1);
                            if (n = this._autoRotate)
                                for (i = n.length; --i > -1;) t[n[i][2]] && n.splice(i, 1);
                            return this._super._kill.call(this, t)
                        }
                    }(), a._gsDefine("plugins.CSSPlugin", ["plugins.TweenPlugin", "TweenLite"], function(t, e) {
                        var i, n, r, o, s = function() {
                                t.call(this, "css"), this._overwriteProps.length = 0, this.setRatio = s.prototype.setRatio
                            },
                            l = a._gsDefine.globals,
                            c = {},
                            u = s.prototype = new t("css");
                        u.constructor = s, s.version = "1.19.1", s.API = 2, s.defaultTransformPerspective = 0, s.defaultSkewType = "compensated", s.defaultSmoothOrigin = !0, u = "px", s.suffixMap = {
                            top: u,
                            right: u,
                            bottom: u,
                            left: u,
                            width: u,
                            height: u,
                            fontSize: u,
                            padding: u,
                            margin: u,
                            perspective: u,
                            lineHeight: ""
                        };
                        var h, d, p, f, m, g, v, y, _ = /(?:\-|\.|\b)(\d|\.|e\-)+/g,
                            x = /(?:\d|\-\d|\.\d|\-\.\d|\+=\d|\-=\d|\+=.\d|\-=\.\d)+/g,
                            b = /(?:\+=|\-=|\-|\b)[\d\-\.]+[a-zA-Z0-9]*(?:%|\b)/gi,
                            w = /(?![+-]?\d*\.?\d+|[+-]|e[+-]\d+)[^0-9]/g,
                            T = /(?:\d|\-|\+|=|#|\.)*/g,
                            S = /opacity *= *([^)]*)/i,
                            E = /opacity:([^;]*)/i,
                            M = /alpha\(opacity *=.+?\)/i,
                            A = /^(rgb|hsl)/,
                            L = /([A-Z])/g,
                            C = /-([a-z])/gi,
                            P = /(^(?:url\(\"|url\())|(?:(\"\))$|\)$)/gi,
                            R = function(t, e) {
                                return e.toUpperCase()
                            },
                            O = /(?:Left|Right|Width)/i,
                            I = /(M11|M12|M21|M22)=[\d\-\.e]+/gi,
                            D = /progid\:DXImageTransform\.Microsoft\.Matrix\(.+?\)/i,
                            N = /,(?=[^\)]*(?:\(|$))/gi,
                            F = /[\s,\(]/i,
                            k = Math.PI / 180,
                            U = 180 / Math.PI,
                            B = {},
                            z = {
                                style: {}
                            },
                            j = a.document || {
                                createElement: function() {
                                    return z
                                }
                            },
                            H = function(t, e) {
                                return j.createElementNS ? j.createElementNS(e || "http://www.w3.org/1999/xhtml", t) : j.createElement(t)
                            },
                            G = H("div"),
                            V = H("img"),
                            W = s._internals = {
                                _specialProps: c
                            },
                            X = (a.navigator || {}).userAgent || "",
                            q = function() {
                                var t = X.indexOf("Android"),
                                    e = H("a");
                                return p = -1 !== X.indexOf("Safari") && -1 === X.indexOf("Chrome") && (-1 === t || parseFloat(X.substr(t + 8, 2)) > 3), m = p && parseFloat(X.substr(X.indexOf("Version/") + 8, 2)) < 6, f = -1 !== X.indexOf("Firefox"), (/MSIE ([0-9]{1,}[\.0-9]{0,})/.exec(X) || /Trident\/.*rv:([0-9]{1,}[\.0-9]{0,})/.exec(X)) && (g = parseFloat(RegExp.$1)), !!e && (e.style.cssText = "top:1px;opacity:.55;", /^0.55/.test(e.style.opacity))
                            }(),
                            Y = function(t) {
                                return S.test("string" == typeof t ? t : (t.currentStyle ? t.currentStyle.filter : t.style.filter) || "") ? parseFloat(RegExp.$1) / 100 : 1
                            },
                            Q = function(t) {
                                a.console && console.log(t)
                            },
                            Z = "",
                            J = "",
                            $ = function(t, e) {
                                var i, n, r = (e = e || G).style;
                                if (void 0 !== r[t]) return t;
                                for (t = t.charAt(0).toUpperCase() + t.substr(1), i = ["O", "Moz", "ms", "Ms", "Webkit"], n = 5; --n > -1 && void 0 === r[i[n] + t];);
                                return n >= 0 ? (J = 3 === n ? "ms" : i[n], Z = "-" + J.toLowerCase() + "-", J + t) : null
                            },
                            K = j.defaultView ? j.defaultView.getComputedStyle : function() {},
                            tt = s.getStyle = function(t, e, i, n, r) {
                                var o;
                                return q || "opacity" !== e ? (!n && t.style[e] ? o = t.style[e] : (i = i || K(t)) ? o = i[e] || i.getPropertyValue(e) || i.getPropertyValue(e.replace(L, "-$1").toLowerCase()) : t.currentStyle && (o = t.currentStyle[e]), null == r || o && "none" !== o && "auto" !== o && "auto auto" !== o ? o : r) : Y(t)
                            },
                            et = W.convertToPixels = function(t, i, n, r, o) {
                                if ("px" === r || !r) return n;
                                if ("auto" === r || !n) return 0;
                                var a, l, c, u = O.test(i),
                                    h = t,
                                    d = G.style,
                                    p = n < 0,
                                    f = 1 === n;
                                if (p && (n = -n), f && (n *= 100), "%" === r && -1 !== i.indexOf("border")) a = n / 100 * (u ? t.clientWidth : t.clientHeight);
                                else {
                                    if (d.cssText = "border:0 solid red;position:" + tt(t, "position") + ";line-height:0;", "%" !== r && h.appendChild && "v" !== r.charAt(0) && "rem" !== r) d[u ? "borderLeftWidth" : "borderTopWidth"] = n + r;
                                    else {
                                        if (h = t.parentNode || j.body, l = h._gsCache, c = e.ticker.frame, l && u && l.time === c) return l.width * n / 100;
                                        d[u ? "width" : "height"] = n + r
                                    }
                                    h.appendChild(G), a = parseFloat(G[u ? "offsetWidth" : "offsetHeight"]), h.removeChild(G), u && "%" === r && !1 !== s.cacheWidths && ((l = h._gsCache = h._gsCache || {}).time = c, l.width = a / n * 100), 0 !== a || o || (a = et(t, i, n, r, !0))
                                }
                                return f && (a /= 100), p ? -a : a
                            },
                            it = W.calculateOffset = function(t, e, i) {
                                if ("absolute" !== tt(t, "position", i)) return 0;
                                var n = "left" === e ? "Left" : "Top",
                                    r = tt(t, "margin" + n, i);
                                return t["offset" + n] - (et(t, e, parseFloat(r), r.replace(T, "")) || 0)
                            },
                            nt = function(t, e) {
                                var i, n, r, o = {};
                                if (e = e || K(t, null))
                                    if (i = e.length)
                                        for (; --i > -1;) - 1 !== (r = e[i]).indexOf("-transform") && Pt !== r || (o[r.replace(C, R)] = e.getPropertyValue(r));
                                    else
                                        for (i in e) - 1 !== i.indexOf("Transform") && Ct !== i || (o[i] = e[i]);
                                else if (e = t.currentStyle || t.style)
                                    for (i in e) "string" == typeof i && void 0 === o[i] && (o[i.replace(C, R)] = e[i]);
                                return q || (o.opacity = Y(t)), n = Vt(t, e, !1), o.rotation = n.rotation, o.skewX = n.skewX, o.scaleX = n.scaleX, o.scaleY = n.scaleY, o.x = n.x, o.y = n.y, Ot && (o.z = n.z, o.rotationX = n.rotationX, o.rotationY = n.rotationY, o.scaleZ = n.scaleZ), o.filters && delete o.filters, o
                            },
                            rt = function(t, e, i, n, r) {
                                var o, a, s, l = {},
                                    c = t.style;
                                for (a in i) "cssText" !== a && "length" !== a && isNaN(a) && (e[a] !== (o = i[a]) || r && r[a]) && -1 === a.indexOf("Origin") && ("number" != typeof o && "string" != typeof o || (l[a] = "auto" !== o || "left" !== a && "top" !== a ? "" !== o && "auto" !== o && "none" !== o || "string" != typeof e[a] || "" === e[a].replace(w, "") ? o : 0 : it(t, a), void 0 !== c[a] && (s = new _t(c, a, c[a], s))));
                                if (n)
                                    for (a in n) "className" !== a && (l[a] = n[a]);
                                return {
                                    difs: l,
                                    firstMPT: s
                                }
                            },
                            ot = {
                                width: ["Left", "Right"],
                                height: ["Top", "Bottom"]
                            },
                            at = ["marginLeft", "marginRight", "marginTop", "marginBottom"],
                            st = function(t, e, i) {
                                if ("svg" === (t.nodeName + "").toLowerCase()) return (i || K(t))[e] || 0;
                                if (t.getCTM && jt(t)) return t.getBBox()[e] || 0;
                                var n = parseFloat("width" === e ? t.offsetWidth : t.offsetHeight),
                                    r = ot[e],
                                    o = r.length;
                                for (i = i || K(t, null); --o > -1;) n -= parseFloat(tt(t, "padding" + r[o], i, !0)) || 0, n -= parseFloat(tt(t, "border" + r[o] + "Width", i, !0)) || 0;
                                return n
                            },
                            lt = function(t, e) {
                                if ("contain" === t || "auto" === t || "auto auto" === t) return t + " ";
                                null != t && "" !== t || (t = "0 0");
                                var i, n = t.split(" "),
                                    r = -1 !== t.indexOf("left") ? "0%" : -1 !== t.indexOf("right") ? "100%" : n[0],
                                    o = -1 !== t.indexOf("top") ? "0%" : -1 !== t.indexOf("bottom") ? "100%" : n[1];
                                if (n.length > 3 && !e) {
                                    for (n = t.split(", ").join(",").split(","), t = [], i = 0; i < n.length; i++) t.push(lt(n[i]));
                                    return t.join(",")
                                }
                                return null == o ? o = "center" === r ? "50%" : "0" : "center" === o && (o = "50%"), ("center" === r || isNaN(parseFloat(r)) && -1 === (r + "").indexOf("=")) && (r = "50%"), t = r + " " + o + (n.length > 2 ? " " + n[2] : ""), e && (e.oxp = -1 !== r.indexOf("%"), e.oyp = -1 !== o.indexOf("%"), e.oxr = "=" === r.charAt(1), e.oyr = "=" === o.charAt(1), e.ox = parseFloat(r.replace(w, "")), e.oy = parseFloat(o.replace(w, "")), e.v = t), e || t
                            },
                            ct = function(t, e) {
                                return "function" == typeof t && (t = t(y, v)), "string" == typeof t && "=" === t.charAt(1) ? parseInt(t.charAt(0) + "1", 10) * parseFloat(t.substr(2)) : parseFloat(t) - parseFloat(e) || 0
                            },
                            ut = function(t, e) {
                                return "function" == typeof t && (t = t(y, v)), null == t ? e : "string" == typeof t && "=" === t.charAt(1) ? parseInt(t.charAt(0) + "1", 10) * parseFloat(t.substr(2)) + e : parseFloat(t) || 0
                            },
                            ht = function(t, e, i, n) {
                                var r, o, a, s, l;
                                return "function" == typeof t && (t = t(y, v)), null == t ? s = e : "number" == typeof t ? s = t : (r = 360, o = t.split("_"), a = ((l = "=" === t.charAt(1)) ? parseInt(t.charAt(0) + "1", 10) * parseFloat(o[0].substr(2)) : parseFloat(o[0])) * (-1 === t.indexOf("rad") ? 1 : U) - (l ? 0 : e), o.length && (n && (n[i] = e + a), -1 !== t.indexOf("short") && (a %= r) !== a % (r / 2) && (a = a < 0 ? a + r : a - r), -1 !== t.indexOf("_cw") && a < 0 ? a = (a + 9999999999 * r) % r - (a / r | 0) * r : -1 !== t.indexOf("ccw") && a > 0 && (a = (a - 9999999999 * r) % r - (a / r | 0) * r)), s = e + a), s < 1e-6 && s > -1e-6 && (s = 0), s
                            },
                            dt = {
                                aqua: [0, 255, 255],
                                lime: [0, 255, 0],
                                silver: [192, 192, 192],
                                black: [0, 0, 0],
                                maroon: [128, 0, 0],
                                teal: [0, 128, 128],
                                blue: [0, 0, 255],
                                navy: [0, 0, 128],
                                white: [255, 255, 255],
                                fuchsia: [255, 0, 255],
                                olive: [128, 128, 0],
                                yellow: [255, 255, 0],
                                orange: [255, 165, 0],
                                gray: [128, 128, 128],
                                purple: [128, 0, 128],
                                green: [0, 128, 0],
                                red: [255, 0, 0],
                                pink: [255, 192, 203],
                                cyan: [0, 255, 255],
                                transparent: [255, 255, 255, 0]
                            },
                            pt = function(t, e, i) {
                                return t = t < 0 ? t + 1 : t > 1 ? t - 1 : t, 255 * (6 * t < 1 ? e + (i - e) * t * 6 : t < .5 ? i : 3 * t < 2 ? e + (i - e) * (2 / 3 - t) * 6 : e) + .5 | 0
                            },
                            ft = s.parseColor = function(t, e) {
                                var i, n, r, o, a, s, l, c, u, h, d;
                                if (t)
                                    if ("number" == typeof t) i = [t >> 16, t >> 8 & 255, 255 & t];
                                    else {
                                        if ("," === t.charAt(t.length - 1) && (t = t.substr(0, t.length - 1)), dt[t]) i = dt[t];
                                        else if ("#" === t.charAt(0)) 4 === t.length && (t = "#" + (n = t.charAt(1)) + n + (r = t.charAt(2)) + r + (o = t.charAt(3)) + o), i = [(t = parseInt(t.substr(1), 16)) >> 16, t >> 8 & 255, 255 & t];
                                        else if ("hsl" === t.substr(0, 3))
                                            if (i = d = t.match(_), e) {
                                                if (-1 !== t.indexOf("=")) return t.match(x)
                                            } else a = Number(i[0]) % 360 / 360, s = Number(i[1]) / 100, n = 2 * (l = Number(i[2]) / 100) - (r = l <= .5 ? l * (s + 1) : l + s - l * s), i.length > 3 && (i[3] = Number(t[3])), i[0] = pt(a + 1 / 3, n, r), i[1] = pt(a, n, r), i[2] = pt(a - 1 / 3, n, r);
                                        else i = t.match(_) || dt.transparent;
                                        i[0] = Number(i[0]), i[1] = Number(i[1]), i[2] = Number(i[2]), i.length > 3 && (i[3] = Number(i[3]))
                                    }
                                else i = dt.black;
                                return e && !d && (n = i[0] / 255, r = i[1] / 255, o = i[2] / 255, l = ((c = Math.max(n, r, o)) + (u = Math.min(n, r, o))) / 2, c === u ? a = s = 0 : (h = c - u, s = l > .5 ? h / (2 - c - u) : h / (c + u), a = c === n ? (r - o) / h + (r < o ? 6 : 0) : c === r ? (o - n) / h + 2 : (n - r) / h + 4, a *= 60), i[0] = a + .5 | 0, i[1] = 100 * s + .5 | 0, i[2] = 100 * l + .5 | 0), i
                            },
                            mt = function(t, e) {
                                var i, n, r, o = t.match(gt) || [],
                                    a = 0,
                                    s = o.length ? "" : t;
                                for (i = 0; i < o.length; i++) n = o[i], a += (r = t.substr(a, t.indexOf(n, a) - a)).length + n.length, 3 === (n = ft(n, e)).length && n.push(1), s += r + (e ? "hsla(" + n[0] + "," + n[1] + "%," + n[2] + "%," + n[3] : "rgba(" + n.join(",")) + ")";
                                return s + t.substr(a)
                            },
                            gt = "(?:\\b(?:(?:rgb|rgba|hsl|hsla)\\(.+?\\))|\\B#(?:[0-9a-f]{3}){1,2}\\b";
                        for (u in dt) gt += "|" + u + "\\b";
                        gt = new RegExp(gt + ")", "gi"), s.colorStringFilter = function(t) {
                            var e, i = t[0] + t[1];
                            gt.test(i) && (e = -1 !== i.indexOf("hsl(") || -1 !== i.indexOf("hsla("), t[0] = mt(t[0], e), t[1] = mt(t[1], e)), gt.lastIndex = 0
                        }, e.defaultStringFilter || (e.defaultStringFilter = s.colorStringFilter);
                        var vt = function(t, e, i, n) {
                                if (null == t) return function(t) {
                                    return t
                                };
                                var r, o = e ? (t.match(gt) || [""])[0] : "",
                                    a = t.split(o).join("").match(b) || [],
                                    s = t.substr(0, t.indexOf(a[0])),
                                    l = ")" === t.charAt(t.length - 1) ? ")" : "",
                                    c = -1 !== t.indexOf(" ") ? " " : ",",
                                    u = a.length,
                                    h = u > 0 ? a[0].replace(_, "") : "";
                                return u ? r = e ? function(t) {
                                    var e, d, p, f;
                                    if ("number" == typeof t) t += h;
                                    else if (n && N.test(t)) {
                                        for (f = t.replace(N, "|").split("|"), p = 0; p < f.length; p++) f[p] = r(f[p]);
                                        return f.join(",")
                                    }
                                    if (e = (t.match(gt) || [o])[0], d = t.split(e).join("").match(b) || [], p = d.length, u > p--)
                                        for (; ++p < u;) d[p] = i ? d[(p - 1) / 2 | 0] : a[p];
                                    return s + d.join(c) + c + e + l + (-1 !== t.indexOf("inset") ? " inset" : "")
                                } : function(t) {
                                    var e, o, d;
                                    if ("number" == typeof t) t += h;
                                    else if (n && N.test(t)) {
                                        for (o = t.replace(N, "|").split("|"), d = 0; d < o.length; d++) o[d] = r(o[d]);
                                        return o.join(",")
                                    }
                                    if (e = t.match(b) || [], d = e.length, u > d--)
                                        for (; ++d < u;) e[d] = i ? e[(d - 1) / 2 | 0] : a[d];
                                    return s + e.join(c) + l
                                } : function(t) {
                                    return t
                                }
                            },
                            yt = function(t) {
                                return t = t.split(","),
                                    function(e, i, n, r, o, a, s) {
                                        var l, c = (i + "").split(" ");
                                        for (s = {}, l = 0; l < 4; l++) s[t[l]] = c[l] = c[l] || c[(l - 1) / 2 >> 0];
                                        return r.parse(e, s, o, a)
                                    }
                            },
                            _t = (W._setPluginRatio = function(t) {
                                this.plugin.setRatio(t);
                                for (var e, i, n, r, o, a = this.data, s = a.proxy, l = a.firstMPT; l;) e = s[l.v], l.r ? e = Math.round(e) : e < 1e-6 && e > -1e-6 && (e = 0), l.t[l.p] = e, l = l._next;
                                if (a.autoRotate && (a.autoRotate.rotation = a.mod ? a.mod(s.rotation, this.t) : s.rotation), 1 === t || 0 === t)
                                    for (l = a.firstMPT, o = 1 === t ? "e" : "b"; l;) {
                                        if ((i = l.t).type) {
                                            if (1 === i.type) {
                                                for (r = i.xs0 + i.s + i.xs1, n = 1; n < i.l; n++) r += i["xn" + n] + i["xs" + (n + 1)];
                                                i[o] = r
                                            }
                                        } else i[o] = i.s + i.xs0;
                                        l = l._next
                                    }
                            }, function(t, e, i, n, r) {
                                this.t = t, this.p = e, this.v = i, this.r = r, n && (n._prev = this, this._next = n)
                            }),
                            xt = (W._parseToProxy = function(t, e, i, n, r, o) {
                                var a, s, l, c, u, h = n,
                                    d = {},
                                    p = {},
                                    f = i._transform,
                                    m = B;
                                for (i._transform = null, B = e, n = u = i.parse(t, e, n, r), B = m, o && (i._transform = f, h && (h._prev = null, h._prev && (h._prev._next = null))); n && n !== h;) {
                                    if (n.type <= 1 && (s = n.p, p[s] = n.s + n.c, d[s] = n.s, o || (c = new _t(n, "s", s, c, n.r), n.c = 0), 1 === n.type))
                                        for (a = n.l; --a > 0;) l = "xn" + a, p[s = n.p + "_" + l] = n.data[l], d[s] = n[l], o || (c = new _t(n, l, s, c, n.rxp[l]));
                                    n = n._next
                                }
                                return {
                                    proxy: d,
                                    end: p,
                                    firstMPT: c,
                                    pt: u
                                }
                            }, W.CSSPropTween = function(t, e, n, r, a, s, l, c, u, h, d) {
                                this.t = t, this.p = e, this.s = n, this.c = r, this.n = l || e, t instanceof xt || o.push(this.n), this.r = c, this.type = s || 0, u && (this.pr = u, i = !0), this.b = void 0 === h ? n : h, this.e = void 0 === d ? n + r : d, a && (this._next = a, a._prev = this)
                            }),
                            bt = function(t, e, i, n, r, o) {
                                var a = new xt(t, e, i, n - i, r, -1, o);
                                return a.b = i, a.e = a.xs0 = n, a
                            },
                            wt = s.parseComplex = function(t, e, i, n, r, o, a, l, c, u) {
                                i = i || o || "", "function" == typeof n && (n = n(y, v)), a = new xt(t, e, 0, 0, a, u ? 2 : 1, null, !1, l, i, n), n += "", r && gt.test(n + i) && (n = [i, n], s.colorStringFilter(n), i = n[0], n = n[1]);
                                var d, p, f, m, g, b, w, T, S, E, M, A, L, C = i.split(", ").join(",").split(" "),
                                    P = n.split(", ").join(",").split(" "),
                                    R = C.length,
                                    O = !1 !== h;
                                for (-1 === n.indexOf(",") && -1 === i.indexOf(",") || (C = C.join(" ").replace(N, ", ").split(" "), P = P.join(" ").replace(N, ", ").split(" "), R = C.length), R !== P.length && (R = (C = (o || "").split(" ")).length), a.plugin = c, a.setRatio = u, gt.lastIndex = 0, d = 0; d < R; d++)
                                    if (m = C[d], g = P[d], (T = parseFloat(m)) || 0 === T) a.appendXtra("", T, ct(g, T), g.replace(x, ""), O && -1 !== g.indexOf("px"), !0);
                                    else if (r && gt.test(m)) A = ")" + ((A = g.indexOf(")") + 1) ? g.substr(A) : ""), L = -1 !== g.indexOf("hsl") && q, m = ft(m, L), g = ft(g, L), (S = m.length + g.length > 6) && !q && 0 === g[3] ? (a["xs" + a.l] += a.l ? " transparent" : "transparent", a.e = a.e.split(P[d]).join("transparent")) : (q || (S = !1), L ? a.appendXtra(S ? "hsla(" : "hsl(", m[0], ct(g[0], m[0]), ",", !1, !0).appendXtra("", m[1], ct(g[1], m[1]), "%,", !1).appendXtra("", m[2], ct(g[2], m[2]), S ? "%," : "%" + A, !1) : a.appendXtra(S ? "rgba(" : "rgb(", m[0], g[0] - m[0], ",", !0, !0).appendXtra("", m[1], g[1] - m[1], ",", !0).appendXtra("", m[2], g[2] - m[2], S ? "," : A, !0), S && (m = m.length < 4 ? 1 : m[3], a.appendXtra("", m, (g.length < 4 ? 1 : g[3]) - m, A, !1))), gt.lastIndex = 0;
                                else if (b = m.match(_)) {
                                    if (!(w = g.match(x)) || w.length !== b.length) return a;
                                    for (f = 0, p = 0; p < b.length; p++) M = b[p], E = m.indexOf(M, f), a.appendXtra(m.substr(f, E - f), Number(M), ct(w[p], M), "", O && "px" === m.substr(E + M.length, 2), 0 === p), f = E + M.length;
                                    a["xs" + a.l] += m.substr(f)
                                } else a["xs" + a.l] += a.l || a["xs" + a.l] ? " " + g : g;
                                if (-1 !== n.indexOf("=") && a.data) {
                                    for (A = a.xs0 + a.data.s, d = 1; d < a.l; d++) A += a["xs" + d] + a.data["xn" + d];
                                    a.e = A + a["xs" + d]
                                }
                                return a.l || (a.type = -1, a.xs0 = a.e), a.xfirst || a
                            },
                            Tt = 9;
                        for ((u = xt.prototype).l = u.pr = 0; --Tt > 0;) u["xn" + Tt] = 0, u["xs" + Tt] = "";
                        u.xs0 = "", u._next = u._prev = u.xfirst = u.data = u.plugin = u.setRatio = u.rxp = null, u.appendXtra = function(t, e, i, n, r, o) {
                            var a = this,
                                s = a.l;
                            return a["xs" + s] += o && (s || a["xs" + s]) ? " " + t : t || "", i || 0 === s || a.plugin ? (a.l++, a.type = a.setRatio ? 2 : 1, a["xs" + a.l] = n || "", s > 0 ? (a.data["xn" + s] = e + i, a.rxp["xn" + s] = r, a["xn" + s] = e, a.plugin || (a.xfirst = new xt(a, "xn" + s, e, i, a.xfirst || a, 0, a.n, r, a.pr), a.xfirst.xs0 = 0), a) : (a.data = {
                                s: e + i
                            }, a.rxp = {}, a.s = e, a.c = i, a.r = r, a)) : (a["xs" + s] += e + (n || ""), a)
                        };
                        var St = function(t, e) {
                                e = e || {}, this.p = e.prefix ? $(t) || t : t, c[t] = c[this.p] = this, this.format = e.formatter || vt(e.defaultValue, e.color, e.collapsible, e.multi), e.parser && (this.parse = e.parser), this.clrs = e.color, this.multi = e.multi, this.keyword = e.keyword, this.dflt = e.defaultValue, this.pr = e.priority || 0
                            },
                            Et = W._registerComplexSpecialProp = function(t, e, i) {
                                "object" != typeof e && (e = {
                                    parser: i
                                });
                                var n, r = t.split(","),
                                    o = e.defaultValue;
                                for (i = i || [o], n = 0; n < r.length; n++) e.prefix = 0 === n && e.prefix, e.defaultValue = i[n] || o, new St(r[n], e)
                            },
                            Mt = W._registerPluginProp = function(t) {
                                if (!c[t]) {
                                    var e = t.charAt(0).toUpperCase() + t.substr(1) + "Plugin";
                                    Et(t, {
                                        parser: function(t, i, n, r, o, a, s) {
                                            var u = l.com.greensock.plugins[e];
                                            return u ? (u._cssRegister(), c[n].parse(t, i, n, r, o, a, s)) : (Q("Error: " + e + " js file not loaded."), o)
                                        }
                                    })
                                }
                            };
                        (u = St.prototype).parseComplex = function(t, e, i, n, r, o) {
                            var a, s, l, c, u, h, d = this.keyword;
                            if (this.multi && (N.test(i) || N.test(e) ? (s = e.replace(N, "|").split("|"), l = i.replace(N, "|").split("|")) : d && (s = [e], l = [i])), l) {
                                for (c = l.length > s.length ? l.length : s.length, a = 0; a < c; a++) e = s[a] = s[a] || this.dflt, i = l[a] = l[a] || this.dflt, d && (u = e.indexOf(d)) !== (h = i.indexOf(d)) && (-1 === h ? s[a] = s[a].split(d).join("") : -1 === u && (s[a] += " " + d));
                                e = s.join(", "), i = l.join(", ")
                            }
                            return wt(t, this.p, e, i, this.clrs, this.dflt, n, this.pr, r, o)
                        }, u.parse = function(t, e, i, n, o, a, s) {
                            return this.parseComplex(t.style, this.format(tt(t, this.p, r, !1, this.dflt)), this.format(e), o, a)
                        }, s.registerSpecialProp = function(t, e, i) {
                            Et(t, {
                                parser: function(t, n, r, o, a, s, l) {
                                    var c = new xt(t, r, 0, 0, a, 2, r, !1, i);
                                    return c.plugin = s, c.setRatio = e(t, n, o._tween, r), c
                                },
                                priority: i
                            })
                        }, s.useSVGTransformAttr = !0;
                        var At, Lt = "scaleX,scaleY,scaleZ,x,y,z,skewX,skewY,rotation,rotationX,rotationY,perspective,xPercent,yPercent".split(","),
                            Ct = $("transform"),
                            Pt = Z + "transform",
                            Rt = $("transformOrigin"),
                            Ot = null !== $("perspective"),
                            It = W.Transform = function() {
                                this.perspective = parseFloat(s.defaultTransformPerspective) || 0, this.force3D = !(!1 === s.defaultForce3D || !Ot) && (s.defaultForce3D || "auto")
                            },
                            Dt = a.SVGElement,
                            Nt = function(t, e, i) {
                                var n, r = j.createElementNS("http://www.w3.org/2000/svg", t),
                                    o = /([a-z])([A-Z])/g;
                                for (n in i) r.setAttributeNS(null, n.replace(o, "$1-$2").toLowerCase(), i[n]);
                                return e.appendChild(r), r
                            },
                            Ft = j.documentElement || {},
                            kt = function() {
                                var t, e, i, n = g || /Android/i.test(X) && !a.chrome;
                                return j.createElementNS && !n && (t = Nt("svg", Ft), i = (e = Nt("rect", t, {
                                    width: 100,
                                    height: 50,
                                    x: 100
                                })).getBoundingClientRect().width, e.style[Rt] = "50% 50%", e.style[Ct] = "scaleX(0.5)", n = i === e.getBoundingClientRect().width && !(f && Ot), Ft.removeChild(t)), n
                            }(),
                            Ut = function(t, e, i, n, r, o) {
                                var a, l, c, u, h, d, p, f, m, g, v, y, _, x, b = t._gsTransform,
                                    w = Gt(t, !0);
                                b && (_ = b.xOrigin, x = b.yOrigin), (!n || (a = n.split(" ")).length < 2) && (0 === (p = t.getBBox()).x && 0 === p.y && p.width + p.height === 0 && (p = {
                                    x: parseFloat(t.hasAttribute("x") ? t.getAttribute("x") : t.hasAttribute("cx") ? t.getAttribute("cx") : 0) || 0,
                                    y: parseFloat(t.hasAttribute("y") ? t.getAttribute("y") : t.hasAttribute("cy") ? t.getAttribute("cy") : 0) || 0,
                                    width: 0,
                                    height: 0
                                }), a = [(-1 !== (e = lt(e).split(" "))[0].indexOf("%") ? parseFloat(e[0]) / 100 * p.width : parseFloat(e[0])) + p.x, (-1 !== e[1].indexOf("%") ? parseFloat(e[1]) / 100 * p.height : parseFloat(e[1])) + p.y]), i.xOrigin = u = parseFloat(a[0]), i.yOrigin = h = parseFloat(a[1]), n && w !== Ht && (d = w[0], p = w[1], f = w[2], m = w[3], g = w[4], v = w[5], (y = d * m - p * f) && (l = u * (m / y) + h * (-f / y) + (f * v - m * g) / y, c = u * (-p / y) + h * (d / y) - (d * v - p * g) / y, u = i.xOrigin = a[0] = l, h = i.yOrigin = a[1] = c)), b && (o && (i.xOffset = b.xOffset, i.yOffset = b.yOffset, b = i), r || !1 !== r && !1 !== s.defaultSmoothOrigin ? (l = u - _, c = h - x, b.xOffset += l * w[0] + c * w[2] - l, b.yOffset += l * w[1] + c * w[3] - c) : b.xOffset = b.yOffset = 0), o || t.setAttribute("data-svg-origin", a.join(" "))
                            },
                            Bt = function(t) {
                                var e, i = H("svg", this.ownerSVGElement.getAttribute("xmlns") || "http://www.w3.org/2000/svg"),
                                    n = this.parentNode,
                                    r = this.nextSibling,
                                    o = this.style.cssText;
                                if (Ft.appendChild(i), i.appendChild(this), this.style.display = "block", t) try {
                                    e = this.getBBox(), this._originalGetBBox = this.getBBox, this.getBBox = Bt
                                } catch (t) {} else this._originalGetBBox && (e = this._originalGetBBox());
                                return r ? n.insertBefore(this, r) : n.appendChild(this), Ft.removeChild(i), this.style.cssText = o, e
                            },
                            zt = function(t) {
                                try {
                                    return t.getBBox()
                                } catch (e) {
                                    return Bt.call(t, !0)
                                }
                            },
                            jt = function(t) {
                                return !(!(Dt && t.getCTM && zt(t)) || t.parentNode && !t.ownerSVGElement)
                            },
                            Ht = [1, 0, 0, 1, 0, 0],
                            Gt = function(t, e) {
                                var i, n, r, o, a, s, l = t._gsTransform || new It,
                                    c = t.style;
                                if (Ct ? n = tt(t, Pt, null, !0) : t.currentStyle && (n = (n = t.currentStyle.filter.match(I)) && 4 === n.length ? [n[0].substr(4), Number(n[2].substr(4)), Number(n[1].substr(4)), n[3].substr(4), l.x || 0, l.y || 0].join(",") : ""), (i = !n || "none" === n || "matrix(1, 0, 0, 1, 0, 0)" === n) && Ct && ((s = "none" === K(t).display) || !t.parentNode) && (s && (o = c.display, c.display = "block"), t.parentNode || (a = 1, Ft.appendChild(t)), i = !(n = tt(t, Pt, null, !0)) || "none" === n || "matrix(1, 0, 0, 1, 0, 0)" === n, o ? c.display = o : s && Yt(c, "display"), a && Ft.removeChild(t)), (l.svg || t.getCTM && jt(t)) && (i && -1 !== (c[Ct] + "").indexOf("matrix") && (n = c[Ct], i = 0), r = t.getAttribute("transform"), i && r && (-1 !== r.indexOf("matrix") ? (n = r, i = 0) : -1 !== r.indexOf("translate") && (n = "matrix(1,0,0,1," + r.match(/(?:\-|\b)[\d\-\.e]+\b/gi).join(",") + ")", i = 0))), i) return Ht;
                                for (r = (n || "").match(_) || [], Tt = r.length; --Tt > -1;) o = Number(r[Tt]), r[Tt] = (a = o - (o |= 0)) ? (1e5 * a + (a < 0 ? -.5 : .5) | 0) / 1e5 + o : o;
                                return e && r.length > 6 ? [r[0], r[1], r[4], r[5], r[12], r[13]] : r
                            },
                            Vt = W.getTransform = function(t, i, n, r) {
                                if (t._gsTransform && n && !r) return t._gsTransform;
                                var o, a, l, c, u, h, d = n ? t._gsTransform || new It : new It,
                                    p = d.scaleX < 0,
                                    f = Ot ? parseFloat(tt(t, Rt, i, !1, "0 0 0").split(" ")[2]) || d.zOrigin || 0 : 0,
                                    m = parseFloat(s.defaultTransformPerspective) || 0;
                                if (d.svg = !(!t.getCTM || !jt(t)), d.svg && (Ut(t, tt(t, Rt, i, !1, "50% 50%") + "", d, t.getAttribute("data-svg-origin")), At = s.useSVGTransformAttr || kt), (o = Gt(t)) !== Ht) {
                                    if (16 === o.length) {
                                        var g, v, y, _, x, b = o[0],
                                            w = o[1],
                                            T = o[2],
                                            S = o[3],
                                            E = o[4],
                                            M = o[5],
                                            A = o[6],
                                            L = o[7],
                                            C = o[8],
                                            P = o[9],
                                            R = o[10],
                                            O = o[12],
                                            I = o[13],
                                            D = o[14],
                                            N = o[11],
                                            F = Math.atan2(A, R);
                                        d.zOrigin && (O = C * (D = -d.zOrigin) - o[12], I = P * D - o[13], D = R * D + d.zOrigin - o[14]), d.rotationX = F * U, F && (g = E * (_ = Math.cos(-F)) + C * (x = Math.sin(-F)), v = M * _ + P * x, y = A * _ + R * x, C = E * -x + C * _, P = M * -x + P * _, R = A * -x + R * _, N = L * -x + N * _, E = g, M = v, A = y), F = Math.atan2(-T, R), d.rotationY = F * U, F && (v = w * (_ = Math.cos(-F)) - P * (x = Math.sin(-F)), y = T * _ - R * x, P = w * x + P * _, R = T * x + R * _, N = S * x + N * _, b = g = b * _ - C * x, w = v, T = y), F = Math.atan2(w, b), d.rotation = F * U, F && (b = b * (_ = Math.cos(-F)) + E * (x = Math.sin(-F)), v = w * _ + M * x, M = w * -x + M * _, A = T * -x + A * _, w = v), d.rotationX && Math.abs(d.rotationX) + Math.abs(d.rotation) > 359.9 && (d.rotationX = d.rotation = 0, d.rotationY = 180 - d.rotationY), d.scaleX = (1e5 * Math.sqrt(b * b + w * w) + .5 | 0) / 1e5, d.scaleY = (1e5 * Math.sqrt(M * M + P * P) + .5 | 0) / 1e5, d.scaleZ = (1e5 * Math.sqrt(A * A + R * R) + .5 | 0) / 1e5, d.rotationX || d.rotationY ? d.skewX = 0 : (d.skewX = E || M ? Math.atan2(E, M) * U + d.rotation : d.skewX || 0, Math.abs(d.skewX) > 90 && Math.abs(d.skewX) < 270 && (p ? (d.scaleX *= -1, d.skewX += d.rotation <= 0 ? 180 : -180, d.rotation += d.rotation <= 0 ? 180 : -180) : (d.scaleY *= -1, d.skewX += d.skewX <= 0 ? 180 : -180))), d.perspective = N ? 1 / (N < 0 ? -N : N) : 0, d.x = O, d.y = I, d.z = D, d.svg && (d.x -= d.xOrigin - (d.xOrigin * b - d.yOrigin * E), d.y -= d.yOrigin - (d.yOrigin * w - d.xOrigin * M))
                                    } else if (!Ot || r || !o.length || d.x !== o[4] || d.y !== o[5] || !d.rotationX && !d.rotationY) {
                                        var k = o.length >= 6,
                                            B = k ? o[0] : 1,
                                            z = o[1] || 0,
                                            j = o[2] || 0,
                                            H = k ? o[3] : 1;
                                        d.x = o[4] || 0, d.y = o[5] || 0, l = Math.sqrt(B * B + z * z), c = Math.sqrt(H * H + j * j), u = B || z ? Math.atan2(z, B) * U : d.rotation || 0, h = j || H ? Math.atan2(j, H) * U + u : d.skewX || 0, Math.abs(h) > 90 && Math.abs(h) < 270 && (p ? (l *= -1, h += u <= 0 ? 180 : -180, u += u <= 0 ? 180 : -180) : (c *= -1, h += h <= 0 ? 180 : -180)), d.scaleX = l, d.scaleY = c, d.rotation = u, d.skewX = h, Ot && (d.rotationX = d.rotationY = d.z = 0, d.perspective = m, d.scaleZ = 1), d.svg && (d.x -= d.xOrigin - (d.xOrigin * B + d.yOrigin * j), d.y -= d.yOrigin - (d.xOrigin * z + d.yOrigin * H))
                                    }
                                    d.zOrigin = f;
                                    for (a in d) d[a] < 2e-5 && d[a] > -2e-5 && (d[a] = 0)
                                }
                                return n && (t._gsTransform = d, d.svg && (At && t.style[Ct] ? e.delayedCall(.001, function() {
                                    Yt(t.style, Ct)
                                }) : !At && t.getAttribute("transform") && e.delayedCall(.001, function() {
                                    t.removeAttribute("transform")
                                }))), d
                            },
                            Wt = function(t) {
                                var e, i, n = this.data,
                                    r = -n.rotation * k,
                                    o = r + n.skewX * k,
                                    a = (Math.cos(r) * n.scaleX * 1e5 | 0) / 1e5,
                                    s = (Math.sin(r) * n.scaleX * 1e5 | 0) / 1e5,
                                    l = (Math.sin(o) * -n.scaleY * 1e5 | 0) / 1e5,
                                    c = (Math.cos(o) * n.scaleY * 1e5 | 0) / 1e5,
                                    u = this.t.style,
                                    h = this.t.currentStyle;
                                if (h) {
                                    i = s, s = -l, l = -i, e = h.filter, u.filter = "";
                                    var d, p, f = this.t.offsetWidth,
                                        m = this.t.offsetHeight,
                                        v = "absolute" !== h.position,
                                        y = "progid:DXImageTransform.Microsoft.Matrix(M11=" + a + ", M12=" + s + ", M21=" + l + ", M22=" + c,
                                        _ = n.x + f * n.xPercent / 100,
                                        x = n.y + m * n.yPercent / 100;
                                    if (null != n.ox && (_ += (d = (n.oxp ? f * n.ox * .01 : n.ox) - f / 2) - (d * a + (p = (n.oyp ? m * n.oy * .01 : n.oy) - m / 2) * s), x += p - (d * l + p * c)), y += v ? ", Dx=" + ((d = f / 2) - (d * a + (p = m / 2) * s) + _) + ", Dy=" + (p - (d * l + p * c) + x) + ")" : ", sizingMethod='auto expand')", -1 !== e.indexOf("DXImageTransform.Microsoft.Matrix(") ? u.filter = e.replace(D, y) : u.filter = y + " " + e, 0 !== t && 1 !== t || 1 === a && 0 === s && 0 === l && 1 === c && (v && -1 === y.indexOf("Dx=0, Dy=0") || S.test(e) && 100 !== parseFloat(RegExp.$1) || -1 === e.indexOf(e.indexOf("Alpha")) && u.removeAttribute("filter")), !v) {
                                        var b, w, E, M = g < 8 ? 1 : -1;
                                        for (d = n.ieOffsetX || 0, p = n.ieOffsetY || 0, n.ieOffsetX = Math.round((f - ((a < 0 ? -a : a) * f + (s < 0 ? -s : s) * m)) / 2 + _), n.ieOffsetY = Math.round((m - ((c < 0 ? -c : c) * m + (l < 0 ? -l : l) * f)) / 2 + x), Tt = 0; Tt < 4; Tt++) E = (i = -1 !== (b = h[w = at[Tt]]).indexOf("px") ? parseFloat(b) : et(this.t, w, parseFloat(b), b.replace(T, "")) || 0) !== n[w] ? Tt < 2 ? -n.ieOffsetX : -n.ieOffsetY : Tt < 2 ? d - n.ieOffsetX : p - n.ieOffsetY, u[w] = (n[w] = Math.round(i - E * (0 === Tt || 2 === Tt ? 1 : M))) + "px"
                                    }
                                }
                            },
                            Xt = W.set3DTransformRatio = W.setTransformRatio = function(t) {
                                var e, i, n, r, o, a, s, l, c, u, h, d, p, m, g, v, y, _, x, b, w, T = this.data,
                                    S = this.t.style,
                                    E = T.rotation,
                                    M = T.rotationX,
                                    A = T.rotationY,
                                    L = T.scaleX,
                                    C = T.scaleY,
                                    P = T.scaleZ,
                                    R = T.x,
                                    O = T.y,
                                    I = T.z,
                                    D = T.svg,
                                    N = T.perspective,
                                    F = T.force3D,
                                    U = T.skewY,
                                    B = T.skewX;
                                if (U && (B += U, E += U), !((1 !== t && 0 !== t || "auto" !== F || this.tween._totalTime !== this.tween._totalDuration && this.tween._totalTime) && F || I || N || A || M || 1 !== P) || At && D || !Ot) E || B || D ? (E *= k, b = B * k, w = 1e5, i = Math.cos(E) * L, o = Math.sin(E) * L, n = Math.sin(E - b) * -C, a = Math.cos(E - b) * C, b && "simple" === T.skewType && (e = Math.tan(b - U * k), n *= e = Math.sqrt(1 + e * e), a *= e, U && (e = Math.tan(U * k), i *= e = Math.sqrt(1 + e * e), o *= e)), D && (R += T.xOrigin - (T.xOrigin * i + T.yOrigin * n) + T.xOffset, O += T.yOrigin - (T.xOrigin * o + T.yOrigin * a) + T.yOffset, At && (T.xPercent || T.yPercent) && (g = this.t.getBBox(), R += .01 * T.xPercent * g.width, O += .01 * T.yPercent * g.height), R < (g = 1e-6) && R > -g && (R = 0), O < g && O > -g && (O = 0)), x = (i * w | 0) / w + "," + (o * w | 0) / w + "," + (n * w | 0) / w + "," + (a * w | 0) / w + "," + R + "," + O + ")", D && At ? this.t.setAttribute("transform", "matrix(" + x) : S[Ct] = (T.xPercent || T.yPercent ? "translate(" + T.xPercent + "%," + T.yPercent + "%) matrix(" : "matrix(") + x) : S[Ct] = (T.xPercent || T.yPercent ? "translate(" + T.xPercent + "%," + T.yPercent + "%) matrix(" : "matrix(") + L + ",0,0," + C + "," + R + "," + O + ")";
                                else {
                                    if (f && (L < (g = 1e-4) && L > -g && (L = P = 2e-5), C < g && C > -g && (C = P = 2e-5), !N || T.z || T.rotationX || T.rotationY || (N = 0)), E || B) E *= k, v = i = Math.cos(E), y = o = Math.sin(E), B && (E -= B * k, v = Math.cos(E), y = Math.sin(E), "simple" === T.skewType && (e = Math.tan((B - U) * k), v *= e = Math.sqrt(1 + e * e), y *= e, T.skewY && (e = Math.tan(U * k), i *= e = Math.sqrt(1 + e * e), o *= e))), n = -y, a = v;
                                    else {
                                        if (!(A || M || 1 !== P || N || D)) return void(S[Ct] = (T.xPercent || T.yPercent ? "translate(" + T.xPercent + "%," + T.yPercent + "%) translate3d(" : "translate3d(") + R + "px," + O + "px," + I + "px)" + (1 !== L || 1 !== C ? " scale(" + L + "," + C + ")" : ""));
                                        i = a = 1, n = o = 0
                                    }
                                    u = 1, r = s = l = c = h = d = 0, p = N ? -1 / N : 0, m = T.zOrigin, g = 1e-6, ",", "0", (E = A * k) && (v = Math.cos(E), l = -(y = Math.sin(E)), h = p * -y, r = i * y, s = o * y, u = v, p *= v, i *= v, o *= v), (E = M * k) && (e = n * (v = Math.cos(E)) + r * (y = Math.sin(E)), _ = a * v + s * y, c = u * y, d = p * y, r = n * -y + r * v, s = a * -y + s * v, u *= v, p *= v, n = e, a = _), 1 !== P && (r *= P, s *= P, u *= P, p *= P), 1 !== C && (n *= C, a *= C, c *= C, d *= C), 1 !== L && (i *= L, o *= L, l *= L, h *= L), (m || D) && (m && (R += r * -m, O += s * -m, I += u * -m + m), D && (R += T.xOrigin - (T.xOrigin * i + T.yOrigin * n) + T.xOffset, O += T.yOrigin - (T.xOrigin * o + T.yOrigin * a) + T.yOffset), R < g && R > -g && (R = "0"), O < g && O > -g && (O = "0"), I < g && I > -g && (I = 0)), x = T.xPercent || T.yPercent ? "translate(" + T.xPercent + "%," + T.yPercent + "%) matrix3d(" : "matrix3d(", x += (i < g && i > -g ? "0" : i) + "," + (o < g && o > -g ? "0" : o) + "," + (l < g && l > -g ? "0" : l), x += "," + (h < g && h > -g ? "0" : h) + "," + (n < g && n > -g ? "0" : n) + "," + (a < g && a > -g ? "0" : a), M || A || 1 !== P ? (x += "," + (c < g && c > -g ? "0" : c) + "," + (d < g && d > -g ? "0" : d) + "," + (r < g && r > -g ? "0" : r), x += "," + (s < g && s > -g ? "0" : s) + "," + (u < g && u > -g ? "0" : u) + "," + (p < g && p > -g ? "0" : p) + ",") : x += ",0,0,0,0,1,0,", x += R + "," + O + "," + I + "," + (N ? 1 + -I / N : 1) + ")", S[Ct] = x
                                }
                            };
                        (u = It.prototype).x = u.y = u.z = u.skewX = u.skewY = u.rotation = u.rotationX = u.rotationY = u.zOrigin = u.xPercent = u.yPercent = u.xOffset = u.yOffset = 0, u.scaleX = u.scaleY = u.scaleZ = 1, Et("transform,scale,scaleX,scaleY,scaleZ,x,y,z,rotation,rotationX,rotationY,rotationZ,skewX,skewY,shortRotation,shortRotationX,shortRotationY,shortRotationZ,transformOrigin,svgOrigin,transformPerspective,directionalRotation,parseTransform,force3D,skewType,xPercent,yPercent,smoothOrigin", {
                            parser: function(t, e, i, n, o, a, l) {
                                if (n._lastParsedTransform === l) return o;
                                n._lastParsedTransform = l;
                                var c, u = l.scale && "function" == typeof l.scale ? l.scale : 0;
                                "function" == typeof l[i] && (c = l[i], l[i] = e), u && (l.scale = u(y, t));
                                var h, d, p, f, m, g, _, x, b, w = t._gsTransform,
                                    T = t.style,
                                    S = Lt.length,
                                    E = l,
                                    M = {},
                                    A = Vt(t, r, !0, E.parseTransform),
                                    L = E.transform && ("function" == typeof E.transform ? E.transform(y, v) : E.transform);
                                if (n._transform = A, L && "string" == typeof L && Ct)(d = G.style)[Ct] = L, d.display = "block", d.position = "absolute", j.body.appendChild(G), h = Vt(G, null, !1), A.svg && (g = A.xOrigin, _ = A.yOrigin, h.x -= A.xOffset, h.y -= A.yOffset, (E.transformOrigin || E.svgOrigin) && (L = {}, Ut(t, lt(E.transformOrigin), L, E.svgOrigin, E.smoothOrigin, !0), g = L.xOrigin, _ = L.yOrigin, h.x -= L.xOffset - A.xOffset, h.y -= L.yOffset - A.yOffset), (g || _) && (x = Gt(G, !0), h.x -= g - (g * x[0] + _ * x[2]), h.y -= _ - (g * x[1] + _ * x[3]))), j.body.removeChild(G), h.perspective || (h.perspective = A.perspective), null != E.xPercent && (h.xPercent = ut(E.xPercent, A.xPercent)), null != E.yPercent && (h.yPercent = ut(E.yPercent, A.yPercent));
                                else if ("object" == typeof E) {
                                    if (h = {
                                            scaleX: ut(null != E.scaleX ? E.scaleX : E.scale, A.scaleX),
                                            scaleY: ut(null != E.scaleY ? E.scaleY : E.scale, A.scaleY),
                                            scaleZ: ut(E.scaleZ, A.scaleZ),
                                            x: ut(E.x, A.x),
                                            y: ut(E.y, A.y),
                                            z: ut(E.z, A.z),
                                            xPercent: ut(E.xPercent, A.xPercent),
                                            yPercent: ut(E.yPercent, A.yPercent),
                                            perspective: ut(E.transformPerspective, A.perspective)
                                        }, null != (m = E.directionalRotation))
                                        if ("object" == typeof m)
                                            for (d in m) E[d] = m[d];
                                        else E.rotation = m;
                                    "string" == typeof E.x && -1 !== E.x.indexOf("%") && (h.x = 0, h.xPercent = ut(E.x, A.xPercent)), "string" == typeof E.y && -1 !== E.y.indexOf("%") && (h.y = 0, h.yPercent = ut(E.y, A.yPercent)), h.rotation = ht("rotation" in E ? E.rotation : "shortRotation" in E ? E.shortRotation + "_short" : "rotationZ" in E ? E.rotationZ : A.rotation, A.rotation, "rotation", M), Ot && (h.rotationX = ht("rotationX" in E ? E.rotationX : "shortRotationX" in E ? E.shortRotationX + "_short" : A.rotationX || 0, A.rotationX, "rotationX", M), h.rotationY = ht("rotationY" in E ? E.rotationY : "shortRotationY" in E ? E.shortRotationY + "_short" : A.rotationY || 0, A.rotationY, "rotationY", M)), h.skewX = ht(E.skewX, A.skewX), h.skewY = ht(E.skewY, A.skewY)
                                }
                                for (Ot && null != E.force3D && (A.force3D = E.force3D, f = !0), A.skewType = E.skewType || A.skewType || s.defaultSkewType, (p = A.force3D || A.z || A.rotationX || A.rotationY || h.z || h.rotationX || h.rotationY || h.perspective) || null == E.scale || (h.scaleZ = 1); --S > -1;)((L = h[b = Lt[S]] - A[b]) > 1e-6 || L < -1e-6 || null != E[b] || null != B[b]) && (f = !0, o = new xt(A, b, A[b], L, o), b in M && (o.e = M[b]), o.xs0 = 0, o.plugin = a, n._overwriteProps.push(o.n));
                                return L = E.transformOrigin, A.svg && (L || E.svgOrigin) && (g = A.xOffset, _ = A.yOffset, Ut(t, lt(L), h, E.svgOrigin, E.smoothOrigin), o = bt(A, "xOrigin", (w ? A : h).xOrigin, h.xOrigin, o, "transformOrigin"), o = bt(A, "yOrigin", (w ? A : h).yOrigin, h.yOrigin, o, "transformOrigin"), g === A.xOffset && _ === A.yOffset || (o = bt(A, "xOffset", w ? g : A.xOffset, A.xOffset, o, "transformOrigin"), o = bt(A, "yOffset", w ? _ : A.yOffset, A.yOffset, o, "transformOrigin")), L = "0px 0px"), (L || Ot && p && A.zOrigin) && (Ct ? (f = !0, b = Rt, L = (L || tt(t, b, r, !1, "50% 50%")) + "", (o = new xt(T, b, 0, 0, o, -1, "transformOrigin")).b = T[b], o.plugin = a, Ot ? (d = A.zOrigin, L = L.split(" "), A.zOrigin = (L.length > 2 && (0 === d || "0px" !== L[2]) ? parseFloat(L[2]) : d) || 0, o.xs0 = o.e = L[0] + " " + (L[1] || "50%") + " 0px", (o = new xt(A, "zOrigin", 0, 0, o, -1, o.n)).b = d, o.xs0 = o.e = A.zOrigin) : o.xs0 = o.e = L) : lt(L + "", A)), f && (n._transformType = A.svg && At || !p && 3 !== this._transformType ? 2 : 3), c && (l[i] = c), u && (l.scale = u), o
                            },
                            prefix: !0
                        }), Et("boxShadow", {
                            defaultValue: "0px 0px 0px 0px #999",
                            prefix: !0,
                            color: !0,
                            multi: !0,
                            keyword: "inset"
                        }), Et("borderRadius", {
                            defaultValue: "0px",
                            parser: function(t, e, i, o, a, s) {
                                e = this.format(e);
                                var l, c, u, h, d, p, f, m, g, v, y, _, x, b, w, T, S = ["borderTopLeftRadius", "borderTopRightRadius", "borderBottomRightRadius", "borderBottomLeftRadius"],
                                    E = t.style;
                                for (g = parseFloat(t.offsetWidth), v = parseFloat(t.offsetHeight), l = e.split(" "), c = 0; c < S.length; c++) this.p.indexOf("border") && (S[c] = $(S[c])), -1 !== (d = h = tt(t, S[c], r, !1, "0px")).indexOf(" ") && (d = (h = d.split(" "))[0], h = h[1]), p = u = l[c], f = parseFloat(d), _ = d.substr((f + "").length), (x = "=" === p.charAt(1)) ? (m = parseInt(p.charAt(0) + "1", 10), p = p.substr(2), m *= parseFloat(p), y = p.substr((m + "").length - (m < 0 ? 1 : 0)) || "") : (m = parseFloat(p), y = p.substr((m + "").length)), "" === y && (y = n[i] || _), y !== _ && (b = et(t, "borderLeft", f, _), w = et(t, "borderTop", f, _), "%" === y ? (d = b / g * 100 + "%", h = w / v * 100 + "%") : "em" === y ? (d = b / (T = et(t, "borderLeft", 1, "em")) + "em", h = w / T + "em") : (d = b + "px", h = w + "px"), x && (p = parseFloat(d) + m + y, u = parseFloat(h) + m + y)), a = wt(E, S[c], d + " " + h, p + " " + u, !1, "0px", a);
                                return a
                            },
                            prefix: !0,
                            formatter: vt("0px 0px 0px 0px", !1, !0)
                        }), Et("borderBottomLeftRadius,borderBottomRightRadius,borderTopLeftRadius,borderTopRightRadius", {
                            defaultValue: "0px",
                            parser: function(t, e, i, n, o, a) {
                                return wt(t.style, i, this.format(tt(t, i, r, !1, "0px 0px")), this.format(e), !1, "0px", o)
                            },
                            prefix: !0,
                            formatter: vt("0px 0px", !1, !0)
                        }), Et("backgroundPosition", {
                            defaultValue: "0 0",
                            parser: function(t, e, i, n, o, a) {
                                var s, l, c, u, h, d, p = "background-position",
                                    f = r || K(t, null),
                                    m = this.format((f ? g ? f.getPropertyValue(p + "-x") + " " + f.getPropertyValue(p + "-y") : f.getPropertyValue(p) : t.currentStyle.backgroundPositionX + " " + t.currentStyle.backgroundPositionY) || "0 0"),
                                    v = this.format(e);
                                if (-1 !== m.indexOf("%") != (-1 !== v.indexOf("%")) && v.split(",").length < 2 && (d = tt(t, "backgroundImage").replace(P, "")) && "none" !== d) {
                                    for (s = m.split(" "), l = v.split(" "), V.setAttribute("src", d), c = 2; --c > -1;)(u = -1 !== (m = s[c]).indexOf("%")) !== (-1 !== l[c].indexOf("%")) && (h = 0 === c ? t.offsetWidth - V.width : t.offsetHeight - V.height, s[c] = u ? parseFloat(m) / 100 * h + "px" : parseFloat(m) / h * 100 + "%");
                                    m = s.join(" ")
                                }
                                return this.parseComplex(t.style, m, v, o, a)
                            },
                            formatter: lt
                        }), Et("backgroundSize", {
                            defaultValue: "0 0",
                            formatter: function(t) {
                                return t += "", lt(-1 === t.indexOf(" ") ? t + " " + t : t)
                            }
                        }), Et("perspective", {
                            defaultValue: "0px",
                            prefix: !0
                        }), Et("perspectiveOrigin", {
                            defaultValue: "50% 50%",
                            prefix: !0
                        }), Et("transformStyle", {
                            prefix: !0
                        }), Et("backfaceVisibility", {
                            prefix: !0
                        }), Et("userSelect", {
                            prefix: !0
                        }), Et("margin", {
                            parser: yt("marginTop,marginRight,marginBottom,marginLeft")
                        }), Et("padding", {
                            parser: yt("paddingTop,paddingRight,paddingBottom,paddingLeft")
                        }), Et("clip", {
                            defaultValue: "rect(0px,0px,0px,0px)",
                            parser: function(t, e, i, n, o, a) {
                                var s, l, c;
                                return g < 9 ? (l = t.currentStyle, c = g < 8 ? " " : ",", s = "rect(" + l.clipTop + c + l.clipRight + c + l.clipBottom + c + l.clipLeft + ")", e = this.format(e).split(",").join(c)) : (s = this.format(tt(t, this.p, r, !1, this.dflt)), e = this.format(e)), this.parseComplex(t.style, s, e, o, a)
                            }
                        }), Et("textShadow", {
                            defaultValue: "0px 0px 0px #999",
                            color: !0,
                            multi: !0
                        }), Et("autoRound,strictUnits", {
                            parser: function(t, e, i, n, r) {
                                return r
                            }
                        }), Et("border", {
                            defaultValue: "0px solid #000",
                            parser: function(t, e, i, n, o, a) {
                                var s = tt(t, "borderTopWidth", r, !1, "0px"),
                                    l = this.format(e).split(" "),
                                    c = l[0].replace(T, "");
                                return "px" !== c && (s = parseFloat(s) / et(t, "borderTopWidth", 1, c) + c), this.parseComplex(t.style, this.format(s + " " + tt(t, "borderTopStyle", r, !1, "solid") + " " + tt(t, "borderTopColor", r, !1, "#000")), l.join(" "), o, a)
                            },
                            color: !0,
                            formatter: function(t) {
                                var e = t.split(" ");
                                return e[0] + " " + (e[1] || "solid") + " " + (t.match(gt) || ["#000"])[0]
                            }
                        }), Et("borderWidth", {
                            parser: yt("borderTopWidth,borderRightWidth,borderBottomWidth,borderLeftWidth")
                        }), Et("float,cssFloat,styleFloat", {
                            parser: function(t, e, i, n, r, o) {
                                var a = t.style,
                                    s = "cssFloat" in a ? "cssFloat" : "styleFloat";
                                return new xt(a, s, 0, 0, r, -1, i, !1, 0, a[s], e)
                            }
                        });
                        var qt = function(t) {
                            var e, i = this.t,
                                n = i.filter || tt(this.data, "filter") || "",
                                r = this.s + this.c * t | 0;
                            100 === r && (-1 === n.indexOf("atrix(") && -1 === n.indexOf("radient(") && -1 === n.indexOf("oader(") ? (i.removeAttribute("filter"), e = !tt(this.data, "filter")) : (i.filter = n.replace(M, ""), e = !0)), e || (this.xn1 && (i.filter = n = n || "alpha(opacity=" + r + ")"), -1 === n.indexOf("pacity") ? 0 === r && this.xn1 || (i.filter = n + " alpha(opacity=" + r + ")") : i.filter = n.replace(S, "opacity=" + r))
                        };
                        Et("opacity,alpha,autoAlpha", {
                            defaultValue: "1",
                            parser: function(t, e, i, n, o, a) {
                                var s = parseFloat(tt(t, "opacity", r, !1, "1")),
                                    l = t.style,
                                    c = "autoAlpha" === i;
                                return "string" == typeof e && "=" === e.charAt(1) && (e = ("-" === e.charAt(0) ? -1 : 1) * parseFloat(e.substr(2)) + s), c && 1 === s && "hidden" === tt(t, "visibility", r) && 0 !== e && (s = 0), q ? o = new xt(l, "opacity", s, e - s, o) : ((o = new xt(l, "opacity", 100 * s, 100 * (e - s), o)).xn1 = c ? 1 : 0, l.zoom = 1, o.type = 2, o.b = "alpha(opacity=" + o.s + ")", o.e = "alpha(opacity=" + (o.s + o.c) + ")", o.data = t, o.plugin = a, o.setRatio = qt), c && ((o = new xt(l, "visibility", 0, 0, o, -1, null, !1, 0, 0 !== s ? "inherit" : "hidden", 0 === e ? "hidden" : "inherit")).xs0 = "inherit", n._overwriteProps.push(o.n), n._overwriteProps.push(i)), o
                            }
                        });
                        var Yt = function(t, e) {
                                e && (t.removeProperty ? ("ms" !== e.substr(0, 2) && "webkit" !== e.substr(0, 6) || (e = "-" + e), t.removeProperty(e.replace(L, "-$1").toLowerCase())) : t.removeAttribute(e))
                            },
                            Qt = function(t) {
                                if (this.t._gsClassPT = this, 1 === t || 0 === t) {
                                    this.t.setAttribute("class", 0 === t ? this.b : this.e);
                                    for (var e = this.data, i = this.t.style; e;) e.v ? i[e.p] = e.v : Yt(i, e.p), e = e._next;
                                    1 === t && this.t._gsClassPT === this && (this.t._gsClassPT = null)
                                } else this.t.getAttribute("class") !== this.e && this.t.setAttribute("class", this.e)
                            };
                        Et("className", {
                            parser: function(t, e, n, o, a, s, l) {
                                var c, u, h, d, p, f = t.getAttribute("class") || "",
                                    m = t.style.cssText;
                                if (a = o._classNamePT = new xt(t, n, 0, 0, a, 2), a.setRatio = Qt, a.pr = -11, i = !0, a.b = f, u = nt(t, r), h = t._gsClassPT) {
                                    for (d = {}, p = h.data; p;) d[p.p] = 1, p = p._next;
                                    h.setRatio(1)
                                }
                                return t._gsClassPT = a, a.e = "=" !== e.charAt(1) ? e : f.replace(new RegExp("(?:\\s|^)" + e.substr(2) + "(?![\\w-])"), "") + ("+" === e.charAt(0) ? " " + e.substr(2) : ""), t.setAttribute("class", a.e), c = rt(t, u, nt(t), l, d), t.setAttribute("class", f), a.data = c.firstMPT, t.style.cssText = m, a = a.xfirst = o.parse(t, c.difs, a, s)
                            }
                        });
                        var Zt = function(t) {
                            if ((1 === t || 0 === t) && this.data._totalTime === this.data._totalDuration && "isFromStart" !== this.data.data) {
                                var e, i, n, r, o, a = this.t.style,
                                    s = c.transform.parse;
                                if ("all" === this.e) a.cssText = "", r = !0;
                                else
                                    for (n = (e = this.e.split(" ").join("").split(",")).length; --n > -1;) i = e[n], c[i] && (c[i].parse === s ? r = !0 : i = "transformOrigin" === i ? Rt : c[i].p), Yt(a, i);
                                r && (Yt(a, Ct), (o = this.t._gsTransform) && (o.svg && (this.t.removeAttribute("data-svg-origin"), this.t.removeAttribute("transform")), delete this.t._gsTransform))
                            }
                        };
                        for (Et("clearProps", {
                                parser: function(t, e, n, r, o) {
                                    return o = new xt(t, n, 0, 0, o, 2), o.setRatio = Zt, o.e = e, o.pr = -10, o.data = r._tween, i = !0, o
                                }
                            }), u = "bezier,throwProps,physicsProps,physics2D".split(","), Tt = u.length; Tt--;) Mt(u[Tt]);
                        (u = s.prototype)._firstPT = u._lastParsedTransform = u._transform = null, u._onInitTween = function(t, e, a, l) {
                            if (!t.nodeType) return !1;
                            this._target = v = t, this._tween = a, this._vars = e, y = l, h = e.autoRound, i = !1, n = e.suffixMap || s.suffixMap, r = K(t, ""), o = this._overwriteProps;
                            var u, f, g, _, x, b, w, T, S, M = t.style;
                            if (d && "" === M.zIndex && ("auto" !== (u = tt(t, "zIndex", r)) && "" !== u || this._addLazySet(M, "zIndex", 0)), "string" == typeof e && (_ = M.cssText, u = nt(t, r), M.cssText = _ + ";" + e, u = rt(t, u, nt(t)).difs, !q && E.test(e) && (u.opacity = parseFloat(RegExp.$1)), e = u, M.cssText = _), e.className ? this._firstPT = f = c.className.parse(t, e.className, "className", this, null, null, e) : this._firstPT = f = this.parse(t, e, null), this._transformType) {
                                for (S = 3 === this._transformType, Ct ? p && (d = !0, "" === M.zIndex && ("auto" !== (w = tt(t, "zIndex", r)) && "" !== w || this._addLazySet(M, "zIndex", 0)), m && this._addLazySet(M, "WebkitBackfaceVisibility", this._vars.WebkitBackfaceVisibility || (S ? "visible" : "hidden"))) : M.zoom = 1, g = f; g && g._next;) g = g._next;
                                T = new xt(t, "transform", 0, 0, null, 2), this._linkCSSP(T, null, g), T.setRatio = Ct ? Xt : Wt, T.data = this._transform || Vt(t, r, !0), T.tween = a, T.pr = -1, o.pop()
                            }
                            if (i) {
                                for (; f;) {
                                    for (b = f._next, g = _; g && g.pr > f.pr;) g = g._next;
                                    (f._prev = g ? g._prev : x) ? f._prev._next = f: _ = f, (f._next = g) ? g._prev = f : x = f, f = b
                                }
                                this._firstPT = _
                            }
                            return !0
                        }, u.parse = function(t, e, i, o) {
                            var a, s, l, u, d, p, f, m, g, _, x = t.style;
                            for (a in e) "function" == typeof(p = e[a]) && (p = p(y, v)), (s = c[a]) ? i = s.parse(t, p, a, this, i, o, e) : (d = tt(t, a, r) + "", g = "string" == typeof p, "color" === a || "fill" === a || "stroke" === a || -1 !== a.indexOf("Color") || g && A.test(p) ? (g || (p = ((p = ft(p)).length > 3 ? "rgba(" : "rgb(") + p.join(",") + ")"), i = wt(x, a, d, p, !0, "transparent", i, 0, o)) : g && F.test(p) ? i = wt(x, a, d, p, !0, null, i, 0, o) : (f = (l = parseFloat(d)) || 0 === l ? d.substr((l + "").length) : "", "" !== d && "auto" !== d || ("width" === a || "height" === a ? (l = st(t, a, r), f = "px") : "left" === a || "top" === a ? (l = it(t, a, r), f = "px") : (l = "opacity" !== a ? 0 : 1, f = "")), (_ = g && "=" === p.charAt(1)) ? (u = parseInt(p.charAt(0) + "1", 10), p = p.substr(2), u *= parseFloat(p), m = p.replace(T, "")) : (u = parseFloat(p), m = g ? p.replace(T, "") : ""), "" === m && (m = a in n ? n[a] : f), p = u || 0 === u ? (_ ? u + l : u) + m : e[a], f !== m && "" !== m && (u || 0 === u) && l && (l = et(t, a, l, f), "%" === m ? (l /= et(t, a, 100, "%") / 100, !0 !== e.strictUnits && (d = l + "%")) : "em" === m || "rem" === m || "vw" === m || "vh" === m ? l /= et(t, a, 1, m) : "px" !== m && (u = et(t, a, u, m), m = "px"), _ && (u || 0 === u) && (p = u + l + m)), _ && (u += l), !l && 0 !== l || !u && 0 !== u ? void 0 !== x[a] && (p || p + "" != "NaN" && null != p) ? (i = new xt(x, a, u || l || 0, 0, i, -1, a, !1, 0, d, p)).xs0 = "none" !== p || "display" !== a && -1 === a.indexOf("Style") ? p : d : Q("invalid " + a + " tween value: " + e[a]) : (i = new xt(x, a, l, u - l, i, 0, a, !1 !== h && ("px" === m || "zIndex" === a), 0, d, p)).xs0 = m)), o && i && !i.plugin && (i.plugin = o);
                            return i
                        }, u.setRatio = function(t) {
                            var e, i, n, r = this._firstPT;
                            if (1 !== t || this._tween._time !== this._tween._duration && 0 !== this._tween._time)
                                if (t || this._tween._time !== this._tween._duration && 0 !== this._tween._time || -1e-6 === this._tween._rawPrevTime)
                                    for (; r;) {
                                        if (e = r.c * t + r.s, r.r ? e = Math.round(e) : e < 1e-6 && e > -1e-6 && (e = 0), r.type)
                                            if (1 === r.type)
                                                if (2 === (n = r.l)) r.t[r.p] = r.xs0 + e + r.xs1 + r.xn1 + r.xs2;
                                                else if (3 === n) r.t[r.p] = r.xs0 + e + r.xs1 + r.xn1 + r.xs2 + r.xn2 + r.xs3;
                                        else if (4 === n) r.t[r.p] = r.xs0 + e + r.xs1 + r.xn1 + r.xs2 + r.xn2 + r.xs3 + r.xn3 + r.xs4;
                                        else if (5 === n) r.t[r.p] = r.xs0 + e + r.xs1 + r.xn1 + r.xs2 + r.xn2 + r.xs3 + r.xn3 + r.xs4 + r.xn4 + r.xs5;
                                        else {
                                            for (i = r.xs0 + e + r.xs1, n = 1; n < r.l; n++) i += r["xn" + n] + r["xs" + (n + 1)];
                                            r.t[r.p] = i
                                        } else -1 === r.type ? r.t[r.p] = r.xs0 : r.setRatio && r.setRatio(t);
                                        else r.t[r.p] = e + r.xs0;
                                        r = r._next
                                    } else
                                        for (; r;) 2 !== r.type ? r.t[r.p] = r.b : r.setRatio(t), r = r._next;
                                else
                                    for (; r;) {
                                        if (2 !== r.type)
                                            if (r.r && -1 !== r.type)
                                                if (e = Math.round(r.s + r.c), r.type) {
                                                    if (1 === r.type) {
                                                        for (n = r.l, i = r.xs0 + e + r.xs1, n = 1; n < r.l; n++) i += r["xn" + n] + r["xs" + (n + 1)];
                                                        r.t[r.p] = i
                                                    }
                                                } else r.t[r.p] = e + r.xs0;
                                        else r.t[r.p] = r.e;
                                        else r.setRatio(t);
                                        r = r._next
                                    }
                        }, u._enableTransforms = function(t) {
                            this._transform = this._transform || Vt(this._target, r, !0), this._transformType = this._transform.svg && At || !t && 3 !== this._transformType ? 2 : 3
                        };
                        var Jt = function(t) {
                            this.t[this.p] = this.e, this.data._linkCSSP(this, this._next, null, !0)
                        };
                        u._addLazySet = function(t, e, i) {
                            var n = this._firstPT = new xt(t, e, 0, 0, this._firstPT, 2);
                            n.e = i, n.setRatio = Jt, n.data = this
                        }, u._linkCSSP = function(t, e, i, n) {
                            return t && (e && (e._prev = t), t._next && (t._next._prev = t._prev), t._prev ? t._prev._next = t._next : this._firstPT === t && (this._firstPT = t._next, n = !0), i ? i._next = t : n || null !== this._firstPT || (this._firstPT = t), t._next = e, t._prev = i), t
                        }, u._mod = function(t) {
                            for (var e = this._firstPT; e;) "function" == typeof t[e.p] && t[e.p] === Math.round && (e.r = 1), e = e._next
                        }, u._kill = function(e) {
                            var i, n, r, o = e;
                            if (e.autoAlpha || e.alpha) {
                                o = {};
                                for (n in e) o[n] = e[n];
                                o.opacity = 1, o.autoAlpha && (o.visibility = 1)
                            }
                            for (e.className && (i = this._classNamePT) && ((r = i.xfirst) && r._prev ? this._linkCSSP(r._prev, i._next, r._prev._prev) : r === this._firstPT && (this._firstPT = i._next), i._next && this._linkCSSP(i._next, i._next._next, r._prev), this._classNamePT = null), i = this._firstPT; i;) i.plugin && i.plugin !== n && i.plugin._kill && (i.plugin._kill(e), n = i.plugin), i = i._next;
                            return t.prototype._kill.call(this, o)
                        };
                        var $t = function(t, e, i) {
                            var n, r, o, a;
                            if (t.slice)
                                for (r = t.length; --r > -1;) $t(t[r], e, i);
                            else
                                for (r = (n = t.childNodes).length; --r > -1;) a = (o = n[r]).type, o.style && (e.push(nt(o)), i && i.push(o)), 1 !== a && 9 !== a && 11 !== a || !o.childNodes.length || $t(o, e, i)
                        };
                        return s.cascadeTo = function(t, i, n) {
                            var r, o, a, s, l = e.to(t, i, n),
                                c = [l],
                                u = [],
                                h = [],
                                d = [],
                                p = e._internals.reservedProps;
                            for (t = l._targets || l.target, $t(t, u, d), l.render(i, !0, !0), $t(t, h), l.render(0, !0, !0), l._enabled(!0), r = d.length; --r > -1;)
                                if ((o = rt(d[r], u[r], h[r])).firstMPT) {
                                    o = o.difs;
                                    for (a in n) p[a] && (o[a] = n[a]);
                                    s = {};
                                    for (a in o) s[a] = u[r][a];
                                    c.push(e.fromTo(d[r], i, s, o))
                                } return c
                        }, t.activate([s]), s
                    }, !0),
                    function() {
                        var t = function(t) {
                                for (; t;) t.f || t.blob || (t.m = Math.round), t = t._next
                            },
                            e = a._gsDefine.plugin({
                                propName: "roundProps",
                                version: "1.6.0",
                                priority: -1,
                                API: 2,
                                init: function(t, e, i) {
                                    return this._tween = i, !0
                                }
                            }).prototype;
                        e._onInitAllProps = function() {
                            for (var e, i, n, r = this._tween, o = r.vars.roundProps.join ? r.vars.roundProps : r.vars.roundProps.split(","), a = o.length, s = {}, l = r._propLookup.roundProps; --a > -1;) s[o[a]] = Math.round;
                            for (a = o.length; --a > -1;)
                                for (e = o[a], i = r._firstPT; i;) n = i._next, i.pg ? i.t._mod(s) : i.n === e && (2 === i.f && i.t ? t(i.t._firstPT) : (this._add(i.t, e, i.s, i.c), n && (n._prev = i._prev), i._prev ? i._prev._next = n : r._firstPT === i && (r._firstPT = n), i._next = i._prev = null, r._propLookup[e] = l)), i = n;
                            return !1
                        }, e._add = function(t, e, i, n) {
                            this._addTween(t, e, i, i + n, e, Math.round), this._overwriteProps.push(e)
                        }
                    }(), a._gsDefine.plugin({
                        propName: "attr",
                        API: 2,
                        version: "0.6.0",
                        init: function(t, e, i, n) {
                            var r, o;
                            if ("function" != typeof t.setAttribute) return !1;
                            for (r in e) "function" == typeof(o = e[r]) && (o = o(n, t)), this._addTween(t, "setAttribute", t.getAttribute(r) + "", o + "", r, !1, r), this._overwriteProps.push(r);
                            return !0
                        }
                    }), a._gsDefine.plugin({
                        propName: "directionalRotation",
                        version: "0.3.0",
                        API: 2,
                        init: function(t, e, i, n) {
                            "object" != typeof e && (e = {
                                rotation: e
                            }), this.finals = {};
                            var r, o, a, s, l, c, u = !0 === e.useRadians ? 2 * Math.PI : 360;
                            for (r in e) "useRadians" !== r && ("function" == typeof(s = e[r]) && (s = s(n, t)), o = (c = (s + "").split("_"))[0], a = parseFloat("function" != typeof t[r] ? t[r] : t[r.indexOf("set") || "function" != typeof t["get" + r.substr(3)] ? r : "get" + r.substr(3)]()), l = (s = this.finals[r] = "string" == typeof o && "=" === o.charAt(1) ? a + parseInt(o.charAt(0) + "1", 10) * Number(o.substr(2)) : Number(o) || 0) - a, c.length && (-1 !== (o = c.join("_")).indexOf("short") && (l %= u) !== l % (u / 2) && (l = l < 0 ? l + u : l - u), -1 !== o.indexOf("_cw") && l < 0 ? l = (l + 9999999999 * u) % u - (l / u | 0) * u : -1 !== o.indexOf("ccw") && l > 0 && (l = (l - 9999999999 * u) % u - (l / u | 0) * u)), (l > 1e-6 || l < -1e-6) && (this._addTween(t, r, a, a + l, r), this._overwriteProps.push(r)));
                            return !0
                        },
                        set: function(t) {
                            var e;
                            if (1 !== t) this._super.setRatio.call(this, t);
                            else
                                for (e = this._firstPT; e;) e.f ? e.t[e.p](this.finals[e.p]) : e.t[e.p] = this.finals[e.p], e = e._next
                        }
                    })._autoCSS = !0, a._gsDefine("easing.Back", ["easing.Ease"], function(t) {
                        var e, i, n, r = a.GreenSockGlobals || a,
                            o = r.com.greensock,
                            s = 2 * Math.PI,
                            l = Math.PI / 2,
                            c = o._class,
                            u = function(e, i) {
                                var n = c("easing." + e, function() {}, !0),
                                    r = n.prototype = new t;
                                return r.constructor = n, r.getRatio = i, n
                            },
                            h = t.register || function() {},
                            d = function(t, e, i, n, r) {
                                var o = c("easing." + t, {
                                    easeOut: new e,
                                    easeIn: new i,
                                    easeInOut: new n
                                }, !0);
                                return h(o, t), o
                            },
                            p = function(t, e, i) {
                                this.t = t, this.v = e, i && (this.next = i, i.prev = this, this.c = i.v - e, this.gap = i.t - t)
                            },
                            f = function(e, i) {
                                var n = c("easing." + e, function(t) {
                                        this._p1 = t || 0 === t ? t : 1.70158, this._p2 = 1.525 * this._p1
                                    }, !0),
                                    r = n.prototype = new t;
                                return r.constructor = n, r.getRatio = i, r.config = function(t) {
                                    return new n(t)
                                }, n
                            },
                            m = d("Back", f("BackOut", function(t) {
                                return (t -= 1) * t * ((this._p1 + 1) * t + this._p1) + 1
                            }), f("BackIn", function(t) {
                                return t * t * ((this._p1 + 1) * t - this._p1)
                            }), f("BackInOut", function(t) {
                                return (t *= 2) < 1 ? .5 * t * t * ((this._p2 + 1) * t - this._p2) : .5 * ((t -= 2) * t * ((this._p2 + 1) * t + this._p2) + 2)
                            })),
                            g = c("easing.SlowMo", function(t, e, i) {
                                e = e || 0 === e ? e : .7, null == t ? t = .7 : t > 1 && (t = 1), this._p = 1 !== t ? e : 0, this._p1 = (1 - t) / 2, this._p2 = t, this._p3 = this._p1 + this._p2, this._calcEnd = !0 === i
                            }, !0),
                            v = g.prototype = new t;
                        return v.constructor = g, v.getRatio = function(t) {
                            var e = t + (.5 - t) * this._p;
                            return t < this._p1 ? this._calcEnd ? 1 - (t = 1 - t / this._p1) * t : e - (t = 1 - t / this._p1) * t * t * t * e : t > this._p3 ? this._calcEnd ? 1 - (t = (t - this._p3) / this._p1) * t : e + (t - e) * (t = (t - this._p3) / this._p1) * t * t * t : this._calcEnd ? 1 : e
                        }, g.ease = new g(.7, .7), v.config = g.config = function(t, e, i) {
                            return new g(t, e, i)
                        }, e = c("easing.SteppedEase", function(t) {
                            t = t || 1, this._p1 = 1 / t, this._p2 = t + 1
                        }, !0), v = e.prototype = new t, v.constructor = e, v.getRatio = function(t) {
                            return t < 0 ? t = 0 : t >= 1 && (t = .999999999), (this._p2 * t >> 0) * this._p1
                        }, v.config = e.config = function(t) {
                            return new e(t)
                        }, i = c("easing.RoughEase", function(e) {
                            for (var i, n, r, o, a, s, l = (e = e || {}).taper || "none", c = [], u = 0, h = 0 | (e.points || 20), d = h, f = !1 !== e.randomize, m = !0 === e.clamp, g = e.template instanceof t ? e.template : null, v = "number" == typeof e.strength ? .4 * e.strength : .4; --d > -1;) i = f ? Math.random() : 1 / h * d, n = g ? g.getRatio(i) : i, r = "none" === l ? v : "out" === l ? (o = 1 - i) * o * v : "in" === l ? i * i * v : i < .5 ? (o = 2 * i) * o * .5 * v : (o = 2 * (1 - i)) * o * .5 * v, f ? n += Math.random() * r - .5 * r : d % 2 ? n += .5 * r : n -= .5 * r, m && (n > 1 ? n = 1 : n < 0 && (n = 0)), c[u++] = {
                                x: i,
                                y: n
                            };
                            for (c.sort(function(t, e) {
                                    return t.x - e.x
                                }), s = new p(1, 1, null), d = h; --d > -1;) a = c[d], s = new p(a.x, a.y, s);
                            this._prev = new p(0, 0, 0 !== s.t ? s : s.next)
                        }, !0), v = i.prototype = new t, v.constructor = i, v.getRatio = function(t) {
                            var e = this._prev;
                            if (t > e.t) {
                                for (; e.next && t >= e.t;) e = e.next;
                                e = e.prev
                            } else
                                for (; e.prev && t <= e.t;) e = e.prev;
                            return this._prev = e, e.v + (t - e.t) / e.gap * e.c
                        }, v.config = function(t) {
                            return new i(t)
                        }, i.ease = new i, d("Bounce", u("BounceOut", function(t) {
                            return t < 1 / 2.75 ? 7.5625 * t * t : t < 2 / 2.75 ? 7.5625 * (t -= 1.5 / 2.75) * t + .75 : t < 2.5 / 2.75 ? 7.5625 * (t -= 2.25 / 2.75) * t + .9375 : 7.5625 * (t -= 2.625 / 2.75) * t + .984375
                        }), u("BounceIn", function(t) {
                            return (t = 1 - t) < 1 / 2.75 ? 1 - 7.5625 * t * t : t < 2 / 2.75 ? 1 - (7.5625 * (t -= 1.5 / 2.75) * t + .75) : t < 2.5 / 2.75 ? 1 - (7.5625 * (t -= 2.25 / 2.75) * t + .9375) : 1 - (7.5625 * (t -= 2.625 / 2.75) * t + .984375)
                        }), u("BounceInOut", function(t) {
                            var e = t < .5;
                            return t = e ? 1 - 2 * t : 2 * t - 1, t < 1 / 2.75 ? t *= 7.5625 * t : t = t < 2 / 2.75 ? 7.5625 * (t -= 1.5 / 2.75) * t + .75 : t < 2.5 / 2.75 ? 7.5625 * (t -= 2.25 / 2.75) * t + .9375 : 7.5625 * (t -= 2.625 / 2.75) * t + .984375, e ? .5 * (1 - t) : .5 * t + .5
                        })), d("Circ", u("CircOut", function(t) {
                            return Math.sqrt(1 - (t -= 1) * t)
                        }), u("CircIn", function(t) {
                            return -(Math.sqrt(1 - t * t) - 1)
                        }), u("CircInOut", function(t) {
                            return (t *= 2) < 1 ? -.5 * (Math.sqrt(1 - t * t) - 1) : .5 * (Math.sqrt(1 - (t -= 2) * t) + 1)
                        })), n = function(e, i, n) {
                            var r = c("easing." + e, function(t, e) {
                                    this._p1 = t >= 1 ? t : 1, this._p2 = (e || n) / (t < 1 ? t : 1), this._p3 = this._p2 / s * (Math.asin(1 / this._p1) || 0), this._p2 = s / this._p2
                                }, !0),
                                o = r.prototype = new t;
                            return o.constructor = r, o.getRatio = i, o.config = function(t, e) {
                                return new r(t, e)
                            }, r
                        }, d("Elastic", n("ElasticOut", function(t) {
                            return this._p1 * Math.pow(2, -10 * t) * Math.sin((t - this._p3) * this._p2) + 1
                        }, .3), n("ElasticIn", function(t) {
                            return -this._p1 * Math.pow(2, 10 * (t -= 1)) * Math.sin((t - this._p3) * this._p2)
                        }, .3), n("ElasticInOut", function(t) {
                            return (t *= 2) < 1 ? this._p1 * Math.pow(2, 10 * (t -= 1)) * Math.sin((t - this._p3) * this._p2) * -.5 : this._p1 * Math.pow(2, -10 * (t -= 1)) * Math.sin((t - this._p3) * this._p2) * .5 + 1
                        }, .45)), d("Expo", u("ExpoOut", function(t) {
                            return 1 - Math.pow(2, -10 * t)
                        }), u("ExpoIn", function(t) {
                            return Math.pow(2, 10 * (t - 1)) - .001
                        }), u("ExpoInOut", function(t) {
                            return (t *= 2) < 1 ? .5 * Math.pow(2, 10 * (t - 1)) : .5 * (2 - Math.pow(2, -10 * (t - 1)))
                        })), d("Sine", u("SineOut", function(t) {
                            return Math.sin(t * l)
                        }), u("SineIn", function(t) {
                            return 1 - Math.cos(t * l)
                        }), u("SineInOut", function(t) {
                            return -.5 * (Math.cos(Math.PI * t) - 1)
                        })), c("easing.EaseLookup", {
                            find: function(e) {
                                return t.map[e]
                            }
                        }, !0), h(r.SlowMo, "SlowMo", "ease,"), h(i, "RoughEase", "ease,"), h(e, "SteppedEase", "ease,"), m
                    }, !0)
            }), a._gsDefine && a._gsQueue.pop()(),
            function(o, a) {
                "use strict";
                var s = {},
                    l = o.document,
                    c = o.GreenSockGlobals = o.GreenSockGlobals || o;
                if (!c.TweenLite) {
                    var u, h, d, p, f, m = function(t) {
                            var e, i = t.split("."),
                                n = c;
                            for (e = 0; e < i.length; e++) n[i[e]] = n = n[i[e]] || {};
                            return n
                        },
                        g = m("com.greensock"),
                        v = function(t) {
                            var e, i = [],
                                n = t.length;
                            for (e = 0; e !== n; i.push(t[e++]));
                            return i
                        },
                        y = function() {},
                        _ = function() {
                            var t = Object.prototype.toString,
                                e = t.call([]);
                            return function(i) {
                                return null != i && (i instanceof Array || "object" == typeof i && !!i.push && t.call(i) === e)
                            }
                        }(),
                        x = {},
                        b = function(o, a, l, u) {
                            this.sc = x[o] ? x[o].sc : [], x[o] = this, this.gsClass = null, this.func = l;
                            var h = [];
                            this.check = function(d) {
                                for (var p, f, g, v, y, _ = a.length, w = _; --_ > -1;)(p = x[a[_]] || new b(a[_], [])).gsClass ? (h[_] = p.gsClass, w--) : d && p.sc.push(this);
                                if (0 === w && l) {
                                    if (f = ("com.greensock." + o).split("."), g = f.pop(), v = m(f.join("."))[g] = this.gsClass = l.apply(l, h), u)
                                        if (c[g] = s[g] = v, !(y = void 0 !== t && t.exports) && i(5)) n = [], void 0 !== (r = function() {
                                            return v
                                        }.apply(e, n)) && (t.exports = r);
                                        else if (y)
                                        if ("TweenMax" === o) {
                                            t.exports = s.TweenMax = v;
                                            for (_ in s) v[_] = s[_]
                                        } else s.TweenMax && (s.TweenMax[g] = v);
                                    for (_ = 0; _ < this.sc.length; _++) this.sc[_].check()
                                }
                            }, this.check(!0)
                        },
                        w = o._gsDefine = function(t, e, i, n) {
                            return new b(t, e, i, n)
                        },
                        T = g._class = function(t, e, i) {
                            return e = e || function() {}, w(t, [], function() {
                                return e
                            }, i), e
                        };
                    w.globals = c;
                    var S = [0, 0, 1, 1],
                        E = T("easing.Ease", function(t, e, i, n) {
                            this._func = t, this._type = i || 0, this._power = n || 0, this._params = e ? S.concat(e) : S
                        }, !0),
                        M = E.map = {},
                        A = E.register = function(t, e, i, n) {
                            for (var r, o, a, s, l = e.split(","), c = l.length, u = (i || "easeIn,easeOut,easeInOut").split(","); --c > -1;)
                                for (o = l[c], r = n ? T("easing." + o, null, !0) : g.easing[o] || {}, a = u.length; --a > -1;) s = u[a], M[o + "." + s] = M[s + o] = r[s] = t.getRatio ? t : t[s] || new t
                        };
                    for ((d = E.prototype)._calcEnd = !1, d.getRatio = function(t) {
                            if (this._func) return this._params[0] = t, this._func.apply(null, this._params);
                            var e = this._type,
                                i = this._power,
                                n = 1 === e ? 1 - t : 2 === e ? t : t < .5 ? 2 * t : 2 * (1 - t);
                            return 1 === i ? n *= n : 2 === i ? n *= n * n : 3 === i ? n *= n * n * n : 4 === i && (n *= n * n * n * n), 1 === e ? 1 - n : 2 === e ? n : t < .5 ? n / 2 : 1 - n / 2
                        }, h = (u = ["Linear", "Quad", "Cubic", "Quart", "Quint,Strong"]).length; --h > -1;) d = u[h] + ",Power" + h, A(new E(null, null, 1, h), d, "easeOut", !0), A(new E(null, null, 2, h), d, "easeIn" + (0 === h ? ",easeNone" : "")), A(new E(null, null, 3, h), d, "easeInOut");
                    M.linear = g.easing.Linear.easeIn, M.swing = g.easing.Quad.easeInOut;
                    var L = T("events.EventDispatcher", function(t) {
                        this._listeners = {}, this._eventTarget = t || this
                    });
                    (d = L.prototype).addEventListener = function(t, e, i, n, r) {
                        r = r || 0;
                        var o, a, s = this._listeners[t],
                            l = 0;
                        for (this !== p || f || p.wake(), null == s && (this._listeners[t] = s = []), a = s.length; --a > -1;)(o = s[a]).c === e && o.s === i ? s.splice(a, 1) : 0 === l && o.pr < r && (l = a + 1);
                        s.splice(l, 0, {
                            c: e,
                            s: i,
                            up: n,
                            pr: r
                        })
                    }, d.removeEventListener = function(t, e) {
                        var i, n = this._listeners[t];
                        if (n)
                            for (i = n.length; --i > -1;)
                                if (n[i].c === e) return void n.splice(i, 1)
                    }, d.dispatchEvent = function(t) {
                        var e, i, n, r = this._listeners[t];
                        if (r)
                            for ((e = r.length) > 1 && (r = r.slice(0)), i = this._eventTarget; --e > -1;)(n = r[e]) && (n.up ? n.c.call(n.s || i, {
                                type: t,
                                target: i
                            }) : n.c.call(n.s || i))
                    };
                    var C = o.requestAnimationFrame,
                        P = o.cancelAnimationFrame,
                        R = Date.now || function() {
                            return (new Date).getTime()
                        },
                        O = R();
                    for (h = (u = ["ms", "moz", "webkit", "o"]).length; --h > -1 && !C;) C = o[u[h] + "RequestAnimationFrame"], P = o[u[h] + "CancelAnimationFrame"] || o[u[h] + "CancelRequestAnimationFrame"];
                    T("Ticker", function(t, e) {
                        var i, n, r, o, a, s = this,
                            c = R(),
                            u = !(!1 === e || !C) && "auto",
                            h = 500,
                            d = 33,
                            m = function(t) {
                                var e, l, u = R() - O;
                                u > h && (c += u - d), O += u, s.time = (O - c) / 1e3, e = s.time - a, (!i || e > 0 || !0 === t) && (s.frame++, a += e + (e >= o ? .004 : o - e), l = !0), !0 !== t && (r = n(m)), l && s.dispatchEvent("tick")
                            };
                        L.call(s), s.time = s.frame = 0, s.tick = function() {
                            m(!0)
                        }, s.lagSmoothing = function(t, e) {
                            h = t || 1e10, d = Math.min(e, h, 0)
                        }, s.sleep = function() {
                            null != r && (u && P ? P(r) : clearTimeout(r), n = y, r = null, s === p && (f = !1))
                        }, s.wake = function(t) {
                            null !== r ? s.sleep() : t ? c += -O + (O = R()) : s.frame > 10 && (O = R() - h + 5), n = 0 === i ? y : u && C ? C : function(t) {
                                return setTimeout(t, 1e3 * (a - s.time) + 1 | 0)
                            }, s === p && (f = !0), m(2)
                        }, s.fps = function(t) {
                            if (!arguments.length) return i;
                            o = 1 / ((i = t) || 60), a = this.time + o, s.wake()
                        }, s.useRAF = function(t) {
                            if (!arguments.length) return u;
                            s.sleep(), u = t, s.fps(i)
                        }, s.fps(t), setTimeout(function() {
                            "auto" === u && s.frame < 5 && "hidden" !== l.visibilityState && s.useRAF(!1)
                        }, 1500)
                    }), (d = g.Ticker.prototype = new g.events.EventDispatcher).constructor = g.Ticker;
                    var I = T("core.Animation", function(t, e) {
                        if (this.vars = e = e || {}, this._duration = this._totalDuration = t || 0, this._delay = Number(e.delay) || 0, this._timeScale = 1, this._active = !0 === e.immediateRender, this.data = e.data, this._reversed = !0 === e.reversed, $) {
                            f || p.wake();
                            var i = this.vars.useFrames ? J : $;
                            i.add(this, i._time), this.vars.paused && this.paused(!0)
                        }
                    });
                    p = I.ticker = new g.Ticker, (d = I.prototype)._dirty = d._gc = d._initted = d._paused = !1, d._totalTime = d._time = 0, d._rawPrevTime = -1, d._next = d._last = d._onUpdate = d._timeline = d.timeline = null, d._paused = !1;
                    var D = function() {
                        f && R() - O > 2e3 && p.wake(), setTimeout(D, 2e3)
                    };
                    D(), d.play = function(t, e) {
                        return null != t && this.seek(t, e), this.reversed(!1).paused(!1)
                    }, d.pause = function(t, e) {
                        return null != t && this.seek(t, e), this.paused(!0)
                    }, d.resume = function(t, e) {
                        return null != t && this.seek(t, e), this.paused(!1)
                    }, d.seek = function(t, e) {
                        return this.totalTime(Number(t), !1 !== e)
                    }, d.restart = function(t, e) {
                        return this.reversed(!1).paused(!1).totalTime(t ? -this._delay : 0, !1 !== e, !0)
                    }, d.reverse = function(t, e) {
                        return null != t && this.seek(t || this.totalDuration(), e), this.reversed(!0).paused(!1)
                    }, d.render = function(t, e, i) {}, d.invalidate = function() {
                        return this._time = this._totalTime = 0, this._initted = this._gc = !1, this._rawPrevTime = -1, !this._gc && this.timeline || this._enabled(!0), this
                    }, d.isActive = function() {
                        var t, e = this._timeline,
                            i = this._startTime;
                        return !e || !this._gc && !this._paused && e.isActive() && (t = e.rawTime(!0)) >= i && t < i + this.totalDuration() / this._timeScale
                    }, d._enabled = function(t, e) {
                        return f || p.wake(), this._gc = !t, this._active = this.isActive(), !0 !== e && (t && !this.timeline ? this._timeline.add(this, this._startTime - this._delay) : !t && this.timeline && this._timeline._remove(this, !0)), !1
                    }, d._kill = function(t, e) {
                        return this._enabled(!1, !1)
                    }, d.kill = function(t, e) {
                        return this._kill(t, e), this
                    }, d._uncache = function(t) {
                        for (var e = t ? this : this.timeline; e;) e._dirty = !0, e = e.timeline;
                        return this
                    }, d._swapSelfInParams = function(t) {
                        for (var e = t.length, i = t.concat(); --e > -1;) "{self}" === t[e] && (i[e] = this);
                        return i
                    }, d._callback = function(t) {
                        var e = this.vars,
                            i = e[t],
                            n = e[t + "Params"],
                            r = e[t + "Scope"] || e.callbackScope || this;
                        switch (n ? n.length : 0) {
                            case 0:
                                i.call(r);
                                break;
                            case 1:
                                i.call(r, n[0]);
                                break;
                            case 2:
                                i.call(r, n[0], n[1]);
                                break;
                            default:
                                i.apply(r, n)
                        }
                    }, d.eventCallback = function(t, e, i, n) {
                        if ("on" === (t || "").substr(0, 2)) {
                            var r = this.vars;
                            if (1 === arguments.length) return r[t];
                            null == e ? delete r[t] : (r[t] = e, r[t + "Params"] = _(i) && -1 !== i.join("").indexOf("{self}") ? this._swapSelfInParams(i) : i, r[t + "Scope"] = n), "onUpdate" === t && (this._onUpdate = e)
                        }
                        return this
                    }, d.delay = function(t) {
                        return arguments.length ? (this._timeline.smoothChildTiming && this.startTime(this._startTime + t - this._delay), this._delay = t, this) : this._delay
                    }, d.duration = function(t) {
                        return arguments.length ? (this._duration = this._totalDuration = t, this._uncache(!0), this._timeline.smoothChildTiming && this._time > 0 && this._time < this._duration && 0 !== t && this.totalTime(this._totalTime * (t / this._duration), !0), this) : (this._dirty = !1, this._duration)
                    }, d.totalDuration = function(t) {
                        return this._dirty = !1, arguments.length ? this.duration(t) : this._totalDuration
                    }, d.time = function(t, e) {
                        return arguments.length ? (this._dirty && this.totalDuration(), this.totalTime(t > this._duration ? this._duration : t, e)) : this._time
                    }, d.totalTime = function(t, e, i) {
                        if (f || p.wake(), !arguments.length) return this._totalTime;
                        if (this._timeline) {
                            if (t < 0 && !i && (t += this.totalDuration()), this._timeline.smoothChildTiming) {
                                this._dirty && this.totalDuration();
                                var n = this._totalDuration,
                                    r = this._timeline;
                                if (t > n && !i && (t = n), this._startTime = (this._paused ? this._pauseTime : r._time) - (this._reversed ? n - t : t) / this._timeScale, r._dirty || this._uncache(!1), r._timeline)
                                    for (; r._timeline;) r._timeline._time !== (r._startTime + r._totalTime) / r._timeScale && r.totalTime(r._totalTime, !0), r = r._timeline
                            }
                            this._gc && this._enabled(!0, !1), this._totalTime === t && 0 !== this._duration || (B.length && tt(), this.render(t, e, !1), B.length && tt())
                        }
                        return this
                    }, d.progress = d.totalProgress = function(t, e) {
                        var i = this.duration();
                        return arguments.length ? this.totalTime(i * t, e) : i ? this._time / i : this.ratio
                    }, d.startTime = function(t) {
                        return arguments.length ? (t !== this._startTime && (this._startTime = t, this.timeline && this.timeline._sortChildren && this.timeline.add(this, t - this._delay)), this) : this._startTime
                    }, d.endTime = function(t) {
                        return this._startTime + (0 != t ? this.totalDuration() : this.duration()) / this._timeScale
                    }, d.timeScale = function(t) {
                        if (!arguments.length) return this._timeScale;
                        if (t = t || 1e-10, this._timeline && this._timeline.smoothChildTiming) {
                            var e = this._pauseTime,
                                i = e || 0 === e ? e : this._timeline.totalTime();
                            this._startTime = i - (i - this._startTime) * this._timeScale / t
                        }
                        return this._timeScale = t, this._uncache(!1)
                    }, d.reversed = function(t) {
                        return arguments.length ? (t != this._reversed && (this._reversed = t, this.totalTime(this._timeline && !this._timeline.smoothChildTiming ? this.totalDuration() - this._totalTime : this._totalTime, !0)), this) : this._reversed
                    }, d.paused = function(t) {
                        if (!arguments.length) return this._paused;
                        var e, i, n = this._timeline;
                        return t != this._paused && n && (f || t || p.wake(), i = (e = n.rawTime()) - this._pauseTime, !t && n.smoothChildTiming && (this._startTime += i, this._uncache(!1)), this._pauseTime = t ? e : null, this._paused = t, this._active = this.isActive(), !t && 0 !== i && this._initted && this.duration() && (e = n.smoothChildTiming ? this._totalTime : (e - this._startTime) / this._timeScale, this.render(e, e === this._totalTime, !0))), this._gc && !t && this._enabled(!0, !1), this
                    };
                    var N = T("core.SimpleTimeline", function(t) {
                        I.call(this, 0, t), this.autoRemoveChildren = this.smoothChildTiming = !0
                    });
                    (d = N.prototype = new I).constructor = N, d.kill()._gc = !1, d._first = d._last = d._recent = null, d._sortChildren = !1, d.add = d.insert = function(t, e, i, n) {
                        var r, o;
                        if (t._startTime = Number(e || 0) + t._delay, t._paused && this !== t._timeline && (t._pauseTime = t._startTime + (this.rawTime() - t._startTime) / t._timeScale), t.timeline && t.timeline._remove(t, !0), t.timeline = t._timeline = this, t._gc && t._enabled(!0, !0), r = this._last, this._sortChildren)
                            for (o = t._startTime; r && r._startTime > o;) r = r._prev;
                        return r ? (t._next = r._next, r._next = t) : (t._next = this._first, this._first = t), t._next ? t._next._prev = t : this._last = t, t._prev = r, this._recent = t, this._timeline && this._uncache(!0), this
                    }, d._remove = function(t, e) {
                        return t.timeline === this && (e || t._enabled(!1, !0), t._prev ? t._prev._next = t._next : this._first === t && (this._first = t._next), t._next ? t._next._prev = t._prev : this._last === t && (this._last = t._prev), t._next = t._prev = t.timeline = null, t === this._recent && (this._recent = this._last), this._timeline && this._uncache(!0)), this
                    }, d.render = function(t, e, i) {
                        var n, r = this._first;
                        for (this._totalTime = this._time = this._rawPrevTime = t; r;) n = r._next, (r._active || t >= r._startTime && !r._paused) && (r._reversed ? r.render((r._dirty ? r.totalDuration() : r._totalDuration) - (t - r._startTime) * r._timeScale, e, i) : r.render((t - r._startTime) * r._timeScale, e, i)), r = n
                    }, d.rawTime = function() {
                        return f || p.wake(), this._totalTime
                    };
                    var F = T("TweenLite", function(t, e, i) {
                            if (I.call(this, e, i), this.render = F.prototype.render, null == t) throw "Cannot tween a null target.";
                            this.target = t = "string" != typeof t ? t : F.selector(t) || t;
                            var n, r, a, s = t.jquery || t.length && t !== o && t[0] && (t[0] === o || t[0].nodeType && t[0].style && !t.nodeType),
                                l = this.vars.overwrite;
                            if (this._overwrite = l = null == l ? Z[F.defaultOverwrite] : "number" == typeof l ? l >> 0 : Z[l], (s || t instanceof Array || t.push && _(t)) && "number" != typeof t[0])
                                for (this._targets = a = v(t), this._propLookup = [], this._siblings = [], n = 0; n < a.length; n++)(r = a[n]) ? "string" != typeof r ? r.length && r !== o && r[0] && (r[0] === o || r[0].nodeType && r[0].style && !r.nodeType) ? (a.splice(n--, 1), this._targets = a = a.concat(v(r))) : (this._siblings[n] = et(r, this, !1), 1 === l && this._siblings[n].length > 1 && nt(r, this, null, 1, this._siblings[n])) : "string" == typeof(r = a[n--] = F.selector(r)) && a.splice(n + 1, 1) : a.splice(n--, 1);
                            else this._propLookup = {}, this._siblings = et(t, this, !1), 1 === l && this._siblings.length > 1 && nt(t, this, null, 1, this._siblings);
                            (this.vars.immediateRender || 0 === e && 0 === this._delay && !1 !== this.vars.immediateRender) && (this._time = -1e-10, this.render(Math.min(0, -this._delay)))
                        }, !0),
                        k = function(t) {
                            return t && t.length && t !== o && t[0] && (t[0] === o || t[0].nodeType && t[0].style && !t.nodeType)
                        },
                        U = function(t, e) {
                            var i, n = {};
                            for (i in t) Q[i] || i in e && "transform" !== i && "x" !== i && "y" !== i && "width" !== i && "height" !== i && "className" !== i && "border" !== i || !(!X[i] || X[i] && X[i]._autoCSS) || (n[i] = t[i], delete t[i]);
                            t.css = n
                        };
                    (d = F.prototype = new I).constructor = F, d.kill()._gc = !1, d.ratio = 0, d._firstPT = d._targets = d._overwrittenProps = d._startAt = null, d._notifyPluginsOfEnabled = d._lazy = !1, F.version = "1.19.1", F.defaultEase = d._ease = new E(null, null, 1, 1), F.defaultOverwrite = "auto", F.ticker = p, F.autoSleep = 120, F.lagSmoothing = function(t, e) {
                        p.lagSmoothing(t, e)
                    }, F.selector = o.$ || o.jQuery || function(t) {
                        var e = o.$ || o.jQuery;
                        return e ? (F.selector = e, e(t)) : void 0 === l ? t : l.querySelectorAll ? l.querySelectorAll(t) : l.getElementById("#" === t.charAt(0) ? t.substr(1) : t)
                    };
                    var B = [],
                        z = {},
                        j = /(?:(-|-=|\+=)?\d*\.?\d*(?:e[\-+]?\d+)?)[0-9]/gi,
                        H = function(t) {
                            for (var e, i = this._firstPT; i;) e = i.blob ? 1 === t ? this.end : t ? this.join("") : this.start : i.c * t + i.s, i.m ? e = i.m(e, this._target || i.t) : e < 1e-6 && e > -1e-6 && !i.blob && (e = 0), i.f ? i.fp ? i.t[i.p](i.fp, e) : i.t[i.p](e) : i.t[i.p] = e, i = i._next
                        },
                        G = function(t, e, i, n) {
                            var r, o, a, s, l, c, u, h = [],
                                d = 0,
                                p = "",
                                f = 0;
                            for (h.start = t, h.end = e, t = h[0] = t + "", e = h[1] = e + "", i && (i(h), t = h[0], e = h[1]), h.length = 0, r = t.match(j) || [], o = e.match(j) || [], n && (n._next = null, n.blob = 1, h._firstPT = h._applyPT = n), l = o.length, s = 0; s < l; s++) u = o[s], p += (c = e.substr(d, e.indexOf(u, d) - d)) || !s ? c : ",", d += c.length, f ? f = (f + 1) % 5 : "rgba(" === c.substr(-5) && (f = 1), u === r[s] || r.length <= s ? p += u : (p && (h.push(p), p = ""), a = parseFloat(r[s]), h.push(a), h._firstPT = {
                                _next: h._firstPT,
                                t: h,
                                p: h.length - 1,
                                s: a,
                                c: ("=" === u.charAt(1) ? parseInt(u.charAt(0) + "1", 10) * parseFloat(u.substr(2)) : parseFloat(u) - a) || 0,
                                f: 0,
                                m: f && f < 4 ? Math.round : 0
                            }), d += u.length;
                            return (p += e.substr(d)) && h.push(p), h.setRatio = H, h
                        },
                        V = function(t, e, i, n, r, o, a, s, l) {
                            "function" == typeof n && (n = n(l || 0, t));
                            var c = typeof t[e],
                                u = "function" !== c ? "" : e.indexOf("set") || "function" != typeof t["get" + e.substr(3)] ? e : "get" + e.substr(3),
                                h = "get" !== i ? i : u ? a ? t[u](a) : t[u]() : t[e],
                                d = "string" == typeof n && "=" === n.charAt(1),
                                p = {
                                    t: t,
                                    p: e,
                                    s: h,
                                    f: "function" === c,
                                    pg: 0,
                                    n: r || e,
                                    m: o ? "function" == typeof o ? o : Math.round : 0,
                                    pr: 0,
                                    c: d ? parseInt(n.charAt(0) + "1", 10) * parseFloat(n.substr(2)) : parseFloat(n) - h || 0
                                };
                            if (("number" != typeof h || "number" != typeof n && !d) && (a || isNaN(h) || !d && isNaN(n) || "boolean" == typeof h || "boolean" == typeof n ? (p.fp = a, p = {
                                    t: G(h, d ? p.s + p.c : n, s || F.defaultStringFilter, p),
                                    p: "setRatio",
                                    s: 0,
                                    c: 1,
                                    f: 2,
                                    pg: 0,
                                    n: r || e,
                                    pr: 0,
                                    m: 0
                                }) : (p.s = parseFloat(h), d || (p.c = parseFloat(n) - p.s || 0))), p.c) return (p._next = this._firstPT) && (p._next._prev = p), this._firstPT = p, p
                        },
                        W = F._internals = {
                            isArray: _,
                            isSelector: k,
                            lazyTweens: B,
                            blobDif: G
                        },
                        X = F._plugins = {},
                        q = W.tweenLookup = {},
                        Y = 0,
                        Q = W.reservedProps = {
                            ease: 1,
                            delay: 1,
                            overwrite: 1,
                            onComplete: 1,
                            onCompleteParams: 1,
                            onCompleteScope: 1,
                            useFrames: 1,
                            runBackwards: 1,
                            startAt: 1,
                            onUpdate: 1,
                            onUpdateParams: 1,
                            onUpdateScope: 1,
                            onStart: 1,
                            onStartParams: 1,
                            onStartScope: 1,
                            onReverseComplete: 1,
                            onReverseCompleteParams: 1,
                            onReverseCompleteScope: 1,
                            onRepeat: 1,
                            onRepeatParams: 1,
                            onRepeatScope: 1,
                            easeParams: 1,
                            yoyo: 1,
                            immediateRender: 1,
                            repeat: 1,
                            repeatDelay: 1,
                            data: 1,
                            paused: 1,
                            reversed: 1,
                            autoCSS: 1,
                            lazy: 1,
                            onOverwrite: 1,
                            callbackScope: 1,
                            stringFilter: 1,
                            id: 1
                        },
                        Z = {
                            none: 0,
                            all: 1,
                            auto: 2,
                            concurrent: 3,
                            allOnStart: 4,
                            preexisting: 5,
                            true: 1,
                            false: 0
                        },
                        J = I._rootFramesTimeline = new N,
                        $ = I._rootTimeline = new N,
                        K = 30,
                        tt = W.lazyRender = function() {
                            var t, e = B.length;
                            for (z = {}; --e > -1;)(t = B[e]) && !1 !== t._lazy && (t.render(t._lazy[0], t._lazy[1], !0), t._lazy = !1);
                            B.length = 0
                        };
                    $._startTime = p.time, J._startTime = p.frame, $._active = J._active = !0, setTimeout(tt, 1), I._updateRoot = F.render = function() {
                        var t, e, i;
                        if (B.length && tt(), $.render((p.time - $._startTime) * $._timeScale, !1, !1), J.render((p.frame - J._startTime) * J._timeScale, !1, !1), B.length && tt(), p.frame >= K) {
                            K = p.frame + (parseInt(F.autoSleep, 10) || 120);
                            for (i in q) {
                                for (t = (e = q[i].tweens).length; --t > -1;) e[t]._gc && e.splice(t, 1);
                                0 === e.length && delete q[i]
                            }
                            if ((!(i = $._first) || i._paused) && F.autoSleep && !J._first && 1 === p._listeners.tick.length) {
                                for (; i && i._paused;) i = i._next;
                                i || p.sleep()
                            }
                        }
                    }, p.addEventListener("tick", I._updateRoot);
                    var et = function(t, e, i) {
                            var n, r, o = t._gsTweenID;
                            if (q[o || (t._gsTweenID = o = "t" + Y++)] || (q[o] = {
                                    target: t,
                                    tweens: []
                                }), e && (n = q[o].tweens, n[r = n.length] = e, i))
                                for (; --r > -1;) n[r] === e && n.splice(r, 1);
                            return q[o].tweens
                        },
                        it = function(t, e, i, n) {
                            var r, o, a = t.vars.onOverwrite;
                            return a && (r = a(t, e, i, n)), (a = F.onOverwrite) && (o = a(t, e, i, n)), !1 !== r && !1 !== o
                        },
                        nt = function(t, e, i, n, r) {
                            var o, a, s, l;
                            if (1 === n || n >= 4) {
                                for (l = r.length, o = 0; o < l; o++)
                                    if ((s = r[o]) !== e) s._gc || s._kill(null, t, e) && (a = !0);
                                    else if (5 === n) break;
                                return a
                            }
                            var c, u = e._startTime + 1e-10,
                                h = [],
                                d = 0,
                                p = 0 === e._duration;
                            for (o = r.length; --o > -1;)(s = r[o]) === e || s._gc || s._paused || (s._timeline !== e._timeline ? (c = c || rt(e, 0, p), 0 === rt(s, c, p) && (h[d++] = s)) : s._startTime <= u && s._startTime + s.totalDuration() / s._timeScale > u && ((p || !s._initted) && u - s._startTime <= 2e-10 || (h[d++] = s)));
                            for (o = d; --o > -1;)
                                if (s = h[o], 2 === n && s._kill(i, t, e) && (a = !0), 2 !== n || !s._firstPT && s._initted) {
                                    if (2 !== n && !it(s, e)) continue;
                                    s._enabled(!1, !1) && (a = !0)
                                } return a
                        },
                        rt = function(t, e, i) {
                            for (var n = t._timeline, r = n._timeScale, o = t._startTime; n._timeline;) {
                                if (o += n._startTime, r *= n._timeScale, n._paused) return -100;
                                n = n._timeline
                            }
                            return o /= r, o > e ? o - e : i && o === e || !t._initted && o - e < 2e-10 ? 1e-10 : (o += t.totalDuration() / t._timeScale / r) > e + 1e-10 ? 0 : o - e - 1e-10
                        };
                    d._init = function() {
                        var t, e, i, n, r, o, a = this.vars,
                            s = this._overwrittenProps,
                            l = this._duration,
                            c = !!a.immediateRender,
                            u = a.ease;
                        if (a.startAt) {
                            this._startAt && (this._startAt.render(-1, !0), this._startAt.kill()), r = {};
                            for (n in a.startAt) r[n] = a.startAt[n];
                            if (r.overwrite = !1, r.immediateRender = !0, r.lazy = c && !1 !== a.lazy, r.startAt = r.delay = null, this._startAt = F.to(this.target, 0, r), c)
                                if (this._time > 0) this._startAt = null;
                                else if (0 !== l) return
                        } else if (a.runBackwards && 0 !== l)
                            if (this._startAt) this._startAt.render(-1, !0), this._startAt.kill(), this._startAt = null;
                            else {
                                0 !== this._time && (c = !1), i = {};
                                for (n in a) Q[n] && "autoCSS" !== n || (i[n] = a[n]);
                                if (i.overwrite = 0, i.data = "isFromStart", i.lazy = c && !1 !== a.lazy, i.immediateRender = c, this._startAt = F.to(this.target, 0, i), c) {
                                    if (0 === this._time) return
                                } else this._startAt._init(), this._startAt._enabled(!1), this.vars.immediateRender && (this._startAt = null)
                            } if (this._ease = u = u ? u instanceof E ? u : "function" == typeof u ? new E(u, a.easeParams) : M[u] || F.defaultEase : F.defaultEase, a.easeParams instanceof Array && u.config && (this._ease = u.config.apply(u, a.easeParams)), this._easeType = this._ease._type, this._easePower = this._ease._power, this._firstPT = null, this._targets)
                            for (o = this._targets.length, t = 0; t < o; t++) this._initProps(this._targets[t], this._propLookup[t] = {}, this._siblings[t], s ? s[t] : null, t) && (e = !0);
                        else e = this._initProps(this.target, this._propLookup, this._siblings, s, 0);
                        if (e && F._onPluginEvent("_onInitAllProps", this), s && (this._firstPT || "function" != typeof this.target && this._enabled(!1, !1)), a.runBackwards)
                            for (i = this._firstPT; i;) i.s += i.c, i.c = -i.c, i = i._next;
                        this._onUpdate = a.onUpdate, this._initted = !0
                    }, d._initProps = function(t, e, i, n, r) {
                        var a, s, l, c, u, h;
                        if (null == t) return !1;
                        z[t._gsTweenID] && tt(), this.vars.css || t.style && t !== o && t.nodeType && X.css && !1 !== this.vars.autoCSS && U(this.vars, t);
                        for (a in this.vars)
                            if (h = this.vars[a], Q[a]) h && (h instanceof Array || h.push && _(h)) && -1 !== h.join("").indexOf("{self}") && (this.vars[a] = h = this._swapSelfInParams(h, this));
                            else if (X[a] && (c = new X[a])._onInitTween(t, this.vars[a], this, r)) {
                            for (this._firstPT = u = {
                                    _next: this._firstPT,
                                    t: c,
                                    p: "setRatio",
                                    s: 0,
                                    c: 1,
                                    f: 1,
                                    n: a,
                                    pg: 1,
                                    pr: c._priority,
                                    m: 0
                                }, s = c._overwriteProps.length; --s > -1;) e[c._overwriteProps[s]] = this._firstPT;
                            (c._priority || c._onInitAllProps) && (l = !0), (c._onDisable || c._onEnable) && (this._notifyPluginsOfEnabled = !0), u._next && (u._next._prev = u)
                        } else e[a] = V.call(this, t, a, "get", h, a, 0, null, this.vars.stringFilter, r);
                        return n && this._kill(n, t) ? this._initProps(t, e, i, n, r) : this._overwrite > 1 && this._firstPT && i.length > 1 && nt(t, this, e, this._overwrite, i) ? (this._kill(e, t), this._initProps(t, e, i, n, r)) : (this._firstPT && (!1 !== this.vars.lazy && this._duration || this.vars.lazy && !this._duration) && (z[t._gsTweenID] = !0), l)
                    }, d.render = function(t, e, i) {
                        var n, r, o, a, s = this._time,
                            l = this._duration,
                            c = this._rawPrevTime;
                        if (t >= l - 1e-7 && t >= 0) this._totalTime = this._time = l, this.ratio = this._ease._calcEnd ? this._ease.getRatio(1) : 1, this._reversed || (n = !0, r = "onComplete", i = i || this._timeline.autoRemoveChildren), 0 === l && (this._initted || !this.vars.lazy || i) && (this._startTime === this._timeline._duration && (t = 0), (c < 0 || t <= 0 && t >= -1e-7 || 1e-10 === c && "isPause" !== this.data) && c !== t && (i = !0, c > 1e-10 && (r = "onReverseComplete")), this._rawPrevTime = a = !e || t || c === t ? t : 1e-10);
                        else if (t < 1e-7) this._totalTime = this._time = 0, this.ratio = this._ease._calcEnd ? this._ease.getRatio(0) : 0, (0 !== s || 0 === l && c > 0) && (r = "onReverseComplete", n = this._reversed), t < 0 && (this._active = !1, 0 === l && (this._initted || !this.vars.lazy || i) && (c >= 0 && (1e-10 !== c || "isPause" !== this.data) && (i = !0), this._rawPrevTime = a = !e || t || c === t ? t : 1e-10)), this._initted || (i = !0);
                        else if (this._totalTime = this._time = t, this._easeType) {
                            var u = t / l,
                                h = this._easeType,
                                d = this._easePower;
                            (1 === h || 3 === h && u >= .5) && (u = 1 - u), 3 === h && (u *= 2), 1 === d ? u *= u : 2 === d ? u *= u * u : 3 === d ? u *= u * u * u : 4 === d && (u *= u * u * u * u), this.ratio = 1 === h ? 1 - u : 2 === h ? u : t / l < .5 ? u / 2 : 1 - u / 2
                        } else this.ratio = this._ease.getRatio(t / l);
                        if (this._time !== s || i) {
                            if (!this._initted) {
                                if (this._init(), !this._initted || this._gc) return;
                                if (!i && this._firstPT && (!1 !== this.vars.lazy && this._duration || this.vars.lazy && !this._duration)) return this._time = this._totalTime = s, this._rawPrevTime = c, B.push(this), void(this._lazy = [t, e]);
                                this._time && !n ? this.ratio = this._ease.getRatio(this._time / l) : n && this._ease._calcEnd && (this.ratio = this._ease.getRatio(0 === this._time ? 0 : 1))
                            }
                            for (!1 !== this._lazy && (this._lazy = !1), this._active || !this._paused && this._time !== s && t >= 0 && (this._active = !0), 0 === s && (this._startAt && (t >= 0 ? this._startAt.render(t, e, i) : r || (r = "_dummyGS")), this.vars.onStart && (0 === this._time && 0 !== l || e || this._callback("onStart"))), o = this._firstPT; o;) o.f ? o.t[o.p](o.c * this.ratio + o.s) : o.t[o.p] = o.c * this.ratio + o.s, o = o._next;
                            this._onUpdate && (t < 0 && this._startAt && -1e-4 !== t && this._startAt.render(t, e, i), e || (this._time !== s || n || i) && this._callback("onUpdate")), r && (this._gc && !i || (t < 0 && this._startAt && !this._onUpdate && -1e-4 !== t && this._startAt.render(t, e, i), n && (this._timeline.autoRemoveChildren && this._enabled(!1, !1), this._active = !1), !e && this.vars[r] && this._callback(r), 0 === l && 1e-10 === this._rawPrevTime && 1e-10 !== a && (this._rawPrevTime = 0)))
                        }
                    }, d._kill = function(t, e, i) {
                        if ("all" === t && (t = null), null == t && (null == e || e === this.target)) return this._lazy = !1, this._enabled(!1, !1);
                        e = "string" != typeof e ? e || this._targets || this.target : F.selector(e) || e;
                        var n, r, o, a, s, l, c, u, h, d = i && this._time && i._startTime === this._startTime && this._timeline === i._timeline;
                        if ((_(e) || k(e)) && "number" != typeof e[0])
                            for (n = e.length; --n > -1;) this._kill(t, e[n], i) && (l = !0);
                        else {
                            if (this._targets) {
                                for (n = this._targets.length; --n > -1;)
                                    if (e === this._targets[n]) {
                                        s = this._propLookup[n] || {}, this._overwrittenProps = this._overwrittenProps || [], r = this._overwrittenProps[n] = t ? this._overwrittenProps[n] || {} : "all";
                                        break
                                    }
                            } else {
                                if (e !== this.target) return !1;
                                s = this._propLookup, r = this._overwrittenProps = t ? this._overwrittenProps || {} : "all"
                            }
                            if (s) {
                                if (c = t || s, u = t !== r && "all" !== r && t !== s && ("object" != typeof t || !t._tempKill), i && (F.onOverwrite || this.vars.onOverwrite)) {
                                    for (o in c) s[o] && (h || (h = []), h.push(o));
                                    if ((h || !t) && !it(this, i, e, h)) return !1
                                }
                                for (o in c)(a = s[o]) && (d && (a.f ? a.t[a.p](a.s) : a.t[a.p] = a.s, l = !0), a.pg && a.t._kill(c) && (l = !0), a.pg && 0 !== a.t._overwriteProps.length || (a._prev ? a._prev._next = a._next : a === this._firstPT && (this._firstPT = a._next), a._next && (a._next._prev = a._prev), a._next = a._prev = null), delete s[o]), u && (r[o] = 1);
                                !this._firstPT && this._initted && this._enabled(!1, !1)
                            }
                        }
                        return l
                    }, d.invalidate = function() {
                        return this._notifyPluginsOfEnabled && F._onPluginEvent("_onDisable", this), this._firstPT = this._overwrittenProps = this._startAt = this._onUpdate = null, this._notifyPluginsOfEnabled = this._active = this._lazy = !1, this._propLookup = this._targets ? {} : [], I.prototype.invalidate.call(this), this.vars.immediateRender && (this._time = -1e-10, this.render(Math.min(0, -this._delay))), this
                    }, d._enabled = function(t, e) {
                        if (f || p.wake(), t && this._gc) {
                            var i, n = this._targets;
                            if (n)
                                for (i = n.length; --i > -1;) this._siblings[i] = et(n[i], this, !0);
                            else this._siblings = et(this.target, this, !0)
                        }
                        return I.prototype._enabled.call(this, t, e), !(!this._notifyPluginsOfEnabled || !this._firstPT) && F._onPluginEvent(t ? "_onEnable" : "_onDisable", this)
                    }, F.to = function(t, e, i) {
                        return new F(t, e, i)
                    }, F.from = function(t, e, i) {
                        return i.runBackwards = !0, i.immediateRender = 0 != i.immediateRender, new F(t, e, i)
                    }, F.fromTo = function(t, e, i, n) {
                        return n.startAt = i, n.immediateRender = 0 != n.immediateRender && 0 != i.immediateRender, new F(t, e, n)
                    }, F.delayedCall = function(t, e, i, n, r) {
                        return new F(e, 0, {
                            delay: t,
                            onComplete: e,
                            onCompleteParams: i,
                            callbackScope: n,
                            onReverseComplete: e,
                            onReverseCompleteParams: i,
                            immediateRender: !1,
                            lazy: !1,
                            useFrames: r,
                            overwrite: 0
                        })
                    }, F.set = function(t, e) {
                        return new F(t, 0, e)
                    }, F.getTweensOf = function(t, e) {
                        if (null == t) return [];
                        t = "string" != typeof t ? t : F.selector(t) || t;
                        var i, n, r, o;
                        if ((_(t) || k(t)) && "number" != typeof t[0]) {
                            for (i = t.length, n = []; --i > -1;) n = n.concat(F.getTweensOf(t[i], e));
                            for (i = n.length; --i > -1;)
                                for (o = n[i], r = i; --r > -1;) o === n[r] && n.splice(i, 1)
                        } else
                            for (i = (n = et(t).concat()).length; --i > -1;)(n[i]._gc || e && !n[i].isActive()) && n.splice(i, 1);
                        return n
                    }, F.killTweensOf = F.killDelayedCallsTo = function(t, e, i) {
                        "object" == typeof e && (i = e, e = !1);
                        for (var n = F.getTweensOf(t, e), r = n.length; --r > -1;) n[r]._kill(i, t)
                    };
                    var ot = T("plugins.TweenPlugin", function(t, e) {
                        this._overwriteProps = (t || "").split(","), this._propName = this._overwriteProps[0], this._priority = e || 0, this._super = ot.prototype
                    }, !0);
                    if (d = ot.prototype, ot.version = "1.19.0", ot.API = 2, d._firstPT = null, d._addTween = V, d.setRatio = H, d._kill = function(t) {
                            var e, i = this._overwriteProps,
                                n = this._firstPT;
                            if (null != t[this._propName]) this._overwriteProps = [];
                            else
                                for (e = i.length; --e > -1;) null != t[i[e]] && i.splice(e, 1);
                            for (; n;) null != t[n.n] && (n._next && (n._next._prev = n._prev), n._prev ? (n._prev._next = n._next, n._prev = null) : this._firstPT === n && (this._firstPT = n._next)), n = n._next;
                            return !1
                        }, d._mod = d._roundProps = function(t) {
                            for (var e, i = this._firstPT; i;)(e = t[this._propName] || null != i.n && t[i.n.split(this._propName + "_").join("")]) && "function" == typeof e && (2 === i.f ? i.t._applyPT.m = e : i.m = e), i = i._next
                        }, F._onPluginEvent = function(t, e) {
                            var i, n, r, o, a, s = e._firstPT;
                            if ("_onInitAllProps" === t) {
                                for (; s;) {
                                    for (a = s._next, n = r; n && n.pr > s.pr;) n = n._next;
                                    (s._prev = n ? n._prev : o) ? s._prev._next = s: r = s, (s._next = n) ? n._prev = s : o = s, s = a
                                }
                                s = e._firstPT = r
                            }
                            for (; s;) s.pg && "function" == typeof s.t[t] && s.t[t]() && (i = !0), s = s._next;
                            return i
                        }, ot.activate = function(t) {
                            for (var e = t.length; --e > -1;) t[e].API === ot.API && (X[(new t[e])._propName] = t[e]);
                            return !0
                        }, w.plugin = function(t) {
                            if (!(t && t.propName && t.init && t.API)) throw "illegal plugin definition.";
                            var e, i = t.propName,
                                n = t.priority || 0,
                                r = t.overwriteProps,
                                o = {
                                    init: "_onInitTween",
                                    set: "setRatio",
                                    kill: "_kill",
                                    round: "_mod",
                                    mod: "_mod",
                                    initAll: "_onInitAllProps"
                                },
                                a = T("plugins." + i.charAt(0).toUpperCase() + i.substr(1) + "Plugin", function() {
                                    ot.call(this, i, n), this._overwriteProps = r || []
                                }, !0 === t.global),
                                s = a.prototype = new ot(i);
                            s.constructor = a, a.API = t.API;
                            for (e in o) "function" == typeof t[e] && (s[o[e]] = t[e]);
                            return a.version = t.version, ot.activate([a]), a
                        }, u = o._gsQueue) {
                        for (h = 0; h < u.length; h++) u[h]();
                        for (d in x) x[d].func || o.console.log("GSAP encountered missing dependency: " + d)
                    }
                    f = !1
                }
            }(void 0 !== t && t.exports && void 0 !== o ? o : this || window)
    }).call(e, function() {
        return this
    }())
}, function(t, e) {
    (function(e) {
        t.exports = e
    }).call(e, {})
}, function(t, e) {
    "use strict";
    var i = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t) {
        return typeof t
    } : function(t) {
        return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
    };
    ! function(t, e, n) {
        function r(t, e) {
            return (void 0 === t ? "undefined" : i(t)) === e
        }

        function o() {
            return "function" != typeof e.createElement ? e.createElement(arguments[0]) : T ? e.createElementNS.call(e, "http://www.w3.org/2000/svg", arguments[0]) : e.createElement.apply(e, arguments)
        }

        function a(t, e) {
            return !!~("" + t).indexOf(e)
        }

        function s(t) {
            return t.replace(/([a-z])-([a-z])/g, function(t, e, i) {
                return e + i.toUpperCase()
            }).replace(/^-/, "")
        }

        function l(t, e) {
            return function() {
                return t.apply(e, arguments)
            }
        }

        function c(t, e, i) {
            var n;
            for (var o in t)
                if (t[o] in e) return !1 === i ? t[o] : (n = e[t[o]], r(n, "function") ? l(n, i || e) : n);
            return !1
        }

        function u(t) {
            return t.replace(/([A-Z])/g, function(t, e) {
                return "-" + e.toLowerCase()
            }).replace(/^ms-/, "-ms-")
        }

        function h(e, i, n) {
            var r;
            if ("getComputedStyle" in t) {
                r = getComputedStyle.call(t, e, i);
                var o = t.console;
                null !== r ? n && (r = r.getPropertyValue(n)) : o && o[o.error ? "error" : "log"].call(o, "getComputedStyle returning null, its possible modernizr test results are inaccurate")
            } else r = !i && e.currentStyle && e.currentStyle[n];
            return r
        }

        function d() {
            var t = e.body;
            return t || (t = o(T ? "svg" : "body"), t.fake = !0), t
        }

        function p(t, i, n, r) {
            var a, s, l, c, u = "modernizr",
                h = o("div"),
                p = d();
            if (parseInt(n, 10))
                for (; n--;)(l = o("div")).id = r ? r[n] : u + (n + 1), h.appendChild(l);
            return a = o("style"), a.type = "text/css", a.id = "s" + u, (p.fake ? p : h).appendChild(a), p.appendChild(h), a.styleSheet ? a.styleSheet.cssText = t : a.appendChild(e.createTextNode(t)), h.id = u, p.fake && (p.style.background = "", p.style.overflow = "hidden", c = w.style.overflow, w.style.overflow = "hidden", w.appendChild(p)), s = i(h, t), p.fake ? (p.parentNode.removeChild(p), w.style.overflow = c, w.offsetHeight) : h.parentNode.removeChild(h), !!s
        }

        function f(e, i) {
            var r = e.length;
            if ("CSS" in t && "supports" in t.CSS) {
                for (; r--;)
                    if (t.CSS.supports(u(e[r]), i)) return !0;
                return !1
            }
            if ("CSSSupportsRule" in t) {
                for (var o = []; r--;) o.push("(" + u(e[r]) + ":" + i + ")");
                return o = o.join(" or "), p("@supports (" + o + ") { #modernizr { position: absolute; } }", function(t) {
                    return "absolute" == h(t, null, "position")
                })
            }
            return n
        }

        function m(t, e, i, l) {
            function c() {
                h && (delete L.style, delete L.modElem)
            }
            if (l = !r(l, "undefined") && l, !r(i, "undefined")) {
                var u = f(t, i);
                if (!r(u, "undefined")) return u
            }
            for (var h, d, p, m, g, v = ["modernizr", "tspan", "samp"]; !L.style && v.length;) h = !0, L.modElem = o(v.shift()), L.style = L.modElem.style;
            for (p = t.length, d = 0; p > d; d++)
                if (m = t[d], g = L.style[m], a(m, "-") && (m = s(m)), L.style[m] !== n) {
                    if (l || r(i, "undefined")) return c(), "pfx" != e || m;
                    try {
                        L.style[m] = i
                    } catch (t) {}
                    if (L.style[m] != g) return c(), "pfx" != e || m
                } return c(), !1
        }

        function g(t, e, i, n, o) {
            var a = t.charAt(0).toUpperCase() + t.slice(1),
                s = (t + " " + E.join(a + " ") + a).split(" ");
            return r(e, "string") || r(e, "undefined") ? m(s, e, n, o) : (s = (t + " " + M.join(a + " ") + a).split(" "), c(s, e, i))
        }

        function v(t, e, i) {
            return g(t, n, n, e, i)
        }
        var y = [],
            _ = [],
            x = {
                _version: "3.5.0",
                _config: {
                    classPrefix: "",
                    enableClasses: !0,
                    enableJSClass: !0,
                    usePrefixes: !0
                },
                _q: [],
                on: function(t, e) {
                    var i = this;
                    setTimeout(function() {
                        e(i[t])
                    }, 0)
                },
                addTest: function(t, e, i) {
                    _.push({
                        name: t,
                        fn: e,
                        options: i
                    })
                },
                addAsyncTest: function(t) {
                    _.push({
                        name: null,
                        fn: t
                    })
                }
            },
            b = function() {};
        b.prototype = x, (b = new b).addTest("passiveeventlisteners", function() {
            var e = !1;
            try {
                var i = Object.defineProperty({}, "passive", {
                    get: function() {
                        e = !0
                    }
                });
                t.addEventListener("test", null, i)
            } catch (t) {}
            return e
        });
        var w = e.documentElement,
            T = "svg" === w.nodeName.toLowerCase();
        b.addTest("webgl", function() {
            var e = o("canvas"),
                i = "probablySupportsContext" in e ? "probablySupportsContext" : "supportsContext";
            return i in e ? e[i]("webgl") || e[i]("experimental-webgl") : "WebGLRenderingContext" in t
        });
        var S = "Moz O ms Webkit",
            E = x._config.usePrefixes ? S.split(" ") : [];
        x._cssomPrefixes = E;
        var M = x._config.usePrefixes ? S.toLowerCase().split(" ") : [];
        x._domPrefixes = M;
        var A = {
            elem: o("modernizr")
        };
        b._q.push(function() {
            delete A.elem
        });
        var L = {
            style: A.elem.style
        };
        b._q.unshift(function() {
                delete L.style
            }), x.testAllProps = g, x.testAllProps = v, b.addTest("csstransitions", v("transition", "all", !0)),
            function() {
                var t, e, i, n, o, a;
                for (var s in _)
                    if (_.hasOwnProperty(s)) {
                        if (t = [], (e = _[s]).name && (t.push(e.name.toLowerCase()), e.options && e.options.aliases && e.options.aliases.length))
                            for (i = 0; i < e.options.aliases.length; i++) t.push(e.options.aliases[i].toLowerCase());
                        for (n = r(e.fn, "function") ? e.fn() : e.fn, o = 0; o < t.length; o++) 1 === (a = t[o].split(".")).length ? b[a[0]] = n : (!b[a[0]] || b[a[0]] instanceof Boolean || (b[a[0]] = new Boolean(b[a[0]])), b[a[0]][a[1]] = n), y.push((n ? "" : "no-") + a.join("-"))
                    }
            }(),
            function(t) {
                var e = w.className,
                    i = b._config.classPrefix || "";
                if (T && (e = e.baseVal), b._config.enableJSClass) {
                    var n = new RegExp("(^|\\s)" + i + "no-js(\\s|$)");
                    e = e.replace(n, "$1" + i + "js$2")
                }
                b._config.enableClasses && (e += " " + i + t.join(" " + i), T ? w.className.baseVal = e : w.className = e)
            }(y), delete x.addTest, delete x.addAsyncTest;
        for (var C = 0; C < b._q.length; C++) b._q[C]();
        t.Modernizr = b
    }(window, document)
}, function(t, e, i) {
    "use strict";

    function n(t, e) {
        if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
    }
    var r = function() {
            function t(t, e) {
                for (var i = 0; i < e.length; i++) {
                    var n = e[i];
                    n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(t, n.key, n)
                }
            }
            return function(e, i, n) {
                return i && t(e.prototype, i), n && t(e, n), e
            }
        }(),
        o = i(3),
        a = (i(4), function() {
            function t(e, i) {
                var r = this;
                n(this, t), this.controller = e, this.objectLoader = new o.ObjectLoader, this.renderer = null, this.controls = null, this.camera = null, this.scene = null, this.events = {}, this.width = 500, this.height = 500, this.cameraVR = null, this.isVR = null, this.animation = {
                    loop: null,
                    call: function() {
                        r.render(), r.animation.loop = requestAnimationFrame(r.animation.call)
                    },
                    timeLast: performance.now(),
                    timeDelta: 0
                }, this.objects = {}, this.campos = {}, this.targetpos = {}, this.renderer = new o.WebGLRenderer({
                    antialias: !0,
                    alpha: !0
                }), this.renderer.setClearColor(0, 0), this.renderer.setPixelRatio(window.devicePixelRatio), this.renderer.autoClear = !1, this.renderer.sortObjects = !1, this.renderer.gammaInput = !!i.project.gammaInput, this.renderer.gammaOutput = !!i.project.gammaOutput, this.renderer.shadowMap.enabled = !!i.project.shadows, this.setScene(this.objectLoader.parse(i.scene)), this.setCamera(this.objectLoader.parse(i.camera)), this.objects.particle = new o.Object3D, this.scene.add(this.objects.particle), this.objects.particle.rotation.set(6.3, 0, 0), this.objects.perspectiveCamera = this.scene.getObjectByName("PerspectiveCamera 1", !0), this.objects.cam = this.scene.getObjectByName("cam", !0), this.objects.main = this.scene.getObjectByName("main-obj", !0), this.objects.target = this.scene.getObjectByName("CenterPoint", !0), this.objects.stone1 = this.scene.getObjectByName("stone-1", !0), this.objects.stone2 = this.scene.getObjectByName("stone-2", !0), this.objects.stone3 = this.scene.getObjectByName("stone-3-lg", !0), this.objects.stone4 = this.scene.getObjectByName("stone-4-lg", !0), this.objects.dot1 = this.scene.getObjectByName("dot-1", !0), this.objects.dot2 = this.scene.getObjectByName("dot-2", !0), this.objects.dot3 = this.scene.getObjectByName("top-dot", !0), this.campos = {
                    x: this.objects.cam.position.x,
                    y: this.objects.cam.position.y,
                    z: this.objects.cam.position.z,
                    x1: -26.57,
                    y1: -86.56,
                    z1: 470.24
                }, this.targetpos = {
                    x: this.objects.target.position.x,
                    y: this.objects.target.position.y,
                    z: this.objects.target.position.z,
                    x1: 6,
                    y1: this.objects.target.position.y,
                    z1: .3,
                    x1plus: 200
                }, this.objects.target.startPositionX = this.objects.target.position.x, this.recalculatePosition(), this.setCamera(this.objects.perspectiveCamera), this.events = {
                    init: [],
                    start: [],
                    stop: [],
                    keydown: [],
                    keyup: [],
                    mousedown: [],
                    mouseup: [],
                    mousemove: [],
                    touchstart: [],
                    touchend: [],
                    touchmove: [],
                    update: []
                }
            }
            return r(t, [{
                key: "setScene",
                value: function(t) {
                    this.scene = t
                }
            }, {
                key: "setCamera",
                value: function(t) {
                    this.camera = t, this.camera.aspect = this.width / this.height, this.camera.updateProjectionMatrix()
                }
            }, {
                key: "setSize",
                value: function(t, e) {
                    this.width = t, this.height = e, this.camera && (this.camera.aspect = this.width / this.height, this.camera.updateProjectionMatrix()), this.renderer && this.renderer.setSize(t, e), window.matchMedia("(orientation: portrait)").matches && (window.innerWidth <= 1024 && (this.campos.z1 = 700), window.innerWidth <= 580 && (this.targetpos.x1plus = 100))
                }
            }, {
                key: "recalculatePosition",
                value: function() {
                    this.setSize(this.width, this.height)
                }
            }, {
                key: "appendTo",
                value: function(t) {
                    t.appendChild(this.renderer.domElement)
                }
            }, {
                key: "dispatch",
                value: function(t) {
                    var e = this;
                    this.events[t] && this.events[t].forEach(function(t) {
                        return t(e)
                    })
                }
            }, {
                key: "render",
                value: function(t) {
                    this.animation.timeDelta = this.animation.time - this.animation.timeLast;
                    try {
                        this.dispatch("update")
                    } catch (t) {
                        console.error(t)
                    }
                    this.renderer.clear(), this.renderer.render(this.scene, this.camera), this.animation.timeLast = this.animation.time
                }
            }, {
                key: "start",
                value: function() {
                    this.dispatch("start"), this.animation.time = performance.now(), this.animation.timeLast = this.animation.time, this.animation.timeDelta = 0, this.animation.loop = requestAnimationFrame(this.animation.call)
                }
            }, {
                key: "stop",
                value: function() {
                    this.dispatch("stop"), cancelAnimationFrame(this.animation.loop)
                }
            }, {
                key: "dispose",
                value: function() {
                    this.renderer.dispose()
                }
            }]), t
        }());
    t.exports = a
}, function(t, e, i) {
    var n, r;
    ! function(e, i) {
        "use strict";
        "object" == typeof t && "object" == typeof t.exports ? t.exports = e.document ? i(e, !0) : function(t) {
            if (!t.document) throw new Error("jQuery requires a window with a document");
            return i(t)
        } : i(e)
    }("undefined" != typeof window ? window : this, function(i, o) {
        "use strict";

        function a(t, e) {
            var i = (e = e || ot).createElement("script");
            i.text = t, e.head.appendChild(i).parentNode.removeChild(i)
        }

        function s(t) {
            var e = !!t && "length" in t && t.length,
                i = vt.type(t);
            return "function" !== i && !vt.isWindow(t) && ("array" === i || 0 === e || "number" == typeof e && e > 0 && e - 1 in t)
        }

        function l(t, e) {
            return t.nodeName && t.nodeName.toLowerCase() === e.toLowerCase()
        }

        function c(t, e, i) {
            return vt.isFunction(e) ? vt.grep(t, function(t, n) {
                return !!e.call(t, n, t) !== i
            }) : e.nodeType ? vt.grep(t, function(t) {
                return t === e !== i
            }) : "string" != typeof e ? vt.grep(t, function(t) {
                return ut.call(e, t) > -1 !== i
            }) : At.test(e) ? vt.filter(e, t, i) : (e = vt.filter(e, t), vt.grep(t, function(t) {
                return ut.call(e, t) > -1 !== i && 1 === t.nodeType
            }))
        }

        function u(t, e) {
            for (;
                (t = t[e]) && 1 !== t.nodeType;);
            return t
        }

        function h(t) {
            var e = {};
            return vt.each(t.match(Ot) || [], function(t, i) {
                e[i] = !0
            }), e
        }

        function d(t) {
            return t
        }

        function p(t) {
            throw t
        }

        function f(t, e, i, n) {
            var r;
            try {
                t && vt.isFunction(r = t.promise) ? r.call(t).done(e).fail(i) : t && vt.isFunction(r = t.then) ? r.call(t, e, i) : e.apply(void 0, [t].slice(n))
            } catch (t) {
                i.apply(void 0, [t])
            }
        }

        function m() {
            ot.removeEventListener("DOMContentLoaded", m), i.removeEventListener("load", m), vt.ready()
        }

        function g() {
            this.expando = vt.expando + g.uid++
        }

        function v(t) {
            return "true" === t || "false" !== t && ("null" === t ? null : t === +t + "" ? +t : Bt.test(t) ? JSON.parse(t) : t)
        }

        function y(t, e, i) {
            var n;
            if (void 0 === i && 1 === t.nodeType)
                if (n = "data-" + e.replace(zt, "-$&").toLowerCase(), "string" == typeof(i = t.getAttribute(n))) {
                    try {
                        i = v(i)
                    } catch (t) {}
                    Ut.set(t, e, i)
                } else i = void 0;
            return i
        }

        function _(t, e, i, n) {
            var r, o = 1,
                a = 20,
                s = n ? function() {
                    return n.cur()
                } : function() {
                    return vt.css(t, e, "")
                },
                l = s(),
                c = i && i[3] || (vt.cssNumber[e] ? "" : "px"),
                u = (vt.cssNumber[e] || "px" !== c && +l) && Ht.exec(vt.css(t, e));
            if (u && u[3] !== c) {
                c = c || u[3], i = i || [], u = +l || 1;
                do {
                    u /= o = o || ".5", vt.style(t, e, u + c)
                } while (o !== (o = s() / l) && 1 !== o && --a)
            }
            return i && (u = +u || +l || 0, r = i[1] ? u + (i[1] + 1) * i[2] : +i[2], n && (n.unit = c, n.start = u, n.end = r)), r
        }

        function x(t) {
            var e, i = t.ownerDocument,
                n = t.nodeName,
                r = Xt[n];
            return r || (e = i.body.appendChild(i.createElement(n)), r = vt.css(e, "display"), e.parentNode.removeChild(e), "none" === r && (r = "block"), Xt[n] = r, r)
        }

        function b(t, e) {
            for (var i, n, r = [], o = 0, a = t.length; o < a; o++)(n = t[o]).style && (i = n.style.display, e ? ("none" === i && (r[o] = kt.get(n, "display") || null, r[o] || (n.style.display = "")), "" === n.style.display && Vt(n) && (r[o] = x(n))) : "none" !== i && (r[o] = "none", kt.set(n, "display", i)));
            for (o = 0; o < a; o++) null != r[o] && (t[o].style.display = r[o]);
            return t
        }

        function w(t, e) {
            var i;
            return i = void 0 !== t.getElementsByTagName ? t.getElementsByTagName(e || "*") : void 0 !== t.querySelectorAll ? t.querySelectorAll(e || "*") : [], void 0 === e || e && l(t, e) ? vt.merge([t], i) : i
        }

        function T(t, e) {
            for (var i = 0, n = t.length; i < n; i++) kt.set(t[i], "globalEval", !e || kt.get(e[i], "globalEval"))
        }

        function S(t, e, i, n, r) {
            for (var o, a, s, l, c, u, h = e.createDocumentFragment(), d = [], p = 0, f = t.length; p < f; p++)
                if ((o = t[p]) || 0 === o)
                    if ("object" === vt.type(o)) vt.merge(d, o.nodeType ? [o] : o);
                    else if (Jt.test(o)) {
                for (a = a || h.appendChild(e.createElement("div")), s = (Yt.exec(o) || ["", ""])[1].toLowerCase(), l = Zt[s] || Zt._default, a.innerHTML = l[1] + vt.htmlPrefilter(o) + l[2], u = l[0]; u--;) a = a.lastChild;
                vt.merge(d, a.childNodes), (a = h.firstChild).textContent = ""
            } else d.push(e.createTextNode(o));
            for (h.textContent = "", p = 0; o = d[p++];)
                if (n && vt.inArray(o, n) > -1) r && r.push(o);
                else if (c = vt.contains(o.ownerDocument, o), a = w(h.appendChild(o), "script"), c && T(a), i)
                for (u = 0; o = a[u++];) Qt.test(o.type || "") && i.push(o);
            return h
        }

        function E() {
            return !0
        }

        function M() {
            return !1
        }

        function A() {
            try {
                return ot.activeElement
            } catch (t) {}
        }

        function L(t, e, i, n, r, o) {
            var a, s;
            if ("object" == typeof e) {
                "string" != typeof i && (n = n || i, i = void 0);
                for (s in e) L(t, s, i, n, e[s], o);
                return t
            }
            if (null == n && null == r ? (r = i, n = i = void 0) : null == r && ("string" == typeof i ? (r = n, n = void 0) : (r = n, n = i, i = void 0)), !1 === r) r = M;
            else if (!r) return t;
            return 1 === o && (a = r, (r = function(t) {
                return vt().off(t), a.apply(this, arguments)
            }).guid = a.guid || (a.guid = vt.guid++)), t.each(function() {
                vt.event.add(this, e, r, n, i)
            })
        }

        function C(t, e) {
            return l(t, "table") && l(11 !== e.nodeType ? e : e.firstChild, "tr") ? vt(">tbody", t)[0] || t : t
        }

        function P(t) {
            return t.type = (null !== t.getAttribute("type")) + "/" + t.type, t
        }

        function R(t) {
            var e = oe.exec(t.type);
            return e ? t.type = e[1] : t.removeAttribute("type"), t
        }

        function O(t, e) {
            var i, n, r, o, a, s, l, c;
            if (1 === e.nodeType) {
                if (kt.hasData(t) && (o = kt.access(t), a = kt.set(e, o), c = o.events)) {
                    delete a.handle, a.events = {};
                    for (r in c)
                        for (i = 0, n = c[r].length; i < n; i++) vt.event.add(e, r, c[r][i])
                }
                Ut.hasData(t) && (s = Ut.access(t), l = vt.extend({}, s), Ut.set(e, l))
            }
        }

        function I(t, e) {
            var i = e.nodeName.toLowerCase();
            "input" === i && qt.test(t.type) ? e.checked = t.checked : "input" !== i && "textarea" !== i || (e.defaultValue = t.defaultValue)
        }

        function D(t, e, i, n) {
            e = lt.apply([], e);
            var r, o, s, l, c, u, h = 0,
                d = t.length,
                p = d - 1,
                f = e[0],
                m = vt.isFunction(f);
            if (m || d > 1 && "string" == typeof f && !gt.checkClone && re.test(f)) return t.each(function(r) {
                var o = t.eq(r);
                m && (e[0] = f.call(this, r, o.html())), D(o, e, i, n)
            });
            if (d && (r = S(e, t[0].ownerDocument, !1, t, n), o = r.firstChild, 1 === r.childNodes.length && (r = o), o || n)) {
                for (l = (s = vt.map(w(r, "script"), P)).length; h < d; h++) c = r, h !== p && (c = vt.clone(c, !0, !0), l && vt.merge(s, w(c, "script"))), i.call(t[h], c, h);
                if (l)
                    for (u = s[s.length - 1].ownerDocument, vt.map(s, R), h = 0; h < l; h++) c = s[h], Qt.test(c.type || "") && !kt.access(c, "globalEval") && vt.contains(u, c) && (c.src ? vt._evalUrl && vt._evalUrl(c.src) : a(c.textContent.replace(ae, ""), u))
            }
            return t
        }

        function N(t, e, i) {
            for (var n, r = e ? vt.filter(e, t) : t, o = 0; null != (n = r[o]); o++) i || 1 !== n.nodeType || vt.cleanData(w(n)), n.parentNode && (i && vt.contains(n.ownerDocument, n) && T(w(n, "script")), n.parentNode.removeChild(n));
            return t
        }

        function F(t, e, i) {
            var n, r, o, a, s = t.style;
            return (i = i || ce(t)) && ("" !== (a = i.getPropertyValue(e) || i[e]) || vt.contains(t.ownerDocument, t) || (a = vt.style(t, e)), !gt.pixelMarginRight() && le.test(a) && se.test(e) && (n = s.width, r = s.minWidth, o = s.maxWidth, s.minWidth = s.maxWidth = s.width = a, a = i.width, s.width = n, s.minWidth = r, s.maxWidth = o)), void 0 !== a ? a + "" : a
        }

        function k(t, e) {
            return {
                get: function() {
                    if (!t()) return (this.get = e).apply(this, arguments);
                    delete this.get
                }
            }
        }

        function U(t) {
            if (t in me) return t;
            for (var e = t[0].toUpperCase() + t.slice(1), i = fe.length; i--;)
                if ((t = fe[i] + e) in me) return t
        }

        function B(t) {
            var e = vt.cssProps[t];
            return e || (e = vt.cssProps[t] = U(t) || t), e
        }

        function z(t, e, i) {
            var n = Ht.exec(e);
            return n ? Math.max(0, n[2] - (i || 0)) + (n[3] || "px") : e
        }

        function j(t, e, i, n, r) {
            var o, a = 0;
            for (o = i === (n ? "border" : "content") ? 4 : "width" === e ? 1 : 0; o < 4; o += 2) "margin" === i && (a += vt.css(t, i + Gt[o], !0, r)), n ? ("content" === i && (a -= vt.css(t, "padding" + Gt[o], !0, r)), "margin" !== i && (a -= vt.css(t, "border" + Gt[o] + "Width", !0, r))) : (a += vt.css(t, "padding" + Gt[o], !0, r), "padding" !== i && (a += vt.css(t, "border" + Gt[o] + "Width", !0, r)));
            return a
        }

        function H(t, e, i) {
            var n, r = ce(t),
                o = F(t, e, r),
                a = "border-box" === vt.css(t, "boxSizing", !1, r);
            return le.test(o) ? o : (n = a && (gt.boxSizingReliable() || o === t.style[e]), "auto" === o && (o = t["offset" + e[0].toUpperCase() + e.slice(1)]), (o = parseFloat(o) || 0) + j(t, e, i || (a ? "border" : "content"), n, r) + "px")
        }

        function G(t, e, i, n, r) {
            return new G.prototype.init(t, e, i, n, r)
        }

        function V() {
            ve && (!1 === ot.hidden && i.requestAnimationFrame ? i.requestAnimationFrame(V) : i.setTimeout(V, vt.fx.interval), vt.fx.tick())
        }

        function W() {
            return i.setTimeout(function() {
                ge = void 0
            }), ge = vt.now()
        }

        function X(t, e) {
            var i, n = 0,
                r = {
                    height: t
                };
            for (e = e ? 1 : 0; n < 4; n += 2 - e) r["margin" + (i = Gt[n])] = r["padding" + i] = t;
            return e && (r.opacity = r.width = t), r
        }

        function q(t, e, i) {
            for (var n, r = (Q.tweeners[e] || []).concat(Q.tweeners["*"]), o = 0, a = r.length; o < a; o++)
                if (n = r[o].call(i, e, t)) return n
        }

        function Y(t, e) {
            var i, n, r, o, a;
            for (i in t)
                if (n = vt.camelCase(i), r = e[n], o = t[i], Array.isArray(o) && (r = o[1], o = t[i] = o[0]), i !== n && (t[n] = o, delete t[i]), (a = vt.cssHooks[n]) && "expand" in a) {
                    o = a.expand(o), delete t[n];
                    for (i in o) i in t || (t[i] = o[i], e[i] = r)
                } else e[n] = r
        }

        function Q(t, e, i) {
            var n, r, o = 0,
                a = Q.prefilters.length,
                s = vt.Deferred().always(function() {
                    delete l.elem
                }),
                l = function() {
                    if (r) return !1;
                    for (var e = ge || W(), i = Math.max(0, c.startTime + c.duration - e), n = 1 - (i / c.duration || 0), o = 0, a = c.tweens.length; o < a; o++) c.tweens[o].run(n);
                    return s.notifyWith(t, [c, n, i]), n < 1 && a ? i : (a || s.notifyWith(t, [c, 1, 0]), s.resolveWith(t, [c]), !1)
                },
                c = s.promise({
                    elem: t,
                    props: vt.extend({}, e),
                    opts: vt.extend(!0, {
                        specialEasing: {},
                        easing: vt.easing._default
                    }, i),
                    originalProperties: e,
                    originalOptions: i,
                    startTime: ge || W(),
                    duration: i.duration,
                    tweens: [],
                    createTween: function(e, i) {
                        var n = vt.Tween(t, c.opts, e, i, c.opts.specialEasing[e] || c.opts.easing);
                        return c.tweens.push(n), n
                    },
                    stop: function(e) {
                        var i = 0,
                            n = e ? c.tweens.length : 0;
                        if (r) return this;
                        for (r = !0; i < n; i++) c.tweens[i].run(1);
                        return e ? (s.notifyWith(t, [c, 1, 0]), s.resolveWith(t, [c, e])) : s.rejectWith(t, [c, e]), this
                    }
                }),
                u = c.props;
            for (Y(u, c.opts.specialEasing); o < a; o++)
                if (n = Q.prefilters[o].call(c, t, u, c.opts)) return vt.isFunction(n.stop) && (vt._queueHooks(c.elem, c.opts.queue).stop = vt.proxy(n.stop, n)), n;
            return vt.map(u, q, c), vt.isFunction(c.opts.start) && c.opts.start.call(t, c), c.progress(c.opts.progress).done(c.opts.done, c.opts.complete).fail(c.opts.fail).always(c.opts.always), vt.fx.timer(vt.extend(l, {
                elem: t,
                anim: c,
                queue: c.opts.queue
            })), c
        }

        function Z(t) {
            return (t.match(Ot) || []).join(" ")
        }

        function J(t) {
            return t.getAttribute && t.getAttribute("class") || ""
        }

        function $(t, e, i, n) {
            var r;
            if (Array.isArray(e)) vt.each(e, function(e, r) {
                i || Ce.test(t) ? n(t, r) : $(t + "[" + ("object" == typeof r && null != r ? e : "") + "]", r, i, n)
            });
            else if (i || "object" !== vt.type(e)) n(t, e);
            else
                for (r in e) $(t + "[" + r + "]", e[r], i, n)
        }

        function K(t) {
            return function(e, i) {
                "string" != typeof e && (i = e, e = "*");
                var n, r = 0,
                    o = e.toLowerCase().match(Ot) || [];
                if (vt.isFunction(i))
                    for (; n = o[r++];) "+" === n[0] ? (n = n.slice(1) || "*", (t[n] = t[n] || []).unshift(i)) : (t[n] = t[n] || []).push(i)
            }
        }

        function tt(t, e, i, n) {
            function r(s) {
                var l;
                return o[s] = !0, vt.each(t[s] || [], function(t, s) {
                    var c = s(e, i, n);
                    return "string" != typeof c || a || o[c] ? a ? !(l = c) : void 0 : (e.dataTypes.unshift(c), r(c), !1)
                }), l
            }
            var o = {},
                a = t === je;
            return r(e.dataTypes[0]) || !o["*"] && r("*")
        }

        function et(t, e) {
            var i, n, r = vt.ajaxSettings.flatOptions || {};
            for (i in e) void 0 !== e[i] && ((r[i] ? t : n || (n = {}))[i] = e[i]);
            return n && vt.extend(!0, t, n), t
        }

        function it(t, e, i) {
            for (var n, r, o, a, s = t.contents, l = t.dataTypes;
                "*" === l[0];) l.shift(), void 0 === n && (n = t.mimeType || e.getResponseHeader("Content-Type"));
            if (n)
                for (r in s)
                    if (s[r] && s[r].test(n)) {
                        l.unshift(r);
                        break
                    } if (l[0] in i) o = l[0];
            else {
                for (r in i) {
                    if (!l[0] || t.converters[r + " " + l[0]]) {
                        o = r;
                        break
                    }
                    a || (a = r)
                }
                o = o || a
            }
            if (o) return o !== l[0] && l.unshift(o), i[o]
        }

        function nt(t, e, i, n) {
            var r, o, a, s, l, c = {},
                u = t.dataTypes.slice();
            if (u[1])
                for (a in t.converters) c[a.toLowerCase()] = t.converters[a];
            for (o = u.shift(); o;)
                if (t.responseFields[o] && (i[t.responseFields[o]] = e), !l && n && t.dataFilter && (e = t.dataFilter(e, t.dataType)), l = o, o = u.shift())
                    if ("*" === o) o = l;
                    else if ("*" !== l && l !== o) {
                if (!(a = c[l + " " + o] || c["* " + o]))
                    for (r in c)
                        if ((s = r.split(" "))[1] === o && (a = c[l + " " + s[0]] || c["* " + s[0]])) {
                            !0 === a ? a = c[r] : !0 !== c[r] && (o = s[0], u.unshift(s[1]));
                            break
                        } if (!0 !== a)
                    if (a && t.throws) e = a(e);
                    else try {
                        e = a(e)
                    } catch (t) {
                        return {
                            state: "parsererror",
                            error: a ? t : "No conversion from " + l + " to " + o
                        }
                    }
            }
            return {
                state: "success",
                data: e
            }
        }
        var rt = [],
            ot = i.document,
            at = Object.getPrototypeOf,
            st = rt.slice,
            lt = rt.concat,
            ct = rt.push,
            ut = rt.indexOf,
            ht = {},
            dt = ht.toString,
            pt = ht.hasOwnProperty,
            ft = pt.toString,
            mt = ft.call(Object),
            gt = {},
            vt = function(t, e) {
                return new vt.fn.init(t, e)
            },
            yt = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,
            _t = /^-ms-/,
            xt = /-([a-z])/g,
            bt = function(t, e) {
                return e.toUpperCase()
            };
        vt.fn = vt.prototype = {
            jquery: "3.2.1",
            constructor: vt,
            length: 0,
            toArray: function() {
                return st.call(this)
            },
            get: function(t) {
                return null == t ? st.call(this) : t < 0 ? this[t + this.length] : this[t]
            },
            pushStack: function(t) {
                var e = vt.merge(this.constructor(), t);
                return e.prevObject = this, e
            },
            each: function(t) {
                return vt.each(this, t)
            },
            map: function(t) {
                return this.pushStack(vt.map(this, function(e, i) {
                    return t.call(e, i, e)
                }))
            },
            slice: function() {
                return this.pushStack(st.apply(this, arguments))
            },
            first: function() {
                return this.eq(0)
            },
            last: function() {
                return this.eq(-1)
            },
            eq: function(t) {
                var e = this.length,
                    i = +t + (t < 0 ? e : 0);
                return this.pushStack(i >= 0 && i < e ? [this[i]] : [])
            },
            end: function() {
                return this.prevObject || this.constructor()
            },
            push: ct,
            sort: rt.sort,
            splice: rt.splice
        }, vt.extend = vt.fn.extend = function() {
            var t, e, i, n, r, o, a = arguments[0] || {},
                s = 1,
                l = arguments.length,
                c = !1;
            for ("boolean" == typeof a && (c = a, a = arguments[s] || {}, s++), "object" == typeof a || vt.isFunction(a) || (a = {}), s === l && (a = this, s--); s < l; s++)
                if (null != (t = arguments[s]))
                    for (e in t) i = a[e], a !== (n = t[e]) && (c && n && (vt.isPlainObject(n) || (r = Array.isArray(n))) ? (r ? (r = !1, o = i && Array.isArray(i) ? i : []) : o = i && vt.isPlainObject(i) ? i : {}, a[e] = vt.extend(c, o, n)) : void 0 !== n && (a[e] = n));
            return a
        }, vt.extend({
            expando: "jQuery" + ("3.2.1" + Math.random()).replace(/\D/g, ""),
            isReady: !0,
            error: function(t) {
                throw new Error(t)
            },
            noop: function() {},
            isFunction: function(t) {
                return "function" === vt.type(t)
            },
            isWindow: function(t) {
                return null != t && t === t.window
            },
            isNumeric: function(t) {
                var e = vt.type(t);
                return ("number" === e || "string" === e) && !isNaN(t - parseFloat(t))
            },
            isPlainObject: function(t) {
                var e, i;
                return !(!t || "[object Object]" !== dt.call(t)) && (!(e = at(t)) || "function" == typeof(i = pt.call(e, "constructor") && e.constructor) && ft.call(i) === mt)
            },
            isEmptyObject: function(t) {
                var e;
                for (e in t) return !1;
                return !0
            },
            type: function(t) {
                return null == t ? t + "" : "object" == typeof t || "function" == typeof t ? ht[dt.call(t)] || "object" : typeof t
            },
            globalEval: function(t) {
                a(t)
            },
            camelCase: function(t) {
                return t.replace(_t, "ms-").replace(xt, bt)
            },
            each: function(t, e) {
                var i, n = 0;
                if (s(t))
                    for (i = t.length; n < i && !1 !== e.call(t[n], n, t[n]); n++);
                else
                    for (n in t)
                        if (!1 === e.call(t[n], n, t[n])) break;
                return t
            },
            trim: function(t) {
                return null == t ? "" : (t + "").replace(yt, "")
            },
            makeArray: function(t, e) {
                var i = e || [];
                return null != t && (s(Object(t)) ? vt.merge(i, "string" == typeof t ? [t] : t) : ct.call(i, t)), i
            },
            inArray: function(t, e, i) {
                return null == e ? -1 : ut.call(e, t, i)
            },
            merge: function(t, e) {
                for (var i = +e.length, n = 0, r = t.length; n < i; n++) t[r++] = e[n];
                return t.length = r, t
            },
            grep: function(t, e, i) {
                for (var n = [], r = 0, o = t.length, a = !i; r < o; r++) !e(t[r], r) !== a && n.push(t[r]);
                return n
            },
            map: function(t, e, i) {
                var n, r, o = 0,
                    a = [];
                if (s(t))
                    for (n = t.length; o < n; o++) null != (r = e(t[o], o, i)) && a.push(r);
                else
                    for (o in t) null != (r = e(t[o], o, i)) && a.push(r);
                return lt.apply([], a)
            },
            guid: 1,
            proxy: function(t, e) {
                var i, n, r;
                if ("string" == typeof e && (i = t[e], e = t, t = i), vt.isFunction(t)) return n = st.call(arguments, 2), r = function() {
                    return t.apply(e || this, n.concat(st.call(arguments)))
                }, r.guid = t.guid = t.guid || vt.guid++, r
            },
            now: Date.now,
            support: gt
        }), "function" == typeof Symbol && (vt.fn[Symbol.iterator] = rt[Symbol.iterator]), vt.each("Boolean Number String Function Array Date RegExp Object Error Symbol".split(" "), function(t, e) {
            ht["[object " + e + "]"] = e.toLowerCase()
        });
        var wt = function(t) {
            function e(t, e, i, n) {
                var r, o, a, s, l, u, d, p = e && e.ownerDocument,
                    f = e ? e.nodeType : 9;
                if (i = i || [], "string" != typeof t || !t || 1 !== f && 9 !== f && 11 !== f) return i;
                if (!n && ((e ? e.ownerDocument || e : B) !== R && P(e), e = e || R, I)) {
                    if (11 !== f && (l = mt.exec(t)))
                        if (r = l[1]) {
                            if (9 === f) {
                                if (!(a = e.getElementById(r))) return i;
                                if (a.id === r) return i.push(a), i
                            } else if (p && (a = p.getElementById(r)) && k(e, a) && a.id === r) return i.push(a), i
                        } else {
                            if (l[2]) return Z.apply(i, e.getElementsByTagName(t)), i;
                            if ((r = l[3]) && x.getElementsByClassName && e.getElementsByClassName) return Z.apply(i, e.getElementsByClassName(r)), i
                        } if (x.qsa && !V[t + " "] && (!D || !D.test(t))) {
                        if (1 !== f) p = e, d = t;
                        else if ("object" !== e.nodeName.toLowerCase()) {
                            for ((s = e.getAttribute("id")) ? s = s.replace(_t, xt) : e.setAttribute("id", s = U), o = (u = S(t)).length; o--;) u[o] = "#" + s + " " + h(u[o]);
                            d = u.join(","), p = gt.test(t) && c(e.parentNode) || e
                        }
                        if (d) try {
                            return Z.apply(i, p.querySelectorAll(d)), i
                        } catch (t) {} finally {
                            s === U && e.removeAttribute("id")
                        }
                    }
                }
                return M(t.replace(ot, "$1"), e, i, n)
            }

            function i() {
                function t(i, n) {
                    return e.push(i + " ") > b.cacheLength && delete t[e.shift()], t[i + " "] = n
                }
                var e = [];
                return t
            }

            function n(t) {
                return t[U] = !0, t
            }

            function r(t) {
                var e = R.createElement("fieldset");
                try {
                    return !!t(e)
                } catch (t) {
                    return !1
                } finally {
                    e.parentNode && e.parentNode.removeChild(e), e = null
                }
            }

            function o(t, e) {
                for (var i = t.split("|"), n = i.length; n--;) b.attrHandle[i[n]] = e
            }

            function a(t, e) {
                var i = e && t,
                    n = i && 1 === t.nodeType && 1 === e.nodeType && t.sourceIndex - e.sourceIndex;
                if (n) return n;
                if (i)
                    for (; i = i.nextSibling;)
                        if (i === e) return -1;
                return t ? 1 : -1
            }

            function s(t) {
                return function(e) {
                    return "form" in e ? e.parentNode && !1 === e.disabled ? "label" in e ? "label" in e.parentNode ? e.parentNode.disabled === t : e.disabled === t : e.isDisabled === t || e.isDisabled !== !t && wt(e) === t : e.disabled === t : "label" in e && e.disabled === t
                }
            }

            function l(t) {
                return n(function(e) {
                    return e = +e, n(function(i, n) {
                        for (var r, o = t([], i.length, e), a = o.length; a--;) i[r = o[a]] && (i[r] = !(n[r] = i[r]))
                    })
                })
            }

            function c(t) {
                return t && void 0 !== t.getElementsByTagName && t
            }

            function u() {}

            function h(t) {
                for (var e = 0, i = t.length, n = ""; e < i; e++) n += t[e].value;
                return n
            }

            function d(t, e, i) {
                var n = e.dir,
                    r = e.next,
                    o = r || n,
                    a = i && "parentNode" === o,
                    s = j++;
                return e.first ? function(e, i, r) {
                    for (; e = e[n];)
                        if (1 === e.nodeType || a) return t(e, i, r);
                    return !1
                } : function(e, i, l) {
                    var c, u, h, d = [z, s];
                    if (l) {
                        for (; e = e[n];)
                            if ((1 === e.nodeType || a) && t(e, i, l)) return !0
                    } else
                        for (; e = e[n];)
                            if (1 === e.nodeType || a)
                                if (h = e[U] || (e[U] = {}), u = h[e.uniqueID] || (h[e.uniqueID] = {}), r && r === e.nodeName.toLowerCase()) e = e[n] || e;
                                else {
                                    if ((c = u[o]) && c[0] === z && c[1] === s) return d[2] = c[2];
                                    if (u[o] = d, d[2] = t(e, i, l)) return !0
                                } return !1
                }
            }

            function p(t) {
                return t.length > 1 ? function(e, i, n) {
                    for (var r = t.length; r--;)
                        if (!t[r](e, i, n)) return !1;
                    return !0
                } : t[0]
            }

            function f(t, i, n) {
                for (var r = 0, o = i.length; r < o; r++) e(t, i[r], n);
                return n
            }

            function m(t, e, i, n, r) {
                for (var o, a = [], s = 0, l = t.length, c = null != e; s < l; s++)(o = t[s]) && (i && !i(o, n, r) || (a.push(o), c && e.push(s)));
                return a
            }

            function g(t, e, i, r, o, a) {
                return r && !r[U] && (r = g(r)), o && !o[U] && (o = g(o, a)), n(function(n, a, s, l) {
                    var c, u, h, d = [],
                        p = [],
                        g = a.length,
                        v = n || f(e || "*", s.nodeType ? [s] : s, []),
                        y = !t || !n && e ? v : m(v, d, t, s, l),
                        _ = i ? o || (n ? t : g || r) ? [] : a : y;
                    if (i && i(y, _, s, l), r)
                        for (c = m(_, p), r(c, [], s, l), u = c.length; u--;)(h = c[u]) && (_[p[u]] = !(y[p[u]] = h));
                    if (n) {
                        if (o || t) {
                            if (o) {
                                for (c = [], u = _.length; u--;)(h = _[u]) && c.push(y[u] = h);
                                o(null, _ = [], c, l)
                            }
                            for (u = _.length; u--;)(h = _[u]) && (c = o ? $(n, h) : d[u]) > -1 && (n[c] = !(a[c] = h))
                        }
                    } else _ = m(_ === a ? _.splice(g, _.length) : _), o ? o(null, a, _, l) : Z.apply(a, _)
                })
            }

            function v(t) {
                for (var e, i, n, r = t.length, o = b.relative[t[0].type], a = o || b.relative[" "], s = o ? 1 : 0, l = d(function(t) {
                        return t === e
                    }, a, !0), c = d(function(t) {
                        return $(e, t) > -1
                    }, a, !0), u = [function(t, i, n) {
                        var r = !o && (n || i !== A) || ((e = i).nodeType ? l(t, i, n) : c(t, i, n));
                        return e = null, r
                    }]; s < r; s++)
                    if (i = b.relative[t[s].type]) u = [d(p(u), i)];
                    else {
                        if ((i = b.filter[t[s].type].apply(null, t[s].matches))[U]) {
                            for (n = ++s; n < r && !b.relative[t[n].type]; n++);
                            return g(s > 1 && p(u), s > 1 && h(t.slice(0, s - 1).concat({
                                value: " " === t[s - 2].type ? "*" : ""
                            })).replace(ot, "$1"), i, s < n && v(t.slice(s, n)), n < r && v(t = t.slice(n)), n < r && h(t))
                        }
                        u.push(i)
                    } return p(u)
            }

            function y(t, i) {
                var r = i.length > 0,
                    o = t.length > 0,
                    a = function(n, a, s, l, c) {
                        var u, h, d, p = 0,
                            f = "0",
                            g = n && [],
                            v = [],
                            y = A,
                            _ = n || o && b.find.TAG("*", c),
                            x = z += null == y ? 1 : Math.random() || .1,
                            w = _.length;
                        for (c && (A = a === R || a || c); f !== w && null != (u = _[f]); f++) {
                            if (o && u) {
                                for (h = 0, a || u.ownerDocument === R || (P(u), s = !I); d = t[h++];)
                                    if (d(u, a || R, s)) {
                                        l.push(u);
                                        break
                                    } c && (z = x)
                            }
                            r && ((u = !d && u) && p--, n && g.push(u))
                        }
                        if (p += f, r && f !== p) {
                            for (h = 0; d = i[h++];) d(g, v, a, s);
                            if (n) {
                                if (p > 0)
                                    for (; f--;) g[f] || v[f] || (v[f] = Y.call(l));
                                v = m(v)
                            }
                            Z.apply(l, v), c && !n && v.length > 0 && p + i.length > 1 && e.uniqueSort(l)
                        }
                        return c && (z = x, A = y), g
                    };
                return r ? n(a) : a
            }
            var _, x, b, w, T, S, E, M, A, L, C, P, R, O, I, D, N, F, k, U = "sizzle" + 1 * new Date,
                B = t.document,
                z = 0,
                j = 0,
                H = i(),
                G = i(),
                V = i(),
                W = function(t, e) {
                    return t === e && (C = !0), 0
                },
                X = {}.hasOwnProperty,
                q = [],
                Y = q.pop,
                Q = q.push,
                Z = q.push,
                J = q.slice,
                $ = function(t, e) {
                    for (var i = 0, n = t.length; i < n; i++)
                        if (t[i] === e) return i;
                    return -1
                },
                K = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",
                tt = "[\\x20\\t\\r\\n\\f]",
                et = "(?:\\\\.|[\\w-]|[^\0-\\xa0])+",
                it = "\\[" + tt + "*(" + et + ")(?:" + tt + "*([*^$|!~]?=)" + tt + "*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + et + "))|)" + tt + "*\\]",
                nt = ":(" + et + ")(?:\\((('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|((?:\\\\.|[^\\\\()[\\]]|" + it + ")*)|.*)\\)|)",
                rt = new RegExp(tt + "+", "g"),
                ot = new RegExp("^" + tt + "+|((?:^|[^\\\\])(?:\\\\.)*)" + tt + "+$", "g"),
                at = new RegExp("^" + tt + "*," + tt + "*"),
                st = new RegExp("^" + tt + "*([>+~]|" + tt + ")" + tt + "*"),
                lt = new RegExp("=" + tt + "*([^\\]'\"]*?)" + tt + "*\\]", "g"),
                ct = new RegExp(nt),
                ut = new RegExp("^" + et + "$"),
                ht = {
                    ID: new RegExp("^#(" + et + ")"),
                    CLASS: new RegExp("^\\.(" + et + ")"),
                    TAG: new RegExp("^(" + et + "|[*])"),
                    ATTR: new RegExp("^" + it),
                    PSEUDO: new RegExp("^" + nt),
                    CHILD: new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + tt + "*(even|odd|(([+-]|)(\\d*)n|)" + tt + "*(?:([+-]|)" + tt + "*(\\d+)|))" + tt + "*\\)|)", "i"),
                    bool: new RegExp("^(?:" + K + ")$", "i"),
                    needsContext: new RegExp("^" + tt + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" + tt + "*((?:-\\d)?\\d*)" + tt + "*\\)|)(?=[^-]|$)", "i")
                },
                dt = /^(?:input|select|textarea|button)$/i,
                pt = /^h\d$/i,
                ft = /^[^{]+\{\s*\[native \w/,
                mt = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,
                gt = /[+~]/,
                vt = new RegExp("\\\\([\\da-f]{1,6}" + tt + "?|(" + tt + ")|.)", "ig"),
                yt = function(t, e, i) {
                    var n = "0x" + e - 65536;
                    return n !== n || i ? e : n < 0 ? String.fromCharCode(n + 65536) : String.fromCharCode(n >> 10 | 55296, 1023 & n | 56320)
                },
                _t = /([\0-\x1f\x7f]|^-?\d)|^-$|[^\0-\x1f\x7f-\uFFFF\w-]/g,
                xt = function(t, e) {
                    return e ? "\0" === t ? "�" : t.slice(0, -1) + "\\" + t.charCodeAt(t.length - 1).toString(16) + " " : "\\" + t
                },
                bt = function() {
                    P()
                },
                wt = d(function(t) {
                    return !0 === t.disabled && ("form" in t || "label" in t)
                }, {
                    dir: "parentNode",
                    next: "legend"
                });
            try {
                Z.apply(q = J.call(B.childNodes), B.childNodes), q[B.childNodes.length].nodeType
            } catch (t) {
                Z = {
                    apply: q.length ? function(t, e) {
                        Q.apply(t, J.call(e))
                    } : function(t, e) {
                        for (var i = t.length, n = 0; t[i++] = e[n++];);
                        t.length = i - 1
                    }
                }
            }
            x = e.support = {}, T = e.isXML = function(t) {
                var e = t && (t.ownerDocument || t).documentElement;
                return !!e && "HTML" !== e.nodeName
            }, P = e.setDocument = function(t) {
                var e, i, n = t ? t.ownerDocument || t : B;
                return n !== R && 9 === n.nodeType && n.documentElement ? (R = n, O = R.documentElement, I = !T(R), B !== R && (i = R.defaultView) && i.top !== i && (i.addEventListener ? i.addEventListener("unload", bt, !1) : i.attachEvent && i.attachEvent("onunload", bt)), x.attributes = r(function(t) {
                    return t.className = "i", !t.getAttribute("className")
                }), x.getElementsByTagName = r(function(t) {
                    return t.appendChild(R.createComment("")), !t.getElementsByTagName("*").length
                }), x.getElementsByClassName = ft.test(R.getElementsByClassName), x.getById = r(function(t) {
                    return O.appendChild(t).id = U, !R.getElementsByName || !R.getElementsByName(U).length
                }), x.getById ? (b.filter.ID = function(t) {
                    var e = t.replace(vt, yt);
                    return function(t) {
                        return t.getAttribute("id") === e
                    }
                }, b.find.ID = function(t, e) {
                    if (void 0 !== e.getElementById && I) {
                        var i = e.getElementById(t);
                        return i ? [i] : []
                    }
                }) : (b.filter.ID = function(t) {
                    var e = t.replace(vt, yt);
                    return function(t) {
                        var i = void 0 !== t.getAttributeNode && t.getAttributeNode("id");
                        return i && i.value === e
                    }
                }, b.find.ID = function(t, e) {
                    if (void 0 !== e.getElementById && I) {
                        var i, n, r, o = e.getElementById(t);
                        if (o) {
                            if ((i = o.getAttributeNode("id")) && i.value === t) return [o];
                            for (r = e.getElementsByName(t), n = 0; o = r[n++];)
                                if ((i = o.getAttributeNode("id")) && i.value === t) return [o]
                        }
                        return []
                    }
                }), b.find.TAG = x.getElementsByTagName ? function(t, e) {
                    return void 0 !== e.getElementsByTagName ? e.getElementsByTagName(t) : x.qsa ? e.querySelectorAll(t) : void 0
                } : function(t, e) {
                    var i, n = [],
                        r = 0,
                        o = e.getElementsByTagName(t);
                    if ("*" === t) {
                        for (; i = o[r++];) 1 === i.nodeType && n.push(i);
                        return n
                    }
                    return o
                }, b.find.CLASS = x.getElementsByClassName && function(t, e) {
                    if (void 0 !== e.getElementsByClassName && I) return e.getElementsByClassName(t)
                }, N = [], D = [], (x.qsa = ft.test(R.querySelectorAll)) && (r(function(t) {
                    O.appendChild(t).innerHTML = "<a id='" + U + "'></a><select id='" + U + "-\r\\' msallowcapture=''><option selected=''></option></select>", t.querySelectorAll("[msallowcapture^='']").length && D.push("[*^$]=" + tt + "*(?:''|\"\")"), t.querySelectorAll("[selected]").length || D.push("\\[" + tt + "*(?:value|" + K + ")"), t.querySelectorAll("[id~=" + U + "-]").length || D.push("~="), t.querySelectorAll(":checked").length || D.push(":checked"), t.querySelectorAll("a#" + U + "+*").length || D.push(".#.+[+~]")
                }), r(function(t) {
                    t.innerHTML = "<a href='' disabled='disabled'></a><select disabled='disabled'><option/></select>";
                    var e = R.createElement("input");
                    e.setAttribute("type", "hidden"), t.appendChild(e).setAttribute("name", "D"), t.querySelectorAll("[name=d]").length && D.push("name" + tt + "*[*^$|!~]?="), 2 !== t.querySelectorAll(":enabled").length && D.push(":enabled", ":disabled"), O.appendChild(t).disabled = !0, 2 !== t.querySelectorAll(":disabled").length && D.push(":enabled", ":disabled"), t.querySelectorAll("*,:x"), D.push(",.*:")
                })), (x.matchesSelector = ft.test(F = O.matches || O.webkitMatchesSelector || O.mozMatchesSelector || O.oMatchesSelector || O.msMatchesSelector)) && r(function(t) {
                    x.disconnectedMatch = F.call(t, "*"), F.call(t, "[s!='']:x"), N.push("!=", nt)
                }), D = D.length && new RegExp(D.join("|")), N = N.length && new RegExp(N.join("|")), e = ft.test(O.compareDocumentPosition), k = e || ft.test(O.contains) ? function(t, e) {
                    var i = 9 === t.nodeType ? t.documentElement : t,
                        n = e && e.parentNode;
                    return t === n || !(!n || 1 !== n.nodeType || !(i.contains ? i.contains(n) : t.compareDocumentPosition && 16 & t.compareDocumentPosition(n)))
                } : function(t, e) {
                    if (e)
                        for (; e = e.parentNode;)
                            if (e === t) return !0;
                    return !1
                }, W = e ? function(t, e) {
                    if (t === e) return C = !0, 0;
                    var i = !t.compareDocumentPosition - !e.compareDocumentPosition;
                    return i || (i = (t.ownerDocument || t) === (e.ownerDocument || e) ? t.compareDocumentPosition(e) : 1, 1 & i || !x.sortDetached && e.compareDocumentPosition(t) === i ? t === R || t.ownerDocument === B && k(B, t) ? -1 : e === R || e.ownerDocument === B && k(B, e) ? 1 : L ? $(L, t) - $(L, e) : 0 : 4 & i ? -1 : 1)
                } : function(t, e) {
                    if (t === e) return C = !0, 0;
                    var i, n = 0,
                        r = t.parentNode,
                        o = e.parentNode,
                        s = [t],
                        l = [e];
                    if (!r || !o) return t === R ? -1 : e === R ? 1 : r ? -1 : o ? 1 : L ? $(L, t) - $(L, e) : 0;
                    if (r === o) return a(t, e);
                    for (i = t; i = i.parentNode;) s.unshift(i);
                    for (i = e; i = i.parentNode;) l.unshift(i);
                    for (; s[n] === l[n];) n++;
                    return n ? a(s[n], l[n]) : s[n] === B ? -1 : l[n] === B ? 1 : 0
                }, R) : R
            }, e.matches = function(t, i) {
                return e(t, null, null, i)
            }, e.matchesSelector = function(t, i) {
                if ((t.ownerDocument || t) !== R && P(t), i = i.replace(lt, "='$1']"), x.matchesSelector && I && !V[i + " "] && (!N || !N.test(i)) && (!D || !D.test(i))) try {
                    var n = F.call(t, i);
                    if (n || x.disconnectedMatch || t.document && 11 !== t.document.nodeType) return n
                } catch (t) {}
                return e(i, R, null, [t]).length > 0
            }, e.contains = function(t, e) {
                return (t.ownerDocument || t) !== R && P(t), k(t, e)
            }, e.attr = function(t, e) {
                (t.ownerDocument || t) !== R && P(t);
                var i = b.attrHandle[e.toLowerCase()],
                    n = i && X.call(b.attrHandle, e.toLowerCase()) ? i(t, e, !I) : void 0;
                return void 0 !== n ? n : x.attributes || !I ? t.getAttribute(e) : (n = t.getAttributeNode(e)) && n.specified ? n.value : null
            }, e.escape = function(t) {
                return (t + "").replace(_t, xt)
            }, e.error = function(t) {
                throw new Error("Syntax error, unrecognized expression: " + t)
            }, e.uniqueSort = function(t) {
                var e, i = [],
                    n = 0,
                    r = 0;
                if (C = !x.detectDuplicates, L = !x.sortStable && t.slice(0), t.sort(W), C) {
                    for (; e = t[r++];) e === t[r] && (n = i.push(r));
                    for (; n--;) t.splice(i[n], 1)
                }
                return L = null, t
            }, w = e.getText = function(t) {
                var e, i = "",
                    n = 0,
                    r = t.nodeType;
                if (r) {
                    if (1 === r || 9 === r || 11 === r) {
                        if ("string" == typeof t.textContent) return t.textContent;
                        for (t = t.firstChild; t; t = t.nextSibling) i += w(t)
                    } else if (3 === r || 4 === r) return t.nodeValue
                } else
                    for (; e = t[n++];) i += w(e);
                return i
            }, (b = e.selectors = {
                cacheLength: 50,
                createPseudo: n,
                match: ht,
                attrHandle: {},
                find: {},
                relative: {
                    ">": {
                        dir: "parentNode",
                        first: !0
                    },
                    " ": {
                        dir: "parentNode"
                    },
                    "+": {
                        dir: "previousSibling",
                        first: !0
                    },
                    "~": {
                        dir: "previousSibling"
                    }
                },
                preFilter: {
                    ATTR: function(t) {
                        return t[1] = t[1].replace(vt, yt), t[3] = (t[3] || t[4] || t[5] || "").replace(vt, yt), "~=" === t[2] && (t[3] = " " + t[3] + " "), t.slice(0, 4)
                    },
                    CHILD: function(t) {
                        return t[1] = t[1].toLowerCase(), "nth" === t[1].slice(0, 3) ? (t[3] || e.error(t[0]), t[4] = +(t[4] ? t[5] + (t[6] || 1) : 2 * ("even" === t[3] || "odd" === t[3])), t[5] = +(t[7] + t[8] || "odd" === t[3])) : t[3] && e.error(t[0]), t
                    },
                    PSEUDO: function(t) {
                        var e, i = !t[6] && t[2];
                        return ht.CHILD.test(t[0]) ? null : (t[3] ? t[2] = t[4] || t[5] || "" : i && ct.test(i) && (e = S(i, !0)) && (e = i.indexOf(")", i.length - e) - i.length) && (t[0] = t[0].slice(0, e), t[2] = i.slice(0, e)), t.slice(0, 3))
                    }
                },
                filter: {
                    TAG: function(t) {
                        var e = t.replace(vt, yt).toLowerCase();
                        return "*" === t ? function() {
                            return !0
                        } : function(t) {
                            return t.nodeName && t.nodeName.toLowerCase() === e
                        }
                    },
                    CLASS: function(t) {
                        var e = H[t + " "];
                        return e || (e = new RegExp("(^|" + tt + ")" + t + "(" + tt + "|$)")) && H(t, function(t) {
                            return e.test("string" == typeof t.className && t.className || void 0 !== t.getAttribute && t.getAttribute("class") || "")
                        })
                    },
                    ATTR: function(t, i, n) {
                        return function(r) {
                            var o = e.attr(r, t);
                            return null == o ? "!=" === i : !i || (o += "", "=" === i ? o === n : "!=" === i ? o !== n : "^=" === i ? n && 0 === o.indexOf(n) : "*=" === i ? n && o.indexOf(n) > -1 : "$=" === i ? n && o.slice(-n.length) === n : "~=" === i ? (" " + o.replace(rt, " ") + " ").indexOf(n) > -1 : "|=" === i && (o === n || o.slice(0, n.length + 1) === n + "-"))
                        }
                    },
                    CHILD: function(t, e, i, n, r) {
                        var o = "nth" !== t.slice(0, 3),
                            a = "last" !== t.slice(-4),
                            s = "of-type" === e;
                        return 1 === n && 0 === r ? function(t) {
                            return !!t.parentNode
                        } : function(e, i, l) {
                            var c, u, h, d, p, f, m = o !== a ? "nextSibling" : "previousSibling",
                                g = e.parentNode,
                                v = s && e.nodeName.toLowerCase(),
                                y = !l && !s,
                                _ = !1;
                            if (g) {
                                if (o) {
                                    for (; m;) {
                                        for (d = e; d = d[m];)
                                            if (s ? d.nodeName.toLowerCase() === v : 1 === d.nodeType) return !1;
                                        f = m = "only" === t && !f && "nextSibling"
                                    }
                                    return !0
                                }
                                if (f = [a ? g.firstChild : g.lastChild], a && y) {
                                    for (_ = (p = (c = (u = (h = (d = g)[U] || (d[U] = {}))[d.uniqueID] || (h[d.uniqueID] = {}))[t] || [])[0] === z && c[1]) && c[2], d = p && g.childNodes[p]; d = ++p && d && d[m] || (_ = p = 0) || f.pop();)
                                        if (1 === d.nodeType && ++_ && d === e) {
                                            u[t] = [z, p, _];
                                            break
                                        }
                                } else if (y && (_ = p = (c = (u = (h = (d = e)[U] || (d[U] = {}))[d.uniqueID] || (h[d.uniqueID] = {}))[t] || [])[0] === z && c[1]), !1 === _)
                                    for (;
                                        (d = ++p && d && d[m] || (_ = p = 0) || f.pop()) && ((s ? d.nodeName.toLowerCase() !== v : 1 !== d.nodeType) || !++_ || (y && ((u = (h = d[U] || (d[U] = {}))[d.uniqueID] || (h[d.uniqueID] = {}))[t] = [z, _]), d !== e)););
                                return (_ -= r) === n || _ % n == 0 && _ / n >= 0
                            }
                        }
                    },
                    PSEUDO: function(t, i) {
                        var r, o = b.pseudos[t] || b.setFilters[t.toLowerCase()] || e.error("unsupported pseudo: " + t);
                        return o[U] ? o(i) : o.length > 1 ? (r = [t, t, "", i], b.setFilters.hasOwnProperty(t.toLowerCase()) ? n(function(t, e) {
                            for (var n, r = o(t, i), a = r.length; a--;) t[n = $(t, r[a])] = !(e[n] = r[a])
                        }) : function(t) {
                            return o(t, 0, r)
                        }) : o
                    }
                },
                pseudos: {
                    not: n(function(t) {
                        var e = [],
                            i = [],
                            r = E(t.replace(ot, "$1"));
                        return r[U] ? n(function(t, e, i, n) {
                            for (var o, a = r(t, null, n, []), s = t.length; s--;)(o = a[s]) && (t[s] = !(e[s] = o))
                        }) : function(t, n, o) {
                            return e[0] = t, r(e, null, o, i), e[0] = null, !i.pop()
                        }
                    }),
                    has: n(function(t) {
                        return function(i) {
                            return e(t, i).length > 0
                        }
                    }),
                    contains: n(function(t) {
                        return t = t.replace(vt, yt),
                            function(e) {
                                return (e.textContent || e.innerText || w(e)).indexOf(t) > -1
                            }
                    }),
                    lang: n(function(t) {
                        return ut.test(t || "") || e.error("unsupported lang: " + t), t = t.replace(vt, yt).toLowerCase(),
                            function(e) {
                                var i;
                                do {
                                    if (i = I ? e.lang : e.getAttribute("xml:lang") || e.getAttribute("lang")) return (i = i.toLowerCase()) === t || 0 === i.indexOf(t + "-")
                                } while ((e = e.parentNode) && 1 === e.nodeType);
                                return !1
                            }
                    }),
                    target: function(e) {
                        var i = t.location && t.location.hash;
                        return i && i.slice(1) === e.id
                    },
                    root: function(t) {
                        return t === O
                    },
                    focus: function(t) {
                        return t === R.activeElement && (!R.hasFocus || R.hasFocus()) && !!(t.type || t.href || ~t.tabIndex)
                    },
                    enabled: s(!1),
                    disabled: s(!0),
                    checked: function(t) {
                        var e = t.nodeName.toLowerCase();
                        return "input" === e && !!t.checked || "option" === e && !!t.selected
                    },
                    selected: function(t) {
                        return t.parentNode && t.parentNode.selectedIndex, !0 === t.selected
                    },
                    empty: function(t) {
                        for (t = t.firstChild; t; t = t.nextSibling)
                            if (t.nodeType < 6) return !1;
                        return !0
                    },
                    parent: function(t) {
                        return !b.pseudos.empty(t)
                    },
                    header: function(t) {
                        return pt.test(t.nodeName)
                    },
                    input: function(t) {
                        return dt.test(t.nodeName)
                    },
                    button: function(t) {
                        var e = t.nodeName.toLowerCase();
                        return "input" === e && "button" === t.type || "button" === e
                    },
                    text: function(t) {
                        var e;
                        return "input" === t.nodeName.toLowerCase() && "text" === t.type && (null == (e = t.getAttribute("type")) || "text" === e.toLowerCase())
                    },
                    first: l(function() {
                        return [0]
                    }),
                    last: l(function(t, e) {
                        return [e - 1]
                    }),
                    eq: l(function(t, e, i) {
                        return [i < 0 ? i + e : i]
                    }),
                    even: l(function(t, e) {
                        for (var i = 0; i < e; i += 2) t.push(i);
                        return t
                    }),
                    odd: l(function(t, e) {
                        for (var i = 1; i < e; i += 2) t.push(i);
                        return t
                    }),
                    lt: l(function(t, e, i) {
                        for (var n = i < 0 ? i + e : i; --n >= 0;) t.push(n);
                        return t
                    }),
                    gt: l(function(t, e, i) {
                        for (var n = i < 0 ? i + e : i; ++n < e;) t.push(n);
                        return t
                    })
                }
            }).pseudos.nth = b.pseudos.eq;
            for (_ in {
                    radio: !0,
                    checkbox: !0,
                    file: !0,
                    password: !0,
                    image: !0
                }) b.pseudos[_] = function(t) {
                return function(e) {
                    return "input" === e.nodeName.toLowerCase() && e.type === t
                }
            }(_);
            for (_ in {
                    submit: !0,
                    reset: !0
                }) b.pseudos[_] = function(t) {
                return function(e) {
                    var i = e.nodeName.toLowerCase();
                    return ("input" === i || "button" === i) && e.type === t
                }
            }(_);
            return u.prototype = b.filters = b.pseudos, b.setFilters = new u, S = e.tokenize = function(t, i) {
                var n, r, o, a, s, l, c, u = G[t + " "];
                if (u) return i ? 0 : u.slice(0);
                for (s = t, l = [], c = b.preFilter; s;) {
                    n && !(r = at.exec(s)) || (r && (s = s.slice(r[0].length) || s), l.push(o = [])), n = !1, (r = st.exec(s)) && (n = r.shift(), o.push({
                        value: n,
                        type: r[0].replace(ot, " ")
                    }), s = s.slice(n.length));
                    for (a in b.filter) !(r = ht[a].exec(s)) || c[a] && !(r = c[a](r)) || (n = r.shift(), o.push({
                        value: n,
                        type: a,
                        matches: r
                    }), s = s.slice(n.length));
                    if (!n) break
                }
                return i ? s.length : s ? e.error(t) : G(t, l).slice(0)
            }, E = e.compile = function(t, e) {
                var i, n = [],
                    r = [],
                    o = V[t + " "];
                if (!o) {
                    for (e || (e = S(t)), i = e.length; i--;)(o = v(e[i]))[U] ? n.push(o) : r.push(o);
                    (o = V(t, y(r, n))).selector = t
                }
                return o
            }, M = e.select = function(t, e, i, n) {
                var r, o, a, s, l, u = "function" == typeof t && t,
                    d = !n && S(t = u.selector || t);
                if (i = i || [], 1 === d.length) {
                    if ((o = d[0] = d[0].slice(0)).length > 2 && "ID" === (a = o[0]).type && 9 === e.nodeType && I && b.relative[o[1].type]) {
                        if (!(e = (b.find.ID(a.matches[0].replace(vt, yt), e) || [])[0])) return i;
                        u && (e = e.parentNode), t = t.slice(o.shift().value.length)
                    }
                    for (r = ht.needsContext.test(t) ? 0 : o.length; r-- && (a = o[r], !b.relative[s = a.type]);)
                        if ((l = b.find[s]) && (n = l(a.matches[0].replace(vt, yt), gt.test(o[0].type) && c(e.parentNode) || e))) {
                            if (o.splice(r, 1), !(t = n.length && h(o))) return Z.apply(i, n), i;
                            break
                        }
                }
                return (u || E(t, d))(n, e, !I, i, !e || gt.test(t) && c(e.parentNode) || e), i
            }, x.sortStable = U.split("").sort(W).join("") === U, x.detectDuplicates = !!C, P(), x.sortDetached = r(function(t) {
                return 1 & t.compareDocumentPosition(R.createElement("fieldset"))
            }), r(function(t) {
                return t.innerHTML = "<a href='#'></a>", "#" === t.firstChild.getAttribute("href")
            }) || o("type|href|height|width", function(t, e, i) {
                if (!i) return t.getAttribute(e, "type" === e.toLowerCase() ? 1 : 2)
            }), x.attributes && r(function(t) {
                return t.innerHTML = "<input/>", t.firstChild.setAttribute("value", ""), "" === t.firstChild.getAttribute("value")
            }) || o("value", function(t, e, i) {
                if (!i && "input" === t.nodeName.toLowerCase()) return t.defaultValue
            }), r(function(t) {
                return null == t.getAttribute("disabled")
            }) || o(K, function(t, e, i) {
                var n;
                if (!i) return !0 === t[e] ? e.toLowerCase() : (n = t.getAttributeNode(e)) && n.specified ? n.value : null
            }), e
        }(i);
        vt.find = wt, vt.expr = wt.selectors, vt.expr[":"] = vt.expr.pseudos, vt.uniqueSort = vt.unique = wt.uniqueSort, vt.text = wt.getText, vt.isXMLDoc = wt.isXML, vt.contains = wt.contains, vt.escapeSelector = wt.escape;
        var Tt = function(t, e, i) {
                for (var n = [], r = void 0 !== i;
                    (t = t[e]) && 9 !== t.nodeType;)
                    if (1 === t.nodeType) {
                        if (r && vt(t).is(i)) break;
                        n.push(t)
                    } return n
            },
            St = function(t, e) {
                for (var i = []; t; t = t.nextSibling) 1 === t.nodeType && t !== e && i.push(t);
                return i
            },
            Et = vt.expr.match.needsContext,
            Mt = /^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i,
            At = /^.[^:#\[\.,]*$/;
        vt.filter = function(t, e, i) {
            var n = e[0];
            return i && (t = ":not(" + t + ")"), 1 === e.length && 1 === n.nodeType ? vt.find.matchesSelector(n, t) ? [n] : [] : vt.find.matches(t, vt.grep(e, function(t) {
                return 1 === t.nodeType
            }))
        }, vt.fn.extend({
            find: function(t) {
                var e, i, n = this.length,
                    r = this;
                if ("string" != typeof t) return this.pushStack(vt(t).filter(function() {
                    for (e = 0; e < n; e++)
                        if (vt.contains(r[e], this)) return !0
                }));
                for (i = this.pushStack([]), e = 0; e < n; e++) vt.find(t, r[e], i);
                return n > 1 ? vt.uniqueSort(i) : i
            },
            filter: function(t) {
                return this.pushStack(c(this, t || [], !1))
            },
            not: function(t) {
                return this.pushStack(c(this, t || [], !0))
            },
            is: function(t) {
                return !!c(this, "string" == typeof t && Et.test(t) ? vt(t) : t || [], !1).length
            }
        });
        var Lt, Ct = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/;
        (vt.fn.init = function(t, e, i) {
            var n, r;
            if (!t) return this;
            if (i = i || Lt, "string" == typeof t) {
                if (!(n = "<" === t[0] && ">" === t[t.length - 1] && t.length >= 3 ? [null, t, null] : Ct.exec(t)) || !n[1] && e) return !e || e.jquery ? (e || i).find(t) : this.constructor(e).find(t);
                if (n[1]) {
                    if (e = e instanceof vt ? e[0] : e, vt.merge(this, vt.parseHTML(n[1], e && e.nodeType ? e.ownerDocument || e : ot, !0)), Mt.test(n[1]) && vt.isPlainObject(e))
                        for (n in e) vt.isFunction(this[n]) ? this[n](e[n]) : this.attr(n, e[n]);
                    return this
                }
                return (r = ot.getElementById(n[2])) && (this[0] = r, this.length = 1), this
            }
            return t.nodeType ? (this[0] = t, this.length = 1, this) : vt.isFunction(t) ? void 0 !== i.ready ? i.ready(t) : t(vt) : vt.makeArray(t, this)
        }).prototype = vt.fn, Lt = vt(ot);
        var Pt = /^(?:parents|prev(?:Until|All))/,
            Rt = {
                children: !0,
                contents: !0,
                next: !0,
                prev: !0
            };
        vt.fn.extend({
            has: function(t) {
                var e = vt(t, this),
                    i = e.length;
                return this.filter(function() {
                    for (var t = 0; t < i; t++)
                        if (vt.contains(this, e[t])) return !0
                })
            },
            closest: function(t, e) {
                var i, n = 0,
                    r = this.length,
                    o = [],
                    a = "string" != typeof t && vt(t);
                if (!Et.test(t))
                    for (; n < r; n++)
                        for (i = this[n]; i && i !== e; i = i.parentNode)
                            if (i.nodeType < 11 && (a ? a.index(i) > -1 : 1 === i.nodeType && vt.find.matchesSelector(i, t))) {
                                o.push(i);
                                break
                            } return this.pushStack(o.length > 1 ? vt.uniqueSort(o) : o)
            },
            index: function(t) {
                return t ? "string" == typeof t ? ut.call(vt(t), this[0]) : ut.call(this, t.jquery ? t[0] : t) : this[0] && this[0].parentNode ? this.first().prevAll().length : -1
            },
            add: function(t, e) {
                return this.pushStack(vt.uniqueSort(vt.merge(this.get(), vt(t, e))))
            },
            addBack: function(t) {
                return this.add(null == t ? this.prevObject : this.prevObject.filter(t))
            }
        }), vt.each({
            parent: function(t) {
                var e = t.parentNode;
                return e && 11 !== e.nodeType ? e : null
            },
            parents: function(t) {
                return Tt(t, "parentNode")
            },
            parentsUntil: function(t, e, i) {
                return Tt(t, "parentNode", i)
            },
            next: function(t) {
                return u(t, "nextSibling")
            },
            prev: function(t) {
                return u(t, "previousSibling")
            },
            nextAll: function(t) {
                return Tt(t, "nextSibling")
            },
            prevAll: function(t) {
                return Tt(t, "previousSibling")
            },
            nextUntil: function(t, e, i) {
                return Tt(t, "nextSibling", i)
            },
            prevUntil: function(t, e, i) {
                return Tt(t, "previousSibling", i)
            },
            siblings: function(t) {
                return St((t.parentNode || {}).firstChild, t)
            },
            children: function(t) {
                return St(t.firstChild)
            },
            contents: function(t) {
                return l(t, "iframe") ? t.contentDocument : (l(t, "template") && (t = t.content || t), vt.merge([], t.childNodes))
            }
        }, function(t, e) {
            vt.fn[t] = function(i, n) {
                var r = vt.map(this, e, i);
                return "Until" !== t.slice(-5) && (n = i), n && "string" == typeof n && (r = vt.filter(n, r)), this.length > 1 && (Rt[t] || vt.uniqueSort(r), Pt.test(t) && r.reverse()), this.pushStack(r)
            }
        });
        var Ot = /[^\x20\t\r\n\f]+/g;
        vt.Callbacks = function(t) {
            t = "string" == typeof t ? h(t) : vt.extend({}, t);
            var e, i, n, r, o = [],
                a = [],
                s = -1,
                l = function() {
                    for (r = r || t.once, n = e = !0; a.length; s = -1)
                        for (i = a.shift(); ++s < o.length;) !1 === o[s].apply(i[0], i[1]) && t.stopOnFalse && (s = o.length, i = !1);
                    t.memory || (i = !1), e = !1, r && (o = i ? [] : "")
                },
                c = {
                    add: function() {
                        return o && (i && !e && (s = o.length - 1, a.push(i)), function e(i) {
                            vt.each(i, function(i, n) {
                                vt.isFunction(n) ? t.unique && c.has(n) || o.push(n) : n && n.length && "string" !== vt.type(n) && e(n)
                            })
                        }(arguments), i && !e && l()), this
                    },
                    remove: function() {
                        return vt.each(arguments, function(t, e) {
                            for (var i;
                                (i = vt.inArray(e, o, i)) > -1;) o.splice(i, 1), i <= s && s--
                        }), this
                    },
                    has: function(t) {
                        return t ? vt.inArray(t, o) > -1 : o.length > 0
                    },
                    empty: function() {
                        return o && (o = []), this
                    },
                    disable: function() {
                        return r = a = [], o = i = "", this
                    },
                    disabled: function() {
                        return !o
                    },
                    lock: function() {
                        return r = a = [], i || e || (o = i = ""), this
                    },
                    locked: function() {
                        return !!r
                    },
                    fireWith: function(t, i) {
                        return r || (i = [t, (i = i || []).slice ? i.slice() : i], a.push(i), e || l()), this
                    },
                    fire: function() {
                        return c.fireWith(this, arguments), this
                    },
                    fired: function() {
                        return !!n
                    }
                };
            return c
        }, vt.extend({
            Deferred: function(t) {
                var e = [
                        ["notify", "progress", vt.Callbacks("memory"), vt.Callbacks("memory"), 2],
                        ["resolve", "done", vt.Callbacks("once memory"), vt.Callbacks("once memory"), 0, "resolved"],
                        ["reject", "fail", vt.Callbacks("once memory"), vt.Callbacks("once memory"), 1, "rejected"]
                    ],
                    n = "pending",
                    r = {
                        state: function() {
                            return n
                        },
                        always: function() {
                            return o.done(arguments).fail(arguments), this
                        },
                        catch: function(t) {
                            return r.then(null, t)
                        },
                        pipe: function() {
                            var t = arguments;
                            return vt.Deferred(function(i) {
                                vt.each(e, function(e, n) {
                                    var r = vt.isFunction(t[n[4]]) && t[n[4]];
                                    o[n[1]](function() {
                                        var t = r && r.apply(this, arguments);
                                        t && vt.isFunction(t.promise) ? t.promise().progress(i.notify).done(i.resolve).fail(i.reject) : i[n[0] + "With"](this, r ? [t] : arguments)
                                    })
                                }), t = null
                            }).promise()
                        },
                        then: function(t, n, r) {
                            function o(t, e, n, r) {
                                return function() {
                                    var s = this,
                                        l = arguments,
                                        c = function() {
                                            var i, c;
                                            if (!(t < a)) {
                                                if ((i = n.apply(s, l)) === e.promise()) throw new TypeError("Thenable self-resolution");
                                                c = i && ("object" == typeof i || "function" == typeof i) && i.then, vt.isFunction(c) ? r ? c.call(i, o(a, e, d, r), o(a, e, p, r)) : (a++, c.call(i, o(a, e, d, r), o(a, e, p, r), o(a, e, d, e.notifyWith))) : (n !== d && (s = void 0, l = [i]), (r || e.resolveWith)(s, l))
                                            }
                                        },
                                        u = r ? c : function() {
                                            try {
                                                c()
                                            } catch (i) {
                                                vt.Deferred.exceptionHook && vt.Deferred.exceptionHook(i, u.stackTrace), t + 1 >= a && (n !== p && (s = void 0, l = [i]), e.rejectWith(s, l))
                                            }
                                        };
                                    t ? u() : (vt.Deferred.getStackHook && (u.stackTrace = vt.Deferred.getStackHook()), i.setTimeout(u))
                                }
                            }
                            var a = 0;
                            return vt.Deferred(function(i) {
                                e[0][3].add(o(0, i, vt.isFunction(r) ? r : d, i.notifyWith)), e[1][3].add(o(0, i, vt.isFunction(t) ? t : d)), e[2][3].add(o(0, i, vt.isFunction(n) ? n : p))
                            }).promise()
                        },
                        promise: function(t) {
                            return null != t ? vt.extend(t, r) : r
                        }
                    },
                    o = {};
                return vt.each(e, function(t, i) {
                    var a = i[2],
                        s = i[5];
                    r[i[1]] = a.add, s && a.add(function() {
                        n = s
                    }, e[3 - t][2].disable, e[0][2].lock), a.add(i[3].fire), o[i[0]] = function() {
                        return o[i[0] + "With"](this === o ? void 0 : this, arguments), this
                    }, o[i[0] + "With"] = a.fireWith
                }), r.promise(o), t && t.call(o, o), o
            },
            when: function(t) {
                var e = arguments.length,
                    i = e,
                    n = Array(i),
                    r = st.call(arguments),
                    o = vt.Deferred(),
                    a = function(t) {
                        return function(i) {
                            n[t] = this, r[t] = arguments.length > 1 ? st.call(arguments) : i, --e || o.resolveWith(n, r)
                        }
                    };
                if (e <= 1 && (f(t, o.done(a(i)).resolve, o.reject, !e), "pending" === o.state() || vt.isFunction(r[i] && r[i].then))) return o.then();
                for (; i--;) f(r[i], a(i), o.reject);
                return o.promise()
            }
        });
        var It = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;
        vt.Deferred.exceptionHook = function(t, e) {
            i.console && i.console.warn && t && It.test(t.name) && i.console.warn("jQuery.Deferred exception: " + t.message, t.stack, e)
        }, vt.readyException = function(t) {
            i.setTimeout(function() {
                throw t
            })
        };
        var Dt = vt.Deferred();
        vt.fn.ready = function(t) {
            return Dt.then(t).catch(function(t) {
                vt.readyException(t)
            }), this
        }, vt.extend({
            isReady: !1,
            readyWait: 1,
            ready: function(t) {
                (!0 === t ? --vt.readyWait : vt.isReady) || (vt.isReady = !0, !0 !== t && --vt.readyWait > 0 || Dt.resolveWith(ot, [vt]))
            }
        }), vt.ready.then = Dt.then, "complete" === ot.readyState || "loading" !== ot.readyState && !ot.documentElement.doScroll ? i.setTimeout(vt.ready) : (ot.addEventListener("DOMContentLoaded", m), i.addEventListener("load", m));
        var Nt = function(t, e, i, n, r, o, a) {
                var s = 0,
                    l = t.length,
                    c = null == i;
                if ("object" === vt.type(i)) {
                    r = !0;
                    for (s in i) Nt(t, e, s, i[s], !0, o, a)
                } else if (void 0 !== n && (r = !0, vt.isFunction(n) || (a = !0), c && (a ? (e.call(t, n), e = null) : (c = e, e = function(t, e, i) {
                        return c.call(vt(t), i)
                    })), e))
                    for (; s < l; s++) e(t[s], i, a ? n : n.call(t[s], s, e(t[s], i)));
                return r ? t : c ? e.call(t) : l ? e(t[0], i) : o
            },
            Ft = function(t) {
                return 1 === t.nodeType || 9 === t.nodeType || !+t.nodeType
            };
        g.uid = 1, g.prototype = {
            cache: function(t) {
                var e = t[this.expando];
                return e || (e = {}, Ft(t) && (t.nodeType ? t[this.expando] = e : Object.defineProperty(t, this.expando, {
                    value: e,
                    configurable: !0
                }))), e
            },
            set: function(t, e, i) {
                var n, r = this.cache(t);
                if ("string" == typeof e) r[vt.camelCase(e)] = i;
                else
                    for (n in e) r[vt.camelCase(n)] = e[n];
                return r
            },
            get: function(t, e) {
                return void 0 === e ? this.cache(t) : t[this.expando] && t[this.expando][vt.camelCase(e)]
            },
            access: function(t, e, i) {
                return void 0 === e || e && "string" == typeof e && void 0 === i ? this.get(t, e) : (this.set(t, e, i), void 0 !== i ? i : e)
            },
            remove: function(t, e) {
                var i, n = t[this.expando];
                if (void 0 !== n) {
                    if (void 0 !== e) {
                        i = (e = Array.isArray(e) ? e.map(vt.camelCase) : (e = vt.camelCase(e)) in n ? [e] : e.match(Ot) || []).length;
                        for (; i--;) delete n[e[i]]
                    }(void 0 === e || vt.isEmptyObject(n)) && (t.nodeType ? t[this.expando] = void 0 : delete t[this.expando])
                }
            },
            hasData: function(t) {
                var e = t[this.expando];
                return void 0 !== e && !vt.isEmptyObject(e)
            }
        };
        var kt = new g,
            Ut = new g,
            Bt = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
            zt = /[A-Z]/g;
        vt.extend({
            hasData: function(t) {
                return Ut.hasData(t) || kt.hasData(t)
            },
            data: function(t, e, i) {
                return Ut.access(t, e, i)
            },
            removeData: function(t, e) {
                Ut.remove(t, e)
            },
            _data: function(t, e, i) {
                return kt.access(t, e, i)
            },
            _removeData: function(t, e) {
                kt.remove(t, e)
            }
        }), vt.fn.extend({
            data: function(t, e) {
                var i, n, r, o = this[0],
                    a = o && o.attributes;
                if (void 0 === t) {
                    if (this.length && (r = Ut.get(o), 1 === o.nodeType && !kt.get(o, "hasDataAttrs"))) {
                        for (i = a.length; i--;) a[i] && 0 === (n = a[i].name).indexOf("data-") && (n = vt.camelCase(n.slice(5)), y(o, n, r[n]));
                        kt.set(o, "hasDataAttrs", !0)
                    }
                    return r
                }
                return "object" == typeof t ? this.each(function() {
                    Ut.set(this, t)
                }) : Nt(this, function(e) {
                    var i;
                    if (o && void 0 === e) {
                        if (void 0 !== (i = Ut.get(o, t))) return i;
                        if (void 0 !== (i = y(o, t))) return i
                    } else this.each(function() {
                        Ut.set(this, t, e)
                    })
                }, null, e, arguments.length > 1, null, !0)
            },
            removeData: function(t) {
                return this.each(function() {
                    Ut.remove(this, t)
                })
            }
        }), vt.extend({
            queue: function(t, e, i) {
                var n;
                if (t) return e = (e || "fx") + "queue", n = kt.get(t, e), i && (!n || Array.isArray(i) ? n = kt.access(t, e, vt.makeArray(i)) : n.push(i)), n || []
            },
            dequeue: function(t, e) {
                e = e || "fx";
                var i = vt.queue(t, e),
                    n = i.length,
                    r = i.shift(),
                    o = vt._queueHooks(t, e);
                "inprogress" === r && (r = i.shift(), n--), r && ("fx" === e && i.unshift("inprogress"), delete o.stop, r.call(t, function() {
                    vt.dequeue(t, e)
                }, o)), !n && o && o.empty.fire()
            },
            _queueHooks: function(t, e) {
                var i = e + "queueHooks";
                return kt.get(t, i) || kt.access(t, i, {
                    empty: vt.Callbacks("once memory").add(function() {
                        kt.remove(t, [e + "queue", i])
                    })
                })
            }
        }), vt.fn.extend({
            queue: function(t, e) {
                var i = 2;
                return "string" != typeof t && (e = t, t = "fx", i--), arguments.length < i ? vt.queue(this[0], t) : void 0 === e ? this : this.each(function() {
                    var i = vt.queue(this, t, e);
                    vt._queueHooks(this, t), "fx" === t && "inprogress" !== i[0] && vt.dequeue(this, t)
                })
            },
            dequeue: function(t) {
                return this.each(function() {
                    vt.dequeue(this, t)
                })
            },
            clearQueue: function(t) {
                return this.queue(t || "fx", [])
            },
            promise: function(t, e) {
                var i, n = 1,
                    r = vt.Deferred(),
                    o = this,
                    a = this.length,
                    s = function() {
                        --n || r.resolveWith(o, [o])
                    };
                for ("string" != typeof t && (e = t, t = void 0), t = t || "fx"; a--;)(i = kt.get(o[a], t + "queueHooks")) && i.empty && (n++, i.empty.add(s));
                return s(), r.promise(e)
            }
        });
        var jt = /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source,
            Ht = new RegExp("^(?:([+-])=|)(" + jt + ")([a-z%]*)$", "i"),
            Gt = ["Top", "Right", "Bottom", "Left"],
            Vt = function(t, e) {
                return "none" === (t = e || t).style.display || "" === t.style.display && vt.contains(t.ownerDocument, t) && "none" === vt.css(t, "display")
            },
            Wt = function(t, e, i, n) {
                var r, o, a = {};
                for (o in e) a[o] = t.style[o], t.style[o] = e[o];
                r = i.apply(t, n || []);
                for (o in e) t.style[o] = a[o];
                return r
            },
            Xt = {};
        vt.fn.extend({
            show: function() {
                return b(this, !0)
            },
            hide: function() {
                return b(this)
            },
            toggle: function(t) {
                return "boolean" == typeof t ? t ? this.show() : this.hide() : this.each(function() {
                    Vt(this) ? vt(this).show() : vt(this).hide()
                })
            }
        });
        var qt = /^(?:checkbox|radio)$/i,
            Yt = /<([a-z][^\/\0>\x20\t\r\n\f]+)/i,
            Qt = /^$|\/(?:java|ecma)script/i,
            Zt = {
                option: [1, "<select multiple='multiple'>", "</select>"],
                thead: [1, "<table>", "</table>"],
                col: [2, "<table><colgroup>", "</colgroup></table>"],
                tr: [2, "<table><tbody>", "</tbody></table>"],
                td: [3, "<table><tbody><tr>", "</tr></tbody></table>"],
                _default: [0, "", ""]
            };
        Zt.optgroup = Zt.option, Zt.tbody = Zt.tfoot = Zt.colgroup = Zt.caption = Zt.thead, Zt.th = Zt.td;
        var Jt = /<|&#?\w+;/;
        ! function() {
            var t = ot.createDocumentFragment().appendChild(ot.createElement("div")),
                e = ot.createElement("input");
            e.setAttribute("type", "radio"), e.setAttribute("checked", "checked"), e.setAttribute("name", "t"), t.appendChild(e), gt.checkClone = t.cloneNode(!0).cloneNode(!0).lastChild.checked, t.innerHTML = "<textarea>x</textarea>", gt.noCloneChecked = !!t.cloneNode(!0).lastChild.defaultValue
        }();
        var $t = ot.documentElement,
            Kt = /^key/,
            te = /^(?:mouse|pointer|contextmenu|drag|drop)|click/,
            ee = /^([^.]*)(?:\.(.+)|)/;
        vt.event = {
            global: {},
            add: function(t, e, i, n, r) {
                var o, a, s, l, c, u, h, d, p, f, m, g = kt.get(t);
                if (g)
                    for (i.handler && (i = (o = i).handler, r = o.selector), r && vt.find.matchesSelector($t, r), i.guid || (i.guid = vt.guid++), (l = g.events) || (l = g.events = {}), (a = g.handle) || (a = g.handle = function(e) {
                            return void 0 !== vt && vt.event.triggered !== e.type ? vt.event.dispatch.apply(t, arguments) : void 0
                        }), c = (e = (e || "").match(Ot) || [""]).length; c--;) p = m = (s = ee.exec(e[c]) || [])[1], f = (s[2] || "").split(".").sort(), p && (h = vt.event.special[p] || {}, p = (r ? h.delegateType : h.bindType) || p, h = vt.event.special[p] || {}, u = vt.extend({
                        type: p,
                        origType: m,
                        data: n,
                        handler: i,
                        guid: i.guid,
                        selector: r,
                        needsContext: r && vt.expr.match.needsContext.test(r),
                        namespace: f.join(".")
                    }, o), (d = l[p]) || ((d = l[p] = []).delegateCount = 0, h.setup && !1 !== h.setup.call(t, n, f, a) || t.addEventListener && t.addEventListener(p, a)), h.add && (h.add.call(t, u), u.handler.guid || (u.handler.guid = i.guid)), r ? d.splice(d.delegateCount++, 0, u) : d.push(u), vt.event.global[p] = !0)
            },
            remove: function(t, e, i, n, r) {
                var o, a, s, l, c, u, h, d, p, f, m, g = kt.hasData(t) && kt.get(t);
                if (g && (l = g.events)) {
                    for (c = (e = (e || "").match(Ot) || [""]).length; c--;)
                        if (s = ee.exec(e[c]) || [], p = m = s[1], f = (s[2] || "").split(".").sort(), p) {
                            for (h = vt.event.special[p] || {}, d = l[p = (n ? h.delegateType : h.bindType) || p] || [], s = s[2] && new RegExp("(^|\\.)" + f.join("\\.(?:.*\\.|)") + "(\\.|$)"), a = o = d.length; o--;) u = d[o], !r && m !== u.origType || i && i.guid !== u.guid || s && !s.test(u.namespace) || n && n !== u.selector && ("**" !== n || !u.selector) || (d.splice(o, 1), u.selector && d.delegateCount--, h.remove && h.remove.call(t, u));
                            a && !d.length && (h.teardown && !1 !== h.teardown.call(t, f, g.handle) || vt.removeEvent(t, p, g.handle), delete l[p])
                        } else
                            for (p in l) vt.event.remove(t, p + e[c], i, n, !0);
                    vt.isEmptyObject(l) && kt.remove(t, "handle events")
                }
            },
            dispatch: function(t) {
                var e, i, n, r, o, a, s = vt.event.fix(t),
                    l = new Array(arguments.length),
                    c = (kt.get(this, "events") || {})[s.type] || [],
                    u = vt.event.special[s.type] || {};
                for (l[0] = s, e = 1; e < arguments.length; e++) l[e] = arguments[e];
                if (s.delegateTarget = this, !u.preDispatch || !1 !== u.preDispatch.call(this, s)) {
                    for (a = vt.event.handlers.call(this, s, c), e = 0;
                        (r = a[e++]) && !s.isPropagationStopped();)
                        for (s.currentTarget = r.elem, i = 0;
                            (o = r.handlers[i++]) && !s.isImmediatePropagationStopped();) s.rnamespace && !s.rnamespace.test(o.namespace) || (s.handleObj = o, s.data = o.data, void 0 !== (n = ((vt.event.special[o.origType] || {}).handle || o.handler).apply(r.elem, l)) && !1 === (s.result = n) && (s.preventDefault(), s.stopPropagation()));
                    return u.postDispatch && u.postDispatch.call(this, s), s.result
                }
            },
            handlers: function(t, e) {
                var i, n, r, o, a, s = [],
                    l = e.delegateCount,
                    c = t.target;
                if (l && c.nodeType && !("click" === t.type && t.button >= 1))
                    for (; c !== this; c = c.parentNode || this)
                        if (1 === c.nodeType && ("click" !== t.type || !0 !== c.disabled)) {
                            for (o = [], a = {}, i = 0; i < l; i++) void 0 === a[r = (n = e[i]).selector + " "] && (a[r] = n.needsContext ? vt(r, this).index(c) > -1 : vt.find(r, this, null, [c]).length), a[r] && o.push(n);
                            o.length && s.push({
                                elem: c,
                                handlers: o
                            })
                        } return c = this, l < e.length && s.push({
                    elem: c,
                    handlers: e.slice(l)
                }), s
            },
            addProp: function(t, e) {
                Object.defineProperty(vt.Event.prototype, t, {
                    enumerable: !0,
                    configurable: !0,
                    get: vt.isFunction(e) ? function() {
                        if (this.originalEvent) return e(this.originalEvent)
                    } : function() {
                        if (this.originalEvent) return this.originalEvent[t]
                    },
                    set: function(e) {
                        Object.defineProperty(this, t, {
                            enumerable: !0,
                            configurable: !0,
                            writable: !0,
                            value: e
                        })
                    }
                })
            },
            fix: function(t) {
                return t[vt.expando] ? t : new vt.Event(t)
            },
            special: {
                load: {
                    noBubble: !0
                },
                focus: {
                    trigger: function() {
                        if (this !== A() && this.focus) return this.focus(), !1
                    },
                    delegateType: "focusin"
                },
                blur: {
                    trigger: function() {
                        if (this === A() && this.blur) return this.blur(), !1
                    },
                    delegateType: "focusout"
                },
                click: {
                    trigger: function() {
                        if ("checkbox" === this.type && this.click && l(this, "input")) return this.click(), !1
                    },
                    _default: function(t) {
                        return l(t.target, "a")
                    }
                },
                beforeunload: {
                    postDispatch: function(t) {
                        void 0 !== t.result && t.originalEvent && (t.originalEvent.returnValue = t.result)
                    }
                }
            }
        }, vt.removeEvent = function(t, e, i) {
            t.removeEventListener && t.removeEventListener(e, i)
        }, vt.Event = function(t, e) {
            if (!(this instanceof vt.Event)) return new vt.Event(t, e);
            t && t.type ? (this.originalEvent = t, this.type = t.type, this.isDefaultPrevented = t.defaultPrevented || void 0 === t.defaultPrevented && !1 === t.returnValue ? E : M, this.target = t.target && 3 === t.target.nodeType ? t.target.parentNode : t.target, this.currentTarget = t.currentTarget, this.relatedTarget = t.relatedTarget) : this.type = t, e && vt.extend(this, e), this.timeStamp = t && t.timeStamp || vt.now(), this[vt.expando] = !0
        }, vt.Event.prototype = {
            constructor: vt.Event,
            isDefaultPrevented: M,
            isPropagationStopped: M,
            isImmediatePropagationStopped: M,
            isSimulated: !1,
            preventDefault: function() {
                var t = this.originalEvent;
                this.isDefaultPrevented = E, t && !this.isSimulated && t.preventDefault()
            },
            stopPropagation: function() {
                var t = this.originalEvent;
                this.isPropagationStopped = E, t && !this.isSimulated && t.stopPropagation()
            },
            stopImmediatePropagation: function() {
                var t = this.originalEvent;
                this.isImmediatePropagationStopped = E, t && !this.isSimulated && t.stopImmediatePropagation(), this.stopPropagation()
            }
        }, vt.each({
            altKey: !0,
            bubbles: !0,
            cancelable: !0,
            changedTouches: !0,
            ctrlKey: !0,
            detail: !0,
            eventPhase: !0,
            metaKey: !0,
            pageX: !0,
            pageY: !0,
            shiftKey: !0,
            view: !0,
            char: !0,
            charCode: !0,
            key: !0,
            keyCode: !0,
            button: !0,
            buttons: !0,
            clientX: !0,
            clientY: !0,
            offsetX: !0,
            offsetY: !0,
            pointerId: !0,
            pointerType: !0,
            screenX: !0,
            screenY: !0,
            targetTouches: !0,
            toElement: !0,
            touches: !0,
            which: function(t) {
                var e = t.button;
                return null == t.which && Kt.test(t.type) ? null != t.charCode ? t.charCode : t.keyCode : !t.which && void 0 !== e && te.test(t.type) ? 1 & e ? 1 : 2 & e ? 3 : 4 & e ? 2 : 0 : t.which
            }
        }, vt.event.addProp), vt.each({
            mouseenter: "mouseover",
            mouseleave: "mouseout",
            pointerenter: "pointerover",
            pointerleave: "pointerout"
        }, function(t, e) {
            vt.event.special[t] = {
                delegateType: e,
                bindType: e,
                handle: function(t) {
                    var i, n = this,
                        r = t.relatedTarget,
                        o = t.handleObj;
                    return r && (r === n || vt.contains(n, r)) || (t.type = o.origType, i = o.handler.apply(this, arguments), t.type = e), i
                }
            }
        }), vt.fn.extend({
            on: function(t, e, i, n) {
                return L(this, t, e, i, n)
            },
            one: function(t, e, i, n) {
                return L(this, t, e, i, n, 1)
            },
            off: function(t, e, i) {
                var n, r;
                if (t && t.preventDefault && t.handleObj) return n = t.handleObj, vt(t.delegateTarget).off(n.namespace ? n.origType + "." + n.namespace : n.origType, n.selector, n.handler), this;
                if ("object" == typeof t) {
                    for (r in t) this.off(r, e, t[r]);
                    return this
                }
                return !1 !== e && "function" != typeof e || (i = e, e = void 0), !1 === i && (i = M), this.each(function() {
                    vt.event.remove(this, t, i, e)
                })
            }
        });
        var ie = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([a-z][^\/\0>\x20\t\r\n\f]*)[^>]*)\/>/gi,
            ne = /<script|<style|<link/i,
            re = /checked\s*(?:[^=]|=\s*.checked.)/i,
            oe = /^true\/(.*)/,
            ae = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g;
        vt.extend({
            htmlPrefilter: function(t) {
                return t.replace(ie, "<$1></$2>")
            },
            clone: function(t, e, i) {
                var n, r, o, a, s = t.cloneNode(!0),
                    l = vt.contains(t.ownerDocument, t);
                if (!(gt.noCloneChecked || 1 !== t.nodeType && 11 !== t.nodeType || vt.isXMLDoc(t)))
                    for (a = w(s), n = 0, r = (o = w(t)).length; n < r; n++) I(o[n], a[n]);
                if (e)
                    if (i)
                        for (o = o || w(t), a = a || w(s), n = 0, r = o.length; n < r; n++) O(o[n], a[n]);
                    else O(t, s);
                return (a = w(s, "script")).length > 0 && T(a, !l && w(t, "script")), s
            },
            cleanData: function(t) {
                for (var e, i, n, r = vt.event.special, o = 0; void 0 !== (i = t[o]); o++)
                    if (Ft(i)) {
                        if (e = i[kt.expando]) {
                            if (e.events)
                                for (n in e.events) r[n] ? vt.event.remove(i, n) : vt.removeEvent(i, n, e.handle);
                            i[kt.expando] = void 0
                        }
                        i[Ut.expando] && (i[Ut.expando] = void 0)
                    }
            }
        }), vt.fn.extend({
            detach: function(t) {
                return N(this, t, !0)
            },
            remove: function(t) {
                return N(this, t)
            },
            text: function(t) {
                return Nt(this, function(t) {
                    return void 0 === t ? vt.text(this) : this.empty().each(function() {
                        1 !== this.nodeType && 11 !== this.nodeType && 9 !== this.nodeType || (this.textContent = t)
                    })
                }, null, t, arguments.length)
            },
            append: function() {
                return D(this, arguments, function(t) {
                    1 !== this.nodeType && 11 !== this.nodeType && 9 !== this.nodeType || C(this, t).appendChild(t)
                })
            },
            prepend: function() {
                return D(this, arguments, function(t) {
                    if (1 === this.nodeType || 11 === this.nodeType || 9 === this.nodeType) {
                        var e = C(this, t);
                        e.insertBefore(t, e.firstChild)
                    }
                })
            },
            before: function() {
                return D(this, arguments, function(t) {
                    this.parentNode && this.parentNode.insertBefore(t, this)
                })
            },
            after: function() {
                return D(this, arguments, function(t) {
                    this.parentNode && this.parentNode.insertBefore(t, this.nextSibling)
                })
            },
            empty: function() {
                for (var t, e = 0; null != (t = this[e]); e++) 1 === t.nodeType && (vt.cleanData(w(t, !1)), t.textContent = "");
                return this
            },
            clone: function(t, e) {
                return t = null != t && t, e = null == e ? t : e, this.map(function() {
                    return vt.clone(this, t, e)
                })
            },
            html: function(t) {
                return Nt(this, function(t) {
                    var e = this[0] || {},
                        i = 0,
                        n = this.length;
                    if (void 0 === t && 1 === e.nodeType) return e.innerHTML;
                    if ("string" == typeof t && !ne.test(t) && !Zt[(Yt.exec(t) || ["", ""])[1].toLowerCase()]) {
                        t = vt.htmlPrefilter(t);
                        try {
                            for (; i < n; i++) 1 === (e = this[i] || {}).nodeType && (vt.cleanData(w(e, !1)), e.innerHTML = t);
                            e = 0
                        } catch (t) {}
                    }
                    e && this.empty().append(t)
                }, null, t, arguments.length)
            },
            replaceWith: function() {
                var t = [];
                return D(this, arguments, function(e) {
                    var i = this.parentNode;
                    vt.inArray(this, t) < 0 && (vt.cleanData(w(this)), i && i.replaceChild(e, this))
                }, t)
            }
        }), vt.each({
            appendTo: "append",
            prependTo: "prepend",
            insertBefore: "before",
            insertAfter: "after",
            replaceAll: "replaceWith"
        }, function(t, e) {
            vt.fn[t] = function(t) {
                for (var i, n = [], r = vt(t), o = r.length - 1, a = 0; a <= o; a++) i = a === o ? this : this.clone(!0), vt(r[a])[e](i), ct.apply(n, i.get());
                return this.pushStack(n)
            }
        });
        var se = /^margin/,
            le = new RegExp("^(" + jt + ")(?!px)[a-z%]+$", "i"),
            ce = function(t) {
                var e = t.ownerDocument.defaultView;
                return e && e.opener || (e = i), e.getComputedStyle(t)
            };
        ! function() {
            function t() {
                if (s) {
                    s.style.cssText = "box-sizing:border-box;position:relative;display:block;margin:auto;border:1px;padding:1px;top:1%;width:50%", s.innerHTML = "", $t.appendChild(a);
                    var t = i.getComputedStyle(s);
                    e = "1%" !== t.top, o = "2px" === t.marginLeft, n = "4px" === t.width, s.style.marginRight = "50%", r = "4px" === t.marginRight, $t.removeChild(a), s = null
                }
            }
            var e, n, r, o, a = ot.createElement("div"),
                s = ot.createElement("div");
            s.style && (s.style.backgroundClip = "content-box", s.cloneNode(!0).style.backgroundClip = "", gt.clearCloneStyle = "content-box" === s.style.backgroundClip, a.style.cssText = "border:0;width:8px;height:0;top:0;left:-9999px;padding:0;margin-top:1px;position:absolute", a.appendChild(s), vt.extend(gt, {
                pixelPosition: function() {
                    return t(), e
                },
                boxSizingReliable: function() {
                    return t(), n
                },
                pixelMarginRight: function() {
                    return t(), r
                },
                reliableMarginLeft: function() {
                    return t(), o
                }
            }))
        }();
        var ue = /^(none|table(?!-c[ea]).+)/,
            he = /^--/,
            de = {
                position: "absolute",
                visibility: "hidden",
                display: "block"
            },
            pe = {
                letterSpacing: "0",
                fontWeight: "400"
            },
            fe = ["Webkit", "Moz", "ms"],
            me = ot.createElement("div").style;
        vt.extend({
            cssHooks: {
                opacity: {
                    get: function(t, e) {
                        if (e) {
                            var i = F(t, "opacity");
                            return "" === i ? "1" : i
                        }
                    }
                }
            },
            cssNumber: {
                animationIterationCount: !0,
                columnCount: !0,
                fillOpacity: !0,
                flexGrow: !0,
                flexShrink: !0,
                fontWeight: !0,
                lineHeight: !0,
                opacity: !0,
                order: !0,
                orphans: !0,
                widows: !0,
                zIndex: !0,
                zoom: !0
            },
            cssProps: {
                float: "cssFloat"
            },
            style: function(t, e, i, n) {
                if (t && 3 !== t.nodeType && 8 !== t.nodeType && t.style) {
                    var r, o, a, s = vt.camelCase(e),
                        l = he.test(e),
                        c = t.style;
                    if (l || (e = B(s)), a = vt.cssHooks[e] || vt.cssHooks[s], void 0 === i) return a && "get" in a && void 0 !== (r = a.get(t, !1, n)) ? r : c[e];
                    "string" == (o = typeof i) && (r = Ht.exec(i)) && r[1] && (i = _(t, e, r), o = "number"), null != i && i === i && ("number" === o && (i += r && r[3] || (vt.cssNumber[s] ? "" : "px")), gt.clearCloneStyle || "" !== i || 0 !== e.indexOf("background") || (c[e] = "inherit"), a && "set" in a && void 0 === (i = a.set(t, i, n)) || (l ? c.setProperty(e, i) : c[e] = i))
                }
            },
            css: function(t, e, i, n) {
                var r, o, a, s = vt.camelCase(e);
                return he.test(e) || (e = B(s)), (a = vt.cssHooks[e] || vt.cssHooks[s]) && "get" in a && (r = a.get(t, !0, i)), void 0 === r && (r = F(t, e, n)), "normal" === r && e in pe && (r = pe[e]), "" === i || i ? (o = parseFloat(r), !0 === i || isFinite(o) ? o || 0 : r) : r
            }
        }), vt.each(["height", "width"], function(t, e) {
            vt.cssHooks[e] = {
                get: function(t, i, n) {
                    if (i) return !ue.test(vt.css(t, "display")) || t.getClientRects().length && t.getBoundingClientRect().width ? H(t, e, n) : Wt(t, de, function() {
                        return H(t, e, n)
                    })
                },
                set: function(t, i, n) {
                    var r, o = n && ce(t),
                        a = n && j(t, e, n, "border-box" === vt.css(t, "boxSizing", !1, o), o);
                    return a && (r = Ht.exec(i)) && "px" !== (r[3] || "px") && (t.style[e] = i, i = vt.css(t, e)), z(t, i, a)
                }
            }
        }), vt.cssHooks.marginLeft = k(gt.reliableMarginLeft, function(t, e) {
            if (e) return (parseFloat(F(t, "marginLeft")) || t.getBoundingClientRect().left - Wt(t, {
                marginLeft: 0
            }, function() {
                return t.getBoundingClientRect().left
            })) + "px"
        }), vt.each({
            margin: "",
            padding: "",
            border: "Width"
        }, function(t, e) {
            vt.cssHooks[t + e] = {
                expand: function(i) {
                    for (var n = 0, r = {}, o = "string" == typeof i ? i.split(" ") : [i]; n < 4; n++) r[t + Gt[n] + e] = o[n] || o[n - 2] || o[0];
                    return r
                }
            }, se.test(t) || (vt.cssHooks[t + e].set = z)
        }), vt.fn.extend({
            css: function(t, e) {
                return Nt(this, function(t, e, i) {
                    var n, r, o = {},
                        a = 0;
                    if (Array.isArray(e)) {
                        for (n = ce(t), r = e.length; a < r; a++) o[e[a]] = vt.css(t, e[a], !1, n);
                        return o
                    }
                    return void 0 !== i ? vt.style(t, e, i) : vt.css(t, e)
                }, t, e, arguments.length > 1)
            }
        }), vt.Tween = G, G.prototype = {
            constructor: G,
            init: function(t, e, i, n, r, o) {
                this.elem = t, this.prop = i, this.easing = r || vt.easing._default, this.options = e, this.start = this.now = this.cur(), this.end = n, this.unit = o || (vt.cssNumber[i] ? "" : "px")
            },
            cur: function() {
                var t = G.propHooks[this.prop];
                return t && t.get ? t.get(this) : G.propHooks._default.get(this)
            },
            run: function(t) {
                var e, i = G.propHooks[this.prop];
                return this.options.duration ? this.pos = e = vt.easing[this.easing](t, this.options.duration * t, 0, 1, this.options.duration) : this.pos = e = t, this.now = (this.end - this.start) * e + this.start, this.options.step && this.options.step.call(this.elem, this.now, this), i && i.set ? i.set(this) : G.propHooks._default.set(this), this
            }
        }, G.prototype.init.prototype = G.prototype, G.propHooks = {
            _default: {
                get: function(t) {
                    var e;
                    return 1 !== t.elem.nodeType || null != t.elem[t.prop] && null == t.elem.style[t.prop] ? t.elem[t.prop] : (e = vt.css(t.elem, t.prop, ""), e && "auto" !== e ? e : 0)
                },
                set: function(t) {
                    vt.fx.step[t.prop] ? vt.fx.step[t.prop](t) : 1 !== t.elem.nodeType || null == t.elem.style[vt.cssProps[t.prop]] && !vt.cssHooks[t.prop] ? t.elem[t.prop] = t.now : vt.style(t.elem, t.prop, t.now + t.unit)
                }
            }
        }, G.propHooks.scrollTop = G.propHooks.scrollLeft = {
            set: function(t) {
                t.elem.nodeType && t.elem.parentNode && (t.elem[t.prop] = t.now)
            }
        }, vt.easing = {
            linear: function(t) {
                return t
            },
            swing: function(t) {
                return .5 - Math.cos(t * Math.PI) / 2
            },
            _default: "swing"
        }, vt.fx = G.prototype.init, vt.fx.step = {};
        var ge, ve, ye = /^(?:toggle|show|hide)$/,
            _e = /queueHooks$/;
        vt.Animation = vt.extend(Q, {
                tweeners: {
                    "*": [function(t, e) {
                        var i = this.createTween(t, e);
                        return _(i.elem, t, Ht.exec(e), i), i
                    }]
                },
                tweener: function(t, e) {
                    vt.isFunction(t) ? (e = t, t = ["*"]) : t = t.match(Ot);
                    for (var i, n = 0, r = t.length; n < r; n++) i = t[n], Q.tweeners[i] = Q.tweeners[i] || [], Q.tweeners[i].unshift(e)
                },
                prefilters: [function(t, e, i) {
                    var n, r, o, a, s, l, c, u, h = "width" in e || "height" in e,
                        d = this,
                        p = {},
                        f = t.style,
                        m = t.nodeType && Vt(t),
                        g = kt.get(t, "fxshow");
                    i.queue || (null == (a = vt._queueHooks(t, "fx")).unqueued && (a.unqueued = 0, s = a.empty.fire, a.empty.fire = function() {
                        a.unqueued || s()
                    }), a.unqueued++, d.always(function() {
                        d.always(function() {
                            a.unqueued--, vt.queue(t, "fx").length || a.empty.fire()
                        })
                    }));
                    for (n in e)
                        if (r = e[n], ye.test(r)) {
                            if (delete e[n], o = o || "toggle" === r, r === (m ? "hide" : "show")) {
                                if ("show" !== r || !g || void 0 === g[n]) continue;
                                m = !0
                            }
                            p[n] = g && g[n] || vt.style(t, n)
                        } if ((l = !vt.isEmptyObject(e)) || !vt.isEmptyObject(p)) {
                        h && 1 === t.nodeType && (i.overflow = [f.overflow, f.overflowX, f.overflowY], null == (c = g && g.display) && (c = kt.get(t, "display")), "none" === (u = vt.css(t, "display")) && (c ? u = c : (b([t], !0), c = t.style.display || c, u = vt.css(t, "display"), b([t]))), ("inline" === u || "inline-block" === u && null != c) && "none" === vt.css(t, "float") && (l || (d.done(function() {
                            f.display = c
                        }), null == c && (u = f.display, c = "none" === u ? "" : u)), f.display = "inline-block")), i.overflow && (f.overflow = "hidden", d.always(function() {
                            f.overflow = i.overflow[0], f.overflowX = i.overflow[1], f.overflowY = i.overflow[2]
                        })), l = !1;
                        for (n in p) l || (g ? "hidden" in g && (m = g.hidden) : g = kt.access(t, "fxshow", {
                            display: c
                        }), o && (g.hidden = !m), m && b([t], !0), d.done(function() {
                            m || b([t]), kt.remove(t, "fxshow");
                            for (n in p) vt.style(t, n, p[n])
                        })), l = q(m ? g[n] : 0, n, d), n in g || (g[n] = l.start, m && (l.end = l.start, l.start = 0))
                    }
                }],
                prefilter: function(t, e) {
                    e ? Q.prefilters.unshift(t) : Q.prefilters.push(t)
                }
            }), vt.speed = function(t, e, i) {
                var n = t && "object" == typeof t ? vt.extend({}, t) : {
                    complete: i || !i && e || vt.isFunction(t) && t,
                    duration: t,
                    easing: i && e || e && !vt.isFunction(e) && e
                };
                return vt.fx.off ? n.duration = 0 : "number" != typeof n.duration && (n.duration in vt.fx.speeds ? n.duration = vt.fx.speeds[n.duration] : n.duration = vt.fx.speeds._default), null != n.queue && !0 !== n.queue || (n.queue = "fx"), n.old = n.complete, n.complete = function() {
                    vt.isFunction(n.old) && n.old.call(this), n.queue && vt.dequeue(this, n.queue)
                }, n
            }, vt.fn.extend({
                fadeTo: function(t, e, i, n) {
                    return this.filter(Vt).css("opacity", 0).show().end().animate({
                        opacity: e
                    }, t, i, n)
                },
                animate: function(t, e, i, n) {
                    var r = vt.isEmptyObject(t),
                        o = vt.speed(e, i, n),
                        a = function() {
                            var e = Q(this, vt.extend({}, t), o);
                            (r || kt.get(this, "finish")) && e.stop(!0)
                        };
                    return a.finish = a, r || !1 === o.queue ? this.each(a) : this.queue(o.queue, a)
                },
                stop: function(t, e, i) {
                    var n = function(t) {
                        var e = t.stop;
                        delete t.stop, e(i)
                    };
                    return "string" != typeof t && (i = e, e = t, t = void 0), e && !1 !== t && this.queue(t || "fx", []), this.each(function() {
                        var e = !0,
                            r = null != t && t + "queueHooks",
                            o = vt.timers,
                            a = kt.get(this);
                        if (r) a[r] && a[r].stop && n(a[r]);
                        else
                            for (r in a) a[r] && a[r].stop && _e.test(r) && n(a[r]);
                        for (r = o.length; r--;) o[r].elem !== this || null != t && o[r].queue !== t || (o[r].anim.stop(i), e = !1, o.splice(r, 1));
                        !e && i || vt.dequeue(this, t)
                    })
                },
                finish: function(t) {
                    return !1 !== t && (t = t || "fx"), this.each(function() {
                        var e, i = kt.get(this),
                            n = i[t + "queue"],
                            r = i[t + "queueHooks"],
                            o = vt.timers,
                            a = n ? n.length : 0;
                        for (i.finish = !0, vt.queue(this, t, []), r && r.stop && r.stop.call(this, !0), e = o.length; e--;) o[e].elem === this && o[e].queue === t && (o[e].anim.stop(!0), o.splice(e, 1));
                        for (e = 0; e < a; e++) n[e] && n[e].finish && n[e].finish.call(this);
                        delete i.finish
                    })
                }
            }), vt.each(["toggle", "show", "hide"], function(t, e) {
                var i = vt.fn[e];
                vt.fn[e] = function(t, n, r) {
                    return null == t || "boolean" == typeof t ? i.apply(this, arguments) : this.animate(X(e, !0), t, n, r)
                }
            }), vt.each({
                slideDown: X("show"),
                slideUp: X("hide"),
                slideToggle: X("toggle"),
                fadeIn: {
                    opacity: "show"
                },
                fadeOut: {
                    opacity: "hide"
                },
                fadeToggle: {
                    opacity: "toggle"
                }
            }, function(t, e) {
                vt.fn[t] = function(t, i, n) {
                    return this.animate(e, t, i, n)
                }
            }), vt.timers = [], vt.fx.tick = function() {
                var t, e = 0,
                    i = vt.timers;
                for (ge = vt.now(); e < i.length; e++)(t = i[e])() || i[e] !== t || i.splice(e--, 1);
                i.length || vt.fx.stop(), ge = void 0
            }, vt.fx.timer = function(t) {
                vt.timers.push(t), vt.fx.start()
            }, vt.fx.interval = 13, vt.fx.start = function() {
                ve || (ve = !0, V())
            }, vt.fx.stop = function() {
                ve = null
            }, vt.fx.speeds = {
                slow: 600,
                fast: 200,
                _default: 400
            }, vt.fn.delay = function(t, e) {
                return t = vt.fx ? vt.fx.speeds[t] || t : t, e = e || "fx", this.queue(e, function(e, n) {
                    var r = i.setTimeout(e, t);
                    n.stop = function() {
                        i.clearTimeout(r)
                    }
                })
            },
            function() {
                var t = ot.createElement("input"),
                    e = ot.createElement("select").appendChild(ot.createElement("option"));
                t.type = "checkbox", gt.checkOn = "" !== t.value, gt.optSelected = e.selected, (t = ot.createElement("input")).value = "t", t.type = "radio", gt.radioValue = "t" === t.value
            }();
        var xe, be = vt.expr.attrHandle;
        vt.fn.extend({
            attr: function(t, e) {
                return Nt(this, vt.attr, t, e, arguments.length > 1)
            },
            removeAttr: function(t) {
                return this.each(function() {
                    vt.removeAttr(this, t)
                })
            }
        }), vt.extend({
            attr: function(t, e, i) {
                var n, r, o = t.nodeType;
                if (3 !== o && 8 !== o && 2 !== o) return void 0 === t.getAttribute ? vt.prop(t, e, i) : (1 === o && vt.isXMLDoc(t) || (r = vt.attrHooks[e.toLowerCase()] || (vt.expr.match.bool.test(e) ? xe : void 0)), void 0 !== i ? null === i ? void vt.removeAttr(t, e) : r && "set" in r && void 0 !== (n = r.set(t, i, e)) ? n : (t.setAttribute(e, i + ""), i) : r && "get" in r && null !== (n = r.get(t, e)) ? n : (n = vt.find.attr(t, e), null == n ? void 0 : n))
            },
            attrHooks: {
                type: {
                    set: function(t, e) {
                        if (!gt.radioValue && "radio" === e && l(t, "input")) {
                            var i = t.value;
                            return t.setAttribute("type", e), i && (t.value = i), e
                        }
                    }
                }
            },
            removeAttr: function(t, e) {
                var i, n = 0,
                    r = e && e.match(Ot);
                if (r && 1 === t.nodeType)
                    for (; i = r[n++];) t.removeAttribute(i)
            }
        }), xe = {
            set: function(t, e, i) {
                return !1 === e ? vt.removeAttr(t, i) : t.setAttribute(i, i), i
            }
        }, vt.each(vt.expr.match.bool.source.match(/\w+/g), function(t, e) {
            var i = be[e] || vt.find.attr;
            be[e] = function(t, e, n) {
                var r, o, a = e.toLowerCase();
                return n || (o = be[a], be[a] = r, r = null != i(t, e, n) ? a : null, be[a] = o), r
            }
        });
        var we = /^(?:input|select|textarea|button)$/i,
            Te = /^(?:a|area)$/i;
        vt.fn.extend({
            prop: function(t, e) {
                return Nt(this, vt.prop, t, e, arguments.length > 1)
            },
            removeProp: function(t) {
                return this.each(function() {
                    delete this[vt.propFix[t] || t]
                })
            }
        }), vt.extend({
            prop: function(t, e, i) {
                var n, r, o = t.nodeType;
                if (3 !== o && 8 !== o && 2 !== o) return 1 === o && vt.isXMLDoc(t) || (e = vt.propFix[e] || e, r = vt.propHooks[e]), void 0 !== i ? r && "set" in r && void 0 !== (n = r.set(t, i, e)) ? n : t[e] = i : r && "get" in r && null !== (n = r.get(t, e)) ? n : t[e]
            },
            propHooks: {
                tabIndex: {
                    get: function(t) {
                        var e = vt.find.attr(t, "tabindex");
                        return e ? parseInt(e, 10) : we.test(t.nodeName) || Te.test(t.nodeName) && t.href ? 0 : -1
                    }
                }
            },
            propFix: {
                for: "htmlFor",
                class: "className"
            }
        }), gt.optSelected || (vt.propHooks.selected = {
            get: function(t) {
                var e = t.parentNode;
                return e && e.parentNode && e.parentNode.selectedIndex, null
            },
            set: function(t) {
                var e = t.parentNode;
                e && (e.selectedIndex, e.parentNode && e.parentNode.selectedIndex)
            }
        }), vt.each(["tabIndex", "readOnly", "maxLength", "cellSpacing", "cellPadding", "rowSpan", "colSpan", "useMap", "frameBorder", "contentEditable"], function() {
            vt.propFix[this.toLowerCase()] = this
        }), vt.fn.extend({
            addClass: function(t) {
                var e, i, n, r, o, a, s, l = 0;
                if (vt.isFunction(t)) return this.each(function(e) {
                    vt(this).addClass(t.call(this, e, J(this)))
                });
                if ("string" == typeof t && t)
                    for (e = t.match(Ot) || []; i = this[l++];)
                        if (r = J(i), n = 1 === i.nodeType && " " + Z(r) + " ") {
                            for (a = 0; o = e[a++];) n.indexOf(" " + o + " ") < 0 && (n += o + " ");
                            r !== (s = Z(n)) && i.setAttribute("class", s)
                        } return this
            },
            removeClass: function(t) {
                var e, i, n, r, o, a, s, l = 0;
                if (vt.isFunction(t)) return this.each(function(e) {
                    vt(this).removeClass(t.call(this, e, J(this)))
                });
                if (!arguments.length) return this.attr("class", "");
                if ("string" == typeof t && t)
                    for (e = t.match(Ot) || []; i = this[l++];)
                        if (r = J(i), n = 1 === i.nodeType && " " + Z(r) + " ") {
                            for (a = 0; o = e[a++];)
                                for (; n.indexOf(" " + o + " ") > -1;) n = n.replace(" " + o + " ", " ");
                            r !== (s = Z(n)) && i.setAttribute("class", s)
                        } return this
            },
            toggleClass: function(t, e) {
                var i = typeof t;
                return "boolean" == typeof e && "string" === i ? e ? this.addClass(t) : this.removeClass(t) : vt.isFunction(t) ? this.each(function(i) {
                    vt(this).toggleClass(t.call(this, i, J(this), e), e)
                }) : this.each(function() {
                    var e, n, r, o;
                    if ("string" === i)
                        for (n = 0, r = vt(this), o = t.match(Ot) || []; e = o[n++];) r.hasClass(e) ? r.removeClass(e) : r.addClass(e);
                    else void 0 !== t && "boolean" !== i || ((e = J(this)) && kt.set(this, "__className__", e), this.setAttribute && this.setAttribute("class", e || !1 === t ? "" : kt.get(this, "__className__") || ""))
                })
            },
            hasClass: function(t) {
                var e, i, n = 0;
                for (e = " " + t + " "; i = this[n++];)
                    if (1 === i.nodeType && (" " + Z(J(i)) + " ").indexOf(e) > -1) return !0;
                return !1
            }
        });
        var Se = /\r/g;
        vt.fn.extend({
            val: function(t) {
                var e, i, n, r = this[0]; {
                    if (arguments.length) return n = vt.isFunction(t), this.each(function(i) {
                        var r;
                        1 === this.nodeType && (null == (r = n ? t.call(this, i, vt(this).val()) : t) ? r = "" : "number" == typeof r ? r += "" : Array.isArray(r) && (r = vt.map(r, function(t) {
                            return null == t ? "" : t + ""
                        })), (e = vt.valHooks[this.type] || vt.valHooks[this.nodeName.toLowerCase()]) && "set" in e && void 0 !== e.set(this, r, "value") || (this.value = r))
                    });
                    if (r) return (e = vt.valHooks[r.type] || vt.valHooks[r.nodeName.toLowerCase()]) && "get" in e && void 0 !== (i = e.get(r, "value")) ? i : (i = r.value, "string" == typeof i ? i.replace(Se, "") : null == i ? "" : i)
                }
            }
        }), vt.extend({
            valHooks: {
                option: {
                    get: function(t) {
                        var e = vt.find.attr(t, "value");
                        return null != e ? e : Z(vt.text(t))
                    }
                },
                select: {
                    get: function(t) {
                        var e, i, n, r = t.options,
                            o = t.selectedIndex,
                            a = "select-one" === t.type,
                            s = a ? null : [],
                            c = a ? o + 1 : r.length;
                        for (n = o < 0 ? c : a ? o : 0; n < c; n++)
                            if (((i = r[n]).selected || n === o) && !i.disabled && (!i.parentNode.disabled || !l(i.parentNode, "optgroup"))) {
                                if (e = vt(i).val(), a) return e;
                                s.push(e)
                            } return s
                    },
                    set: function(t, e) {
                        for (var i, n, r = t.options, o = vt.makeArray(e), a = r.length; a--;)((n = r[a]).selected = vt.inArray(vt.valHooks.option.get(n), o) > -1) && (i = !0);
                        return i || (t.selectedIndex = -1), o
                    }
                }
            }
        }), vt.each(["radio", "checkbox"], function() {
            vt.valHooks[this] = {
                set: function(t, e) {
                    if (Array.isArray(e)) return t.checked = vt.inArray(vt(t).val(), e) > -1
                }
            }, gt.checkOn || (vt.valHooks[this].get = function(t) {
                return null === t.getAttribute("value") ? "on" : t.value
            })
        });
        var Ee = /^(?:focusinfocus|focusoutblur)$/;
        vt.extend(vt.event, {
            trigger: function(t, e, n, r) {
                var o, a, s, l, c, u, h, d = [n || ot],
                    p = pt.call(t, "type") ? t.type : t,
                    f = pt.call(t, "namespace") ? t.namespace.split(".") : [];
                if (a = s = n = n || ot, 3 !== n.nodeType && 8 !== n.nodeType && !Ee.test(p + vt.event.triggered) && (p.indexOf(".") > -1 && (p = (f = p.split(".")).shift(), f.sort()), c = p.indexOf(":") < 0 && "on" + p, t = t[vt.expando] ? t : new vt.Event(p, "object" == typeof t && t), t.isTrigger = r ? 2 : 3, t.namespace = f.join("."), t.rnamespace = t.namespace ? new RegExp("(^|\\.)" + f.join("\\.(?:.*\\.|)") + "(\\.|$)") : null, t.result = void 0, t.target || (t.target = n), e = null == e ? [t] : vt.makeArray(e, [t]), h = vt.event.special[p] || {}, r || !h.trigger || !1 !== h.trigger.apply(n, e))) {
                    if (!r && !h.noBubble && !vt.isWindow(n)) {
                        for (l = h.delegateType || p, Ee.test(l + p) || (a = a.parentNode); a; a = a.parentNode) d.push(a), s = a;
                        s === (n.ownerDocument || ot) && d.push(s.defaultView || s.parentWindow || i)
                    }
                    for (o = 0;
                        (a = d[o++]) && !t.isPropagationStopped();) t.type = o > 1 ? l : h.bindType || p, (u = (kt.get(a, "events") || {})[t.type] && kt.get(a, "handle")) && u.apply(a, e), (u = c && a[c]) && u.apply && Ft(a) && (t.result = u.apply(a, e), !1 === t.result && t.preventDefault());
                    return t.type = p, r || t.isDefaultPrevented() || h._default && !1 !== h._default.apply(d.pop(), e) || !Ft(n) || c && vt.isFunction(n[p]) && !vt.isWindow(n) && ((s = n[c]) && (n[c] = null), vt.event.triggered = p, n[p](), vt.event.triggered = void 0, s && (n[c] = s)), t.result
                }
            },
            simulate: function(t, e, i) {
                var n = vt.extend(new vt.Event, i, {
                    type: t,
                    isSimulated: !0
                });
                vt.event.trigger(n, null, e)
            }
        }), vt.fn.extend({
            trigger: function(t, e) {
                return this.each(function() {
                    vt.event.trigger(t, e, this)
                })
            },
            triggerHandler: function(t, e) {
                var i = this[0];
                if (i) return vt.event.trigger(t, e, i, !0)
            }
        }), vt.each("blur focus focusin focusout resize scroll click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup contextmenu".split(" "), function(t, e) {
            vt.fn[e] = function(t, i) {
                return arguments.length > 0 ? this.on(e, null, t, i) : this.trigger(e)
            }
        }), vt.fn.extend({
            hover: function(t, e) {
                return this.mouseenter(t).mouseleave(e || t)
            }
        }), gt.focusin = "onfocusin" in i, gt.focusin || vt.each({
            focus: "focusin",
            blur: "focusout"
        }, function(t, e) {
            var i = function(t) {
                vt.event.simulate(e, t.target, vt.event.fix(t))
            };
            vt.event.special[e] = {
                setup: function() {
                    var n = this.ownerDocument || this,
                        r = kt.access(n, e);
                    r || n.addEventListener(t, i, !0), kt.access(n, e, (r || 0) + 1)
                },
                teardown: function() {
                    var n = this.ownerDocument || this,
                        r = kt.access(n, e) - 1;
                    r ? kt.access(n, e, r) : (n.removeEventListener(t, i, !0), kt.remove(n, e))
                }
            }
        });
        var Me = i.location,
            Ae = vt.now(),
            Le = /\?/;
        vt.parseXML = function(t) {
            var e;
            if (!t || "string" != typeof t) return null;
            try {
                e = (new i.DOMParser).parseFromString(t, "text/xml")
            } catch (t) {
                e = void 0
            }
            return e && !e.getElementsByTagName("parsererror").length || vt.error("Invalid XML: " + t), e
        };
        var Ce = /\[\]$/,
            Pe = /\r?\n/g,
            Re = /^(?:submit|button|image|reset|file)$/i,
            Oe = /^(?:input|select|textarea|keygen)/i;
        vt.param = function(t, e) {
            var i, n = [],
                r = function(t, e) {
                    var i = vt.isFunction(e) ? e() : e;
                    n[n.length] = encodeURIComponent(t) + "=" + encodeURIComponent(null == i ? "" : i)
                };
            if (Array.isArray(t) || t.jquery && !vt.isPlainObject(t)) vt.each(t, function() {
                r(this.name, this.value)
            });
            else
                for (i in t) $(i, t[i], e, r);
            return n.join("&")
        }, vt.fn.extend({
            serialize: function() {
                return vt.param(this.serializeArray())
            },
            serializeArray: function() {
                return this.map(function() {
                    var t = vt.prop(this, "elements");
                    return t ? vt.makeArray(t) : this
                }).filter(function() {
                    var t = this.type;
                    return this.name && !vt(this).is(":disabled") && Oe.test(this.nodeName) && !Re.test(t) && (this.checked || !qt.test(t))
                }).map(function(t, e) {
                    var i = vt(this).val();
                    return null == i ? null : Array.isArray(i) ? vt.map(i, function(t) {
                        return {
                            name: e.name,
                            value: t.replace(Pe, "\r\n")
                        }
                    }) : {
                        name: e.name,
                        value: i.replace(Pe, "\r\n")
                    }
                }).get()
            }
        });
        var Ie = /%20/g,
            De = /#.*$/,
            Ne = /([?&])_=[^&]*/,
            Fe = /^(.*?):[ \t]*([^\r\n]*)$/gm,
            ke = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
            Ue = /^(?:GET|HEAD)$/,
            Be = /^\/\//,
            ze = {},
            je = {},
            He = "*/".concat("*"),
            Ge = ot.createElement("a");
        Ge.href = Me.href, vt.extend({
            active: 0,
            lastModified: {},
            etag: {},
            ajaxSettings: {
                url: Me.href,
                type: "GET",
                isLocal: ke.test(Me.protocol),
                global: !0,
                processData: !0,
                async: !0,
                contentType: "application/x-www-form-urlencoded; charset=UTF-8",
                accepts: {
                    "*": He,
                    text: "text/plain",
                    html: "text/html",
                    xml: "application/xml, text/xml",
                    json: "application/json, text/javascript"
                },
                contents: {
                    xml: /\bxml\b/,
                    html: /\bhtml/,
                    json: /\bjson\b/
                },
                responseFields: {
                    xml: "responseXML",
                    text: "responseText",
                    json: "responseJSON"
                },
                converters: {
                    "* text": String,
                    "text html": !0,
                    "text json": JSON.parse,
                    "text xml": vt.parseXML
                },
                flatOptions: {
                    url: !0,
                    context: !0
                }
            },
            ajaxSetup: function(t, e) {
                return e ? et(et(t, vt.ajaxSettings), e) : et(vt.ajaxSettings, t)
            },
            ajaxPrefilter: K(ze),
            ajaxTransport: K(je),
            ajax: function(t, e) {
                function n(t, e, n, s) {
                    var c, d, p, x, b, w = e;
                    u || (u = !0, l && i.clearTimeout(l), r = void 0, a = s || "", T.readyState = t > 0 ? 4 : 0, c = t >= 200 && t < 300 || 304 === t, n && (x = it(f, T, n)), x = nt(f, x, T, c), c ? (f.ifModified && ((b = T.getResponseHeader("Last-Modified")) && (vt.lastModified[o] = b), (b = T.getResponseHeader("etag")) && (vt.etag[o] = b)), 204 === t || "HEAD" === f.type ? w = "nocontent" : 304 === t ? w = "notmodified" : (w = x.state, d = x.data, c = !(p = x.error))) : (p = w, !t && w || (w = "error", t < 0 && (t = 0))), T.status = t, T.statusText = (e || w) + "", c ? v.resolveWith(m, [d, w, T]) : v.rejectWith(m, [T, w, p]), T.statusCode(_), _ = void 0, h && g.trigger(c ? "ajaxSuccess" : "ajaxError", [T, f, c ? d : p]), y.fireWith(m, [T, w]), h && (g.trigger("ajaxComplete", [T, f]), --vt.active || vt.event.trigger("ajaxStop")))
                }
                "object" == typeof t && (e = t, t = void 0), e = e || {};
                var r, o, a, s, l, c, u, h, d, p, f = vt.ajaxSetup({}, e),
                    m = f.context || f,
                    g = f.context && (m.nodeType || m.jquery) ? vt(m) : vt.event,
                    v = vt.Deferred(),
                    y = vt.Callbacks("once memory"),
                    _ = f.statusCode || {},
                    x = {},
                    b = {},
                    w = "canceled",
                    T = {
                        readyState: 0,
                        getResponseHeader: function(t) {
                            var e;
                            if (u) {
                                if (!s)
                                    for (s = {}; e = Fe.exec(a);) s[e[1].toLowerCase()] = e[2];
                                e = s[t.toLowerCase()]
                            }
                            return null == e ? null : e
                        },
                        getAllResponseHeaders: function() {
                            return u ? a : null
                        },
                        setRequestHeader: function(t, e) {
                            return null == u && (t = b[t.toLowerCase()] = b[t.toLowerCase()] || t, x[t] = e), this
                        },
                        overrideMimeType: function(t) {
                            return null == u && (f.mimeType = t), this
                        },
                        statusCode: function(t) {
                            var e;
                            if (t)
                                if (u) T.always(t[T.status]);
                                else
                                    for (e in t) _[e] = [_[e], t[e]];
                            return this
                        },
                        abort: function(t) {
                            var e = t || w;
                            return r && r.abort(e), n(0, e), this
                        }
                    };
                if (v.promise(T), f.url = ((t || f.url || Me.href) + "").replace(Be, Me.protocol + "//"), f.type = e.method || e.type || f.method || f.type, f.dataTypes = (f.dataType || "*").toLowerCase().match(Ot) || [""], null == f.crossDomain) {
                    c = ot.createElement("a");
                    try {
                        c.href = f.url, c.href = c.href, f.crossDomain = Ge.protocol + "//" + Ge.host != c.protocol + "//" + c.host
                    } catch (t) {
                        f.crossDomain = !0
                    }
                }
                if (f.data && f.processData && "string" != typeof f.data && (f.data = vt.param(f.data, f.traditional)), tt(ze, f, e, T), u) return T;
                (h = vt.event && f.global) && 0 == vt.active++ && vt.event.trigger("ajaxStart"), f.type = f.type.toUpperCase(), f.hasContent = !Ue.test(f.type), o = f.url.replace(De, ""), f.hasContent ? f.data && f.processData && 0 === (f.contentType || "").indexOf("application/x-www-form-urlencoded") && (f.data = f.data.replace(Ie, "+")) : (p = f.url.slice(o.length), f.data && (o += (Le.test(o) ? "&" : "?") + f.data, delete f.data), !1 === f.cache && (o = o.replace(Ne, "$1"), p = (Le.test(o) ? "&" : "?") + "_=" + Ae++ + p), f.url = o + p), f.ifModified && (vt.lastModified[o] && T.setRequestHeader("If-Modified-Since", vt.lastModified[o]), vt.etag[o] && T.setRequestHeader("If-None-Match", vt.etag[o])), (f.data && f.hasContent && !1 !== f.contentType || e.contentType) && T.setRequestHeader("Content-Type", f.contentType), T.setRequestHeader("Accept", f.dataTypes[0] && f.accepts[f.dataTypes[0]] ? f.accepts[f.dataTypes[0]] + ("*" !== f.dataTypes[0] ? ", " + He + "; q=0.01" : "") : f.accepts["*"]);
                for (d in f.headers) T.setRequestHeader(d, f.headers[d]);
                if (f.beforeSend && (!1 === f.beforeSend.call(m, T, f) || u)) return T.abort();
                if (w = "abort", y.add(f.complete), T.done(f.success), T.fail(f.error), r = tt(je, f, e, T)) {
                    if (T.readyState = 1, h && g.trigger("ajaxSend", [T, f]), u) return T;
                    f.async && f.timeout > 0 && (l = i.setTimeout(function() {
                        T.abort("timeout")
                    }, f.timeout));
                    try {
                        u = !1, r.send(x, n)
                    } catch (t) {
                        if (u) throw t;
                        n(-1, t)
                    }
                } else n(-1, "No Transport");
                return T
            },
            getJSON: function(t, e, i) {
                return vt.get(t, e, i, "json")
            },
            getScript: function(t, e) {
                return vt.get(t, void 0, e, "script")
            }
        }), vt.each(["get", "post"], function(t, e) {
            vt[e] = function(t, i, n, r) {
                return vt.isFunction(i) && (r = r || n, n = i, i = void 0), vt.ajax(vt.extend({
                    url: t,
                    type: e,
                    dataType: r,
                    data: i,
                    success: n
                }, vt.isPlainObject(t) && t))
            }
        }), vt._evalUrl = function(t) {
            return vt.ajax({
                url: t,
                type: "GET",
                dataType: "script",
                cache: !0,
                async: !1,
                global: !1,
                throws: !0
            })
        }, vt.fn.extend({
            wrapAll: function(t) {
                var e;
                return this[0] && (vt.isFunction(t) && (t = t.call(this[0])), e = vt(t, this[0].ownerDocument).eq(0).clone(!0), this[0].parentNode && e.insertBefore(this[0]), e.map(function() {
                    for (var t = this; t.firstElementChild;) t = t.firstElementChild;
                    return t
                }).append(this)), this
            },
            wrapInner: function(t) {
                return vt.isFunction(t) ? this.each(function(e) {
                    vt(this).wrapInner(t.call(this, e))
                }) : this.each(function() {
                    var e = vt(this),
                        i = e.contents();
                    i.length ? i.wrapAll(t) : e.append(t)
                })
            },
            wrap: function(t) {
                var e = vt.isFunction(t);
                return this.each(function(i) {
                    vt(this).wrapAll(e ? t.call(this, i) : t)
                })
            },
            unwrap: function(t) {
                return this.parent(t).not("body").each(function() {
                    vt(this).replaceWith(this.childNodes)
                }), this
            }
        }), vt.expr.pseudos.hidden = function(t) {
            return !vt.expr.pseudos.visible(t)
        }, vt.expr.pseudos.visible = function(t) {
            return !!(t.offsetWidth || t.offsetHeight || t.getClientRects().length)
        }, vt.ajaxSettings.xhr = function() {
            try {
                return new i.XMLHttpRequest
            } catch (t) {}
        };
        var Ve = {
                0: 200,
                1223: 204
            },
            We = vt.ajaxSettings.xhr();
        gt.cors = !!We && "withCredentials" in We, gt.ajax = We = !!We, vt.ajaxTransport(function(t) {
            var e, n;
            if (gt.cors || We && !t.crossDomain) return {
                send: function(r, o) {
                    var a, s = t.xhr();
                    if (s.open(t.type, t.url, t.async, t.username, t.password), t.xhrFields)
                        for (a in t.xhrFields) s[a] = t.xhrFields[a];
                    t.mimeType && s.overrideMimeType && s.overrideMimeType(t.mimeType), t.crossDomain || r["X-Requested-With"] || (r["X-Requested-With"] = "XMLHttpRequest");
                    for (a in r) s.setRequestHeader(a, r[a]);
                    e = function(t) {
                        return function() {
                            e && (e = n = s.onload = s.onerror = s.onabort = s.onreadystatechange = null, "abort" === t ? s.abort() : "error" === t ? "number" != typeof s.status ? o(0, "error") : o(s.status, s.statusText) : o(Ve[s.status] || s.status, s.statusText, "text" !== (s.responseType || "text") || "string" != typeof s.responseText ? {
                                binary: s.response
                            } : {
                                text: s.responseText
                            }, s.getAllResponseHeaders()))
                        }
                    }, s.onload = e(), n = s.onerror = e("error"), void 0 !== s.onabort ? s.onabort = n : s.onreadystatechange = function() {
                        4 === s.readyState && i.setTimeout(function() {
                            e && n()
                        })
                    }, e = e("abort");
                    try {
                        s.send(t.hasContent && t.data || null)
                    } catch (t) {
                        if (e) throw t
                    }
                },
                abort: function() {
                    e && e()
                }
            }
        }), vt.ajaxPrefilter(function(t) {
            t.crossDomain && (t.contents.script = !1)
        }), vt.ajaxSetup({
            accepts: {
                script: "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"
            },
            contents: {
                script: /\b(?:java|ecma)script\b/
            },
            converters: {
                "text script": function(t) {
                    return vt.globalEval(t), t
                }
            }
        }), vt.ajaxPrefilter("script", function(t) {
            void 0 === t.cache && (t.cache = !1), t.crossDomain && (t.type = "GET")
        }), vt.ajaxTransport("script", function(t) {
            if (t.crossDomain) {
                var e, i;
                return {
                    send: function(n, r) {
                        e = vt("<script>").prop({
                            charset: t.scriptCharset,
                            src: t.url
                        }).on("load error", i = function(t) {
                            e.remove(), i = null, t && r("error" === t.type ? 404 : 200, t.type)
                        }), ot.head.appendChild(e[0])
                    },
                    abort: function() {
                        i && i()
                    }
                }
            }
        });
        var Xe = [],
            qe = /(=)\?(?=&|$)|\?\?/;
        vt.ajaxSetup({
            jsonp: "callback",
            jsonpCallback: function() {
                var t = Xe.pop() || vt.expando + "_" + Ae++;
                return this[t] = !0, t
            }
        }), vt.ajaxPrefilter("json jsonp", function(t, e, n) {
            var r, o, a, s = !1 !== t.jsonp && (qe.test(t.url) ? "url" : "string" == typeof t.data && 0 === (t.contentType || "").indexOf("application/x-www-form-urlencoded") && qe.test(t.data) && "data");
            if (s || "jsonp" === t.dataTypes[0]) return r = t.jsonpCallback = vt.isFunction(t.jsonpCallback) ? t.jsonpCallback() : t.jsonpCallback, s ? t[s] = t[s].replace(qe, "$1" + r) : !1 !== t.jsonp && (t.url += (Le.test(t.url) ? "&" : "?") + t.jsonp + "=" + r), t.converters["script json"] = function() {
                return a || vt.error(r + " was not called"), a[0]
            }, t.dataTypes[0] = "json", o = i[r], i[r] = function() {
                a = arguments
            }, n.always(function() {
                void 0 === o ? vt(i).removeProp(r) : i[r] = o, t[r] && (t.jsonpCallback = e.jsonpCallback, Xe.push(r)), a && vt.isFunction(o) && o(a[0]), a = o = void 0
            }), "script"
        }), gt.createHTMLDocument = function() {
            var t = ot.implementation.createHTMLDocument("").body;
            return t.innerHTML = "<form></form><form></form>", 2 === t.childNodes.length
        }(), vt.parseHTML = function(t, e, i) {
            if ("string" != typeof t) return [];
            "boolean" == typeof e && (i = e, e = !1);
            var n, r, o;
            return e || (gt.createHTMLDocument ? ((n = (e = ot.implementation.createHTMLDocument("")).createElement("base")).href = ot.location.href, e.head.appendChild(n)) : e = ot), r = Mt.exec(t), o = !i && [], r ? [e.createElement(r[1])] : (r = S([t], e, o), o && o.length && vt(o).remove(), vt.merge([], r.childNodes))
        }, vt.fn.load = function(t, e, i) {
            var n, r, o, a = this,
                s = t.indexOf(" ");
            return s > -1 && (n = Z(t.slice(s)), t = t.slice(0, s)), vt.isFunction(e) ? (i = e, e = void 0) : e && "object" == typeof e && (r = "POST"), a.length > 0 && vt.ajax({
                url: t,
                type: r || "GET",
                dataType: "html",
                data: e
            }).done(function(t) {
                o = arguments, a.html(n ? vt("<div>").append(vt.parseHTML(t)).find(n) : t)
            }).always(i && function(t, e) {
                a.each(function() {
                    i.apply(this, o || [t.responseText, e, t])
                })
            }), this
        }, vt.each(["ajaxStart", "ajaxStop", "ajaxComplete", "ajaxError", "ajaxSuccess", "ajaxSend"], function(t, e) {
            vt.fn[e] = function(t) {
                return this.on(e, t)
            }
        }), vt.expr.pseudos.animated = function(t) {
            return vt.grep(vt.timers, function(e) {
                return t === e.elem
            }).length
        }, vt.offset = {
            setOffset: function(t, e, i) {
                var n, r, o, a, s, l, c = vt.css(t, "position"),
                    u = vt(t),
                    h = {};
                "static" === c && (t.style.position = "relative"), s = u.offset(), o = vt.css(t, "top"), l = vt.css(t, "left"), ("absolute" === c || "fixed" === c) && (o + l).indexOf("auto") > -1 ? (a = (n = u.position()).top, r = n.left) : (a = parseFloat(o) || 0, r = parseFloat(l) || 0), vt.isFunction(e) && (e = e.call(t, i, vt.extend({}, s))), null != e.top && (h.top = e.top - s.top + a), null != e.left && (h.left = e.left - s.left + r), "using" in e ? e.using.call(t, h) : u.css(h)
            }
        }, vt.fn.extend({
            offset: function(t) {
                if (arguments.length) return void 0 === t ? this : this.each(function(e) {
                    vt.offset.setOffset(this, t, e)
                });
                var e, i, n, r, o = this[0];
                if (o) return o.getClientRects().length ? (n = o.getBoundingClientRect(), e = o.ownerDocument, i = e.documentElement, r = e.defaultView, {
                    top: n.top + r.pageYOffset - i.clientTop,
                    left: n.left + r.pageXOffset - i.clientLeft
                }) : {
                    top: 0,
                    left: 0
                }
            },
            position: function() {
                if (this[0]) {
                    var t, e, i = this[0],
                        n = {
                            top: 0,
                            left: 0
                        };
                    return "fixed" === vt.css(i, "position") ? e = i.getBoundingClientRect() : (t = this.offsetParent(), e = this.offset(), l(t[0], "html") || (n = t.offset()), n = {
                        top: n.top + vt.css(t[0], "borderTopWidth", !0),
                        left: n.left + vt.css(t[0], "borderLeftWidth", !0)
                    }), {
                        top: e.top - n.top - vt.css(i, "marginTop", !0),
                        left: e.left - n.left - vt.css(i, "marginLeft", !0)
                    }
                }
            },
            offsetParent: function() {
                return this.map(function() {
                    for (var t = this.offsetParent; t && "static" === vt.css(t, "position");) t = t.offsetParent;
                    return t || $t
                })
            }
        }), vt.each({
            scrollLeft: "pageXOffset",
            scrollTop: "pageYOffset"
        }, function(t, e) {
            var i = "pageYOffset" === e;
            vt.fn[t] = function(n) {
                return Nt(this, function(t, n, r) {
                    var o;
                    if (vt.isWindow(t) ? o = t : 9 === t.nodeType && (o = t.defaultView), void 0 === r) return o ? o[e] : t[n];
                    o ? o.scrollTo(i ? o.pageXOffset : r, i ? r : o.pageYOffset) : t[n] = r
                }, t, n, arguments.length)
            }
        }), vt.each(["top", "left"], function(t, e) {
            vt.cssHooks[e] = k(gt.pixelPosition, function(t, i) {
                if (i) return i = F(t, e), le.test(i) ? vt(t).position()[e] + "px" : i
            })
        }), vt.each({
            Height: "height",
            Width: "width"
        }, function(t, e) {
            vt.each({
                padding: "inner" + t,
                content: e,
                "": "outer" + t
            }, function(i, n) {
                vt.fn[n] = function(r, o) {
                    var a = arguments.length && (i || "boolean" != typeof r),
                        s = i || (!0 === r || !0 === o ? "margin" : "border");
                    return Nt(this, function(e, i, r) {
                        var o;
                        return vt.isWindow(e) ? 0 === n.indexOf("outer") ? e["inner" + t] : e.document.documentElement["client" + t] : 9 === e.nodeType ? (o = e.documentElement, Math.max(e.body["scroll" + t], o["scroll" + t], e.body["offset" + t], o["offset" + t], o["client" + t])) : void 0 === r ? vt.css(e, i, s) : vt.style(e, i, r, s)
                    }, e, a ? r : void 0, a)
                }
            })
        }), vt.fn.extend({
            bind: function(t, e, i) {
                return this.on(t, null, e, i)
            },
            unbind: function(t, e) {
                return this.off(t, null, e)
            },
            delegate: function(t, e, i, n) {
                return this.on(e, t, i, n)
            },
            undelegate: function(t, e, i) {
                return 1 === arguments.length ? this.off(t, "**") : this.off(e, t || "**", i)
            }
        }), vt.holdReady = function(t) {
            t ? vt.readyWait++ : vt.ready(!0)
        }, vt.isArray = Array.isArray, vt.parseJSON = JSON.parse, vt.nodeName = l, n = [], void 0 !== (r = function() {
            return vt
        }.apply(e, n)) && (t.exports = r);
        var Ye = i.jQuery,
            Qe = i.$;
        return vt.noConflict = function(t) {
            return i.$ === vt && (i.$ = Qe), t && i.jQuery === vt && (i.jQuery = Ye), vt
        }, o || (i.jQuery = i.$ = vt), vt
    })
}, function(t, e, i) {
    var n, r;
    "function" == typeof Symbol && Symbol.iterator;
    ! function(o, a) {
        "use strict";
        n = [i(8)], void 0 !== (r = function(t) {
            return a(t, o, o.document, o.Math)
        }.apply(e, n)) && (t.exports = r)
    }("undefined" != typeof window ? window : void 0, function(t, e, i, n, r) {
        "use strict";
        var o = "fullpage-wrapper",
            a = "." + o,
            s = "fp-responsive",
            l = "fp-notransition",
            c = "fp-destroyed",
            u = "fp-enabled",
            h = "fp-viewing",
            d = "active",
            p = "." + d,
            f = "fp-completely",
            m = "." + f,
            g = "fp-section",
            v = "." + g,
            y = v + p,
            _ = v + ":first",
            x = v + ":last",
            b = "fp-tableCell",
            w = "." + b,
            T = "fp-auto-height",
            S = "fp-normal-scroll",
            E = "fp-nav",
            M = "#" + E,
            A = "fp-tooltip",
            L = "." + A,
            C = "fp-show-active",
            P = "fp-slide",
            R = "." + P,
            O = R + p,
            I = "fp-slides",
            D = "." + I,
            N = "fp-slidesContainer",
            F = "." + N,
            k = "fp-table",
            U = "fp-slidesNav",
            B = "." + U,
            z = B + " a",
            j = ".fp-controlArrow",
            H = "fp-prev",
            G = "fp-controlArrow " + H,
            V = j + ("." + H),
            W = "fp-controlArrow fp-next",
            X = j + ".fp-next",
            q = t(e),
            Y = t(i);
        t.fn.fullpage = function(Q) {
            function Z(e, i) {
                e || Ve(0), Ye("autoScrolling", e, i);
                var n = t(y);
                Q.autoScrolling && !Q.scrollBar ? (Je.css({
                    overflow: "hidden",
                    height: "100%"
                }), J(Ti.recordHistory, "internal"), si.css({
                    "-ms-touch-action": "none",
                    "touch-action": "none"
                }), n.length && Ve(n.position().top)) : (Je.css({
                    overflow: "visible",
                    height: "initial"
                }), J(!1, "internal"), si.css({
                    "-ms-touch-action": "",
                    "touch-action": ""
                }), n.length && Je.scrollTop(n.position().top))
            }

            function J(t, e) {
                Ye("recordHistory", t, e)
            }

            function $(t, e) {
                Ye("scrollingSpeed", t, e)
            }

            function K(t, e) {
                Ye("fitToSection", t, e)
            }

            function tt(t) {
                t ? (ke(), Ue()) : (Fe(), Be())
            }

            function et(e, i) {
                void 0 !== i ? (i = i.replace(/ /g, "").split(","), t.each(i, function(t, i) {
                    Xe(e, i, "m")
                })) : (Xe(e, "all", "m"), e ? (tt(!0), ze()) : (tt(!1), je()))
            }

            function it(e, i) {
                void 0 !== i ? (i = i.replace(/ /g, "").split(","), t.each(i, function(t, i) {
                    Xe(e, i, "k")
                })) : (Xe(e, "all", "k"), Q.keyboardScrolling = e)
            }

            function nt() {
                var e = t(y).prev(v);
                e.length || !Q.loopTop && !Q.continuousVertical || (e = t(v).last()), e.length && Ut(e, null, !0)
            }

            function rt() {
                var e = t(y).next(v);
                e.length || !Q.loopBottom && !Q.continuousVertical || (e = t(v).first()), e.length && Ut(e, null, !1)
            }

            function ot(t, e) {
                $(0, "internal"), at(t, e), $(Ti.scrollingSpeed, "internal")
            }

            function at(t, e) {
                var i = Me(t);
                void 0 !== e ? Le(t, e) : i.length > 0 && Ut(i)
            }

            function st(t) {
                Nt("right", t)
            }

            function lt(t) {
                Nt("left", t)
            }

            function ct(e) {
                if (!si.hasClass(c)) {
                    ci = !0, li = q.height(), t(v).each(function() {
                        var e = t(this).find(D),
                            i = t(this).find(R);
                        Q.verticalCentered && t(this).find(w).css("height", Se(t(this)) + "px"), t(this).css("height", li + "px"), i.length > 1 && ue(e, e.find(O))
                    }), Q.scrollOverflow && fi.createScrollBarForAll();
                    var i = t(y).index(v);
                    i && ot(i + 1), ci = !1, t.isFunction(Q.afterResize) && e && Q.afterResize.call(si), t.isFunction(Q.afterReBuild) && !e && Q.afterReBuild.call(si)
                }
            }

            function ut(e) {
                var i = $e.hasClass(s);
                e ? i || (Z(!1, "internal"), K(!1, "internal"), t(M).hide(), $e.addClass(s), t.isFunction(Q.afterResponsive) && Q.afterResponsive.call(si, e)) : i && (Z(Ti.autoScrolling, "internal"), K(Ti.autoScrolling, "internal"), t(M).show(), $e.removeClass(s), t.isFunction(Q.afterResponsive) && Q.afterResponsive.call(si, e))
            }

            function ht() {
                var e = si.find(Q.sectionSelector);
                Q.anchors.length || (Q.anchors = e.filter("[data-anchor]").map(function() {
                    return t(this).data("anchor").toString()
                }).get()), Q.navigationTooltips.length || (Q.navigationTooltips = e.filter("[data-tooltip]").map(function() {
                    return t(this).data("tooltip").toString()
                }).get())
            }

            function dt() {
                si.css({
                    height: "100%",
                    position: "relative"
                }), si.addClass(o), t("html").addClass(u), li = q.height(), si.removeClass(c), gt(), t(v).each(function(e) {
                    var i = t(this),
                        n = i.find(R),
                        r = n.length;
                    ft(i, e), mt(i, e), r > 0 ? pt(i, n, r) : Q.verticalCentered && Te(i)
                }), Q.fixedElements && Q.css3 && t(Q.fixedElements).appendTo($e), Q.navigation && yt(), _t(), Q.scrollOverflow ? fi = Q.scrollOverflowHandler.init(Q) : wt()
            }

            function pt(e, i, n) {
                var r = 100 * n,
                    o = 100 / n;
                i.wrapAll('<div class="' + N + '" />'), i.parent().wrap('<div class="' + I + '" />'), e.find(F).css("width", r + "%"), n > 1 && (Q.controlArrows && vt(e), Q.slidesNavigation && Pe(e, n)), i.each(function(e) {
                    t(this).css("width", o + "%"), Q.verticalCentered && Te(t(this))
                });
                var a = e.find(O);
                a.length && (0 !== t(y).index(v) || 0 === t(y).index(v) && 0 !== a.index()) ? Ge(a, "internal") : i.eq(0).addClass(d)
            }

            function ft(e, i) {
                i || 0 !== t(y).length || e.addClass(d), ni = t(y), e.css("height", li + "px"), Q.paddingTop && e.css("padding-top", Q.paddingTop), Q.paddingBottom && e.css("padding-bottom", Q.paddingBottom), void 0 !== Q.sectionsColor[i] && e.css("background-color", Q.sectionsColor[i]), void 0 !== Q.anchors[i] && e.attr("data-anchor", Q.anchors[i])
            }

            function mt(e, i) {
                void 0 !== Q.anchors[i] && e.hasClass(d) && xe(Q.anchors[i], i), Q.menu && Q.css3 && t(Q.menu).closest(a).length && t(Q.menu).appendTo($e)
            }

            function gt() {
                si.find(Q.sectionSelector).addClass(g), si.find(Q.slideSelector).addClass(P)
            }

            function vt(t) {
                t.find(D).after('<div class="' + G + '"></div><div class="' + W + '"></div>'), "#fff" != Q.controlArrowColor && (t.find(X).css("border-color", "transparent transparent transparent " + Q.controlArrowColor), t.find(V).css("border-color", "transparent " + Q.controlArrowColor + " transparent transparent")), Q.loopHorizontal || t.find(V).hide()
            }

            function yt() {
                $e.append('<div id="' + E + '"><ul></ul></div>');
                var e = t(M);
                e.addClass(function() {
                    return Q.showActiveTooltip ? C + " " + Q.navigationPosition : Q.navigationPosition
                });
                for (var i = 0; i < t(v).length; i++) {
                    var n = "";
                    Q.anchors.length && (n = Q.anchors[i]);
                    var r = '<li><a href="#' + n + '"><span></span></a>',
                        o = Q.navigationTooltips[i];
                    void 0 !== o && "" !== o && (r += '<div class="' + A + " " + Q.navigationPosition + '">' + o + "</div>"), r += "</li>", e.find("ul").append(r)
                }
                t(M).css("margin-top", "-" + t(M).height() / 2 + "px"), t(M).find("li").eq(t(y).index(v)).find("a").addClass(d)
            }

            function _t() {
                si.find('iframe[src*="youtube.com/embed/"]').each(function() {
                    xt(t(this), "enablejsapi=1")
                })
            }

            function xt(t, e) {
                var i = t.attr("src");
                t.attr("src", i + bt(i) + e)
            }

            function bt(t) {
                return /\?/.test(t) ? "&" : "?"
            }

            function wt() {
                var e = t(y);
                e.addClass(f), Wt(e), Xt(e), Q.scrollOverflow && Q.scrollOverflowHandler.afterLoad(), Tt() && t.isFunction(Q.afterLoad) && Q.afterLoad.call(e, e.data("anchor"), e.index(v) + 1), t.isFunction(Q.afterRender) && Q.afterRender.call(si)
            }

            function Tt() {
                var t = Me($t().section);
                return !t.length || t.length && t.index() === ni.index()
            }

            function St() {
                var e;
                if (!Q.autoScrolling || Q.scrollBar) {
                    var n = q.scrollTop(),
                        r = At(n),
                        o = 0,
                        a = n + q.height() / 2,
                        s = $e.height() - q.height() === n,
                        l = i.querySelectorAll(v);
                    if (s) o = l.length - 1;
                    else if (n)
                        for (var c = 0; c < l.length; ++c) l[c].offsetTop <= a && (o = c);
                    else o = 0;
                    if (Mt(r) && (t(y).hasClass(f) || t(y).addClass(f).siblings().removeClass(f)), !(e = t(l).eq(o)).hasClass(d)) {
                        Si = !0;
                        var u, h, p = t(y),
                            m = p.index(v) + 1,
                            g = be(e),
                            _ = e.data("anchor"),
                            x = e.index(v) + 1,
                            b = e.find(O);
                        b.length && (h = b.data("anchor"), u = b.index()), hi && (e.addClass(d).siblings().removeClass(d), t.isFunction(Q.onLeave) && Q.onLeave.call(p, m, x, g), t.isFunction(Q.afterLoad) && Q.afterLoad.call(e, _, x), Yt(p), Wt(e), Xt(e), xe(_, x - 1), Q.anchors.length && (ti = _), Re(u, h, _, x)), clearTimeout(yi), yi = setTimeout(function() {
                            Si = !1
                        }, 100)
                    }
                    Q.fitToSection && (clearTimeout(_i), _i = setTimeout(function() {
                        Q.fitToSection && t(y).outerHeight() <= li && Et()
                    }, Q.fitToSectionDelay))
                }
            }

            function Et() {
                hi && (ci = !0, Ut(t(y)), ci = !1)
            }

            function Mt(e) {
                var i = t(y).position().top,
                    n = i + q.height();
                return "up" == e ? n >= q.scrollTop() + q.height() : i <= q.scrollTop()
            }

            function At(t) {
                var e = t > Ei ? "down" : "up";
                return Ei = t, Ri = t, e
            }

            function Lt(e) {
                if (pi.m[e]) {
                    var i = "down" === e ? rt : nt;
                    if (Q.scrollOverflow) {
                        var n = Q.scrollOverflowHandler.scrollable(t(y)),
                            r = "down" === e ? "bottom" : "top";
                        if (n.length > 0) {
                            if (!Q.scrollOverflowHandler.isScrolled(r, n)) return !0;
                            i()
                        } else i()
                    } else i()
                }
            }

            function Ct(t) {
                var e = t.originalEvent;
                Q.autoScrolling && Rt(e) && t.preventDefault()
            }

            function Pt(e) {
                var i = e.originalEvent,
                    r = t(i.target).closest(v);
                if (Rt(i)) {
                    Q.autoScrolling && e.preventDefault();
                    var o = He(i);
                    Li = o.y, Ci = o.x, r.find(D).length && n.abs(Ai - Ci) > n.abs(Mi - Li) ? !ri && n.abs(Ai - Ci) > q.outerWidth() / 100 * Q.touchSensitivity && (Ai > Ci ? pi.m.right && st(r) : pi.m.left && lt(r)) : Q.autoScrolling && hi && n.abs(Mi - Li) > q.height() / 100 * Q.touchSensitivity && (Mi > Li ? Lt("down") : Li > Mi && Lt("up"))
                }
            }

            function Rt(t) {
                return void 0 === t.pointerType || "mouse" != t.pointerType
            }

            function Ot(t) {
                var e = t.originalEvent;
                if (Q.fitToSection && Je.stop(), Rt(e)) {
                    var i = He(e);
                    Mi = i.y, Ai = i.x
                }
            }

            function It(t, e) {
                for (var i = 0, r = t.slice(n.max(t.length - e, 1)), o = 0; o < r.length; o++) i += r[o];
                return n.ceil(i / e)
            }

            function Dt(i) {
                var r = (new Date).getTime(),
                    o = t(m).hasClass(S);
                if (Q.autoScrolling && !ii && !o) {
                    var a = (i = i || e.event).wheelDelta || -i.deltaY || -i.detail,
                        s = n.max(-1, n.min(1, a)),
                        l = void 0 !== i.wheelDeltaX || void 0 !== i.deltaX,
                        c = n.abs(i.wheelDeltaX) < n.abs(i.wheelDelta) || n.abs(i.deltaX) < n.abs(i.deltaY) || !l;
                    di.length > 149 && di.shift(), di.push(n.abs(a)), Q.scrollBar && (i.preventDefault ? i.preventDefault() : i.returnValue = !1);
                    var u = r - Pi;
                    return Pi = r, u > 200 && (di = []), hi && It(di, 10) >= It(di, 70) && c && Lt(s < 0 ? "down" : "up"), !1
                }
                Q.fitToSection && Je.stop()
            }

            function Nt(e, i) {
                var n = (void 0 === i ? t(y) : i).find(D),
                    r = n.find(R).length;
                if (!(!n.length || ri || r < 2)) {
                    var o = n.find(O),
                        a = null;
                    if (!(a = "left" === e ? o.prev(R) : o.next(R)).length) {
                        if (!Q.loopHorizontal) return;
                        a = "left" === e ? o.siblings(":last") : o.siblings(":first")
                    }
                    ri = !0, ue(n, a, e)
                }
            }

            function Ft() {
                t(O).each(function() {
                    Ge(t(this), "internal")
                })
            }

            function kt(t) {
                var e = t.position(),
                    i = e.top,
                    n = e.top > Ri,
                    r = i - li + t.outerHeight(),
                    o = Q.bigSectionsDestination;
                return t.outerHeight() > li ? (n || o) && "bottom" !== o || (i = r) : (n || ci && t.is(":last-child")) && (i = r), Ri = i, i
            }

            function Ut(e, i, n) {
                if (void 0 !== e) {
                    var r, o, a = {
                        element: e,
                        callback: i,
                        isMovementUp: n,
                        dtop: kt(e),
                        yMovement: be(e),
                        anchorLink: e.data("anchor"),
                        sectionIndex: e.index(v),
                        activeSlide: e.find(O),
                        activeSection: t(y),
                        leavingSection: t(y).index(v) + 1,
                        localIsResizing: ci
                    };
                    a.activeSection.is(e) && !ci || Q.scrollBar && q.scrollTop() === a.dtop && !e.hasClass(T) || (a.activeSlide.length && (r = a.activeSlide.data("anchor"), o = a.activeSlide.index()), t.isFunction(Q.onLeave) && !a.localIsResizing && !1 === Q.onLeave.call(a.activeSection, a.leavingSection, a.sectionIndex + 1, a.yMovement) || (Q.autoScrolling && Q.continuousVertical && void 0 !== a.isMovementUp && (!a.isMovementUp && "up" == a.yMovement || a.isMovementUp && "down" == a.yMovement) && (a = jt(a)), a.localIsResizing || Yt(a.activeSection), Q.scrollOverflow && Q.scrollOverflowHandler.beforeLeave(), e.addClass(d).siblings().removeClass(d), Wt(e), Q.scrollOverflow && Q.scrollOverflowHandler.onLeave(), hi = !1, Re(o, r, a.anchorLink, a.sectionIndex), Bt(a), ti = a.anchorLink, xe(a.anchorLink, a.sectionIndex)))
                }
            }

            function Bt(e) {
                if (Q.css3 && Q.autoScrolling && !Q.scrollBar) Ee("translate3d(0px, -" + n.round(e.dtop) + "px, 0px)", !0), Q.scrollingSpeed ? (clearTimeout(gi), gi = setTimeout(function() {
                    Gt(e)
                }, Q.scrollingSpeed)) : Gt(e);
                else {
                    var i = zt(e);
                    t(i.element).animate(i.options, Q.scrollingSpeed, Q.easing).promise().done(function() {
                        Q.scrollBar ? setTimeout(function() {
                            Gt(e)
                        }, 30) : Gt(e)
                    })
                }
            }

            function zt(t) {
                var e = {};
                return Q.autoScrolling && !Q.scrollBar ? (e.options = {
                    top: -t.dtop
                }, e.element = a) : (e.options = {
                    scrollTop: t.dtop
                }, e.element = "html, body"), e
            }

            function jt(e) {
                return e.isMovementUp ? t(y).before(e.activeSection.nextAll(v)) : t(y).after(e.activeSection.prevAll(v).get().reverse()), Ve(t(y).position().top), Ft(), e.wrapAroundElements = e.activeSection, e.dtop = e.element.position().top, e.yMovement = be(e.element), e.leavingSection = e.activeSection.index(v) + 1, e.sectionIndex = e.element.index(v), e
            }

            function Ht(e) {
                e.wrapAroundElements && e.wrapAroundElements.length && (e.isMovementUp ? t(_).before(e.wrapAroundElements) : t(x).after(e.wrapAroundElements), Ve(t(y).position().top), Ft())
            }

            function Gt(e) {
                Ht(e), t.isFunction(Q.afterLoad) && !e.localIsResizing && Q.afterLoad.call(e.element, e.anchorLink, e.sectionIndex + 1), Q.scrollOverflow && Q.scrollOverflowHandler.afterLoad(), e.localIsResizing || Xt(e.element), e.element.addClass(f).siblings().removeClass(f), hi = !0, t.isFunction(e.callback) && e.callback.call(this)
            }

            function Vt(t, e) {
                t.attr(e, t.data(e)).removeAttr("data-" + e)
            }

            function Wt(e) {
                if (Q.lazyLoading) {
                    var i;
                    Qt(e).find("img[data-src], img[data-srcset], source[data-src], video[data-src], audio[data-src], iframe[data-src]").each(function() {
                        if (i = t(this), t.each(["src", "srcset"], function(t, e) {
                                var n = i.attr("data-" + e);
                                void 0 !== n && n && Vt(i, e)
                            }), i.is("source")) {
                            var e = i.closest("video").length ? "video" : "audio";
                            i.closest(e).get(0).load()
                        }
                    })
                }
            }

            function Xt(e) {
                var i = Qt(e);
                i.find("video, audio").each(function() {
                    var e = t(this).get(0);
                    e.hasAttribute("data-autoplay") && "function" == typeof e.play && e.play()
                }), i.find('iframe[src*="youtube.com/embed/"]').each(function() {
                    var e = t(this).get(0);
                    e.hasAttribute("data-autoplay") && qt(e), e.onload = function() {
                        e.hasAttribute("data-autoplay") && qt(e)
                    }
                })
            }

            function qt(t) {
                t.contentWindow.postMessage('{"event":"command","func":"playVideo","args":""}', "*")
            }

            function Yt(e) {
                var i = Qt(e);
                i.find("video, audio").each(function() {
                    var e = t(this).get(0);
                    e.hasAttribute("data-keepplaying") || "function" != typeof e.pause || e.pause()
                }), i.find('iframe[src*="youtube.com/embed/"]').each(function() {
                    var e = t(this).get(0);
                    /youtube\.com\/embed\//.test(t(this).attr("src")) && !e.hasAttribute("data-keepplaying") && t(this).get(0).contentWindow.postMessage('{"event":"command","func":"pauseVideo","args":""}', "*")
                })
            }

            function Qt(e) {
                var i = e.find(O);
                return i.length && (e = t(i)), e
            }

            function Zt() {
                var t = $t(),
                    e = t.section,
                    i = t.slide;
                e && (Q.animateAnchor ? Le(e, i) : ot(e, i))
            }

            function Jt() {
                if (!Si && !Q.lockAnchors) {
                    var t = $t(),
                        e = t.section,
                        i = t.slide,
                        n = void 0 === ti,
                        r = void 0 === ti && void 0 === i && !ri;
                    e.length && (e && e !== ti && !n || r || !ri && ei != i) && Le(e, i)
                }
            }

            function $t() {
                var t = e.location.hash,
                    i = t.replace("#", "").split("/"),
                    n = t.indexOf("#/") > -1;
                return {
                    section: n ? "/" + i[1] : decodeURIComponent(i[0]),
                    slide: n ? decodeURIComponent(i[2]) : decodeURIComponent(i[1])
                }
            }

            function Kt(e) {
                clearTimeout(xi);
                var i = t(":focus");
                if (!i.is("textarea") && !i.is("input") && !i.is("select") && "true" !== i.attr("contentEditable") && "" !== i.attr("contentEditable") && Q.keyboardScrolling && Q.autoScrolling) {
                    var n = e.which,
                        r = [40, 38, 32, 33, 34];
                    t.inArray(n, r) > -1 && e.preventDefault(), ii = e.ctrlKey, xi = setTimeout(function() {
                        le(e)
                    }, 150)
                }
            }

            function te() {
                t(this).prev().trigger("click")
            }

            function ee(t) {
                ui && (ii = t.ctrlKey)
            }

            function ie(t) {
                2 == t.which && (Oi = t.pageY, si.on("mousemove", ce))
            }

            function ne(t) {
                2 == t.which && si.off("mousemove")
            }

            function re() {
                var e = t(this).closest(v);
                t(this).hasClass(H) ? pi.m.left && lt(e) : pi.m.right && st(e)
            }

            function oe() {
                ui = !1, ii = !1
            }

            function ae(e) {
                e.preventDefault();
                var i = t(this).parent().index();
                Ut(t(v).eq(i))
            }

            function se(e) {
                e.preventDefault();
                var i = t(this).closest(v).find(D);
                ue(i, i.find(R).eq(t(this).closest("li").index()))
            }

            function le(e) {
                var i = e.shiftKey;
                if (hi || !([37, 39].indexOf(e.which) < 0)) switch (e.which) {
                    case 38:
                    case 33:
                        pi.k.up && nt();
                        break;
                    case 32:
                        if (i && pi.k.up) {
                            nt();
                            break
                        }
                    case 40:
                    case 34:
                        pi.k.down && rt();
                        break;
                    case 36:
                        pi.k.up && at(1);
                        break;
                    case 35:
                        pi.k.down && at(t(v).length);
                        break;
                    case 37:
                        pi.k.left && lt();
                        break;
                    case 39:
                        pi.k.right && st();
                        break;
                    default:
                        return
                }
            }

            function ce(t) {
                hi && (t.pageY < Oi && pi.m.up ? nt() : t.pageY > Oi && pi.m.down && rt()), Oi = t.pageY
            }

            function ue(e, i, n) {
                var r = e.closest(v),
                    o = {
                        slides: e,
                        destiny: i,
                        direction: n,
                        destinyPos: i.position(),
                        slideIndex: i.index(),
                        section: r,
                        sectionIndex: r.index(v),
                        anchorLink: r.data("anchor"),
                        slidesNav: r.find(B),
                        slideAnchor: Ie(i),
                        prevSlide: r.find(O),
                        prevSlideIndex: r.find(O).index(),
                        localIsResizing: ci
                    };
                o.xMovement = we(o.prevSlideIndex, o.slideIndex), o.localIsResizing || (hi = !1), Q.onSlideLeave && !o.localIsResizing && "none" !== o.xMovement && t.isFunction(Q.onSlideLeave) && !1 === Q.onSlideLeave.call(o.prevSlide, o.anchorLink, o.sectionIndex + 1, o.prevSlideIndex, o.direction, o.slideIndex) ? ri = !1 : (i.addClass(d).siblings().removeClass(d), o.localIsResizing || (Yt(o.prevSlide), Wt(i)), !Q.loopHorizontal && Q.controlArrows && (r.find(V).toggle(0 !== o.slideIndex), r.find(X).toggle(!i.is(":last-child"))), r.hasClass(d) && !o.localIsResizing && Re(o.slideIndex, o.slideAnchor, o.anchorLink, o.sectionIndex), de(e, o, !0))
            }

            function he(e) {
                pe(e.slidesNav, e.slideIndex), e.localIsResizing || (t.isFunction(Q.afterSlideLoad) && Q.afterSlideLoad.call(e.destiny, e.anchorLink, e.sectionIndex + 1, e.slideAnchor, e.slideIndex), hi = !0, Xt(e.destiny)), ri = !1
            }

            function de(t, e, i) {
                var r = e.destinyPos;
                if (Q.css3) {
                    var o = "translate3d(-" + n.round(r.left) + "px, 0px, 0px)";
                    ge(t.find(F)).css(We(o)), vi = setTimeout(function() {
                        i && he(e)
                    }, Q.scrollingSpeed, Q.easing)
                } else t.animate({
                    scrollLeft: n.round(r.left)
                }, Q.scrollingSpeed, Q.easing, function() {
                    i && he(e)
                })
            }

            function pe(t, e) {
                t.find(p).removeClass(d), t.find("li").eq(e).find("a").addClass(d)
            }

            function fe() {
                if (me(), oi) {
                    var e = t(i.activeElement);
                    if (!e.is("textarea") && !e.is("input") && !e.is("select")) {
                        var r = q.height();
                        n.abs(r - Ii) > 20 * n.max(Ii, r) / 100 && (ct(!0), Ii = r)
                    }
                } else clearTimeout(mi), mi = setTimeout(function() {
                    ct(!0)
                }, 350)
            }

            function me() {
                var t = Q.responsive || Q.responsiveWidth,
                    e = Q.responsiveHeight,
                    i = t && q.outerWidth() < t,
                    n = e && q.height() < e;
                t && e ? ut(i || n) : t ? ut(i) : e && ut(n)
            }

            function ge(t) {
                var e = "all " + Q.scrollingSpeed + "ms " + Q.easingcss3;
                return t.removeClass(l), t.css({
                    "-webkit-transition": e,
                    transition: e
                })
            }

            function ve(t) {
                return t.addClass(l)
            }

            function ye(e, i) {
                Q.navigation && (t(M).find(p).removeClass(d), e ? t(M).find('a[href="#' + e + '"]').addClass(d) : t(M).find("li").eq(i).find("a").addClass(d))
            }

            function _e(e) {
                Q.menu && (t(Q.menu).find(p).removeClass(d), t(Q.menu).find('[data-menuanchor="' + e + '"]').addClass(d))
            }

            function xe(t, e) {
                _e(t), ye(t, e)
            }

            function be(e) {
                var i = t(y).index(v),
                    n = e.index(v);
                return i == n ? "none" : i > n ? "up" : "down"
            }

            function we(t, e) {
                return t == e ? "none" : t > e ? "left" : "right"
            }

            function Te(t) {
                t.hasClass(k) || t.addClass(k).wrapInner('<div class="' + b + '" style="height:' + Se(t) + 'px;" />')
            }

            function Se(t) {
                var e = li;
                if (Q.paddingTop || Q.paddingBottom) {
                    var i = t;
                    i.hasClass(g) || (i = t.closest(v));
                    var n = parseInt(i.css("padding-top")) + parseInt(i.css("padding-bottom"));
                    e = li - n
                }
                return e
            }

            function Ee(t, e) {
                e ? ge(si) : ve(si), si.css(We(t)), setTimeout(function() {
                    si.removeClass(l)
                }, 10)
            }

            function Me(e) {
                if (!e) return [];
                var i = si.find(v + '[data-anchor="' + e + '"]');
                return i.length || (i = t(v).eq(e - 1)), i
            }

            function Ae(t, e) {
                var i = e.find(D),
                    n = i.find(R + '[data-anchor="' + t + '"]');
                return n.length || (n = i.find(R).eq(t)), n
            }

            function Le(t, e) {
                var i = Me(t);
                i.length && (void 0 === e && (e = 0), t === ti || i.hasClass(d) ? Ce(i, e) : Ut(i, function() {
                    Ce(i, e)
                }))
            }

            function Ce(t, e) {
                if (void 0 !== e) {
                    var i = t.find(D),
                        n = Ae(e, t);
                    n.length && ue(i, n)
                }
            }

            function Pe(t, e) {
                t.append('<div class="' + U + '"><ul></ul></div>');
                var i = t.find(B);
                i.addClass(Q.slidesNavPosition);
                for (var n = 0; n < e; n++) i.find("ul").append('<li><a href="#"><span></span></a></li>');
                i.css("margin-left", "-" + i.width() / 2 + "px"), i.find("li").first().find("a").addClass(d)
            }

            function Re(t, e, i, n) {
                var r = "";
                Q.anchors.length && !Q.lockAnchors && (t ? (void 0 !== i && (r = i), void 0 === e && (e = t), ei = e, Oe(r + "/" + e)) : void 0 !== t ? (ei = e, Oe(i)) : Oe(i)), De()
            }

            function Oe(t) {
                if (Q.recordHistory) location.hash = t;
                else if (oi || ai) e.history.replaceState(r, r, "#" + t);
                else {
                    var i = e.location.href.split("#")[0];
                    e.location.replace(i + "#" + t)
                }
            }

            function Ie(t) {
                var e = t.data("anchor"),
                    i = t.index();
                return void 0 === e && (e = i), e
            }

            function De() {
                var e = t(y),
                    i = e.find(O),
                    n = Ie(e),
                    r = Ie(i),
                    o = String(n);
                i.length && (o = o + "-" + r), o = o.replace("/", "-").replace("#", "");
                var a = new RegExp("\\b\\s?" + h + "-[^\\s]+\\b", "g");
                $e[0].className = $e[0].className.replace(a, ""), $e.addClass(h + "-" + o)
            }

            function Ne() {
                var t, n = i.createElement("p"),
                    o = {
                        webkitTransform: "-webkit-transform",
                        OTransform: "-o-transform",
                        msTransform: "-ms-transform",
                        MozTransform: "-moz-transform",
                        transform: "transform"
                    };
                i.body.insertBefore(n, null);
                for (var a in o) n.style[a] !== r && (n.style[a] = "translate3d(1px,1px,1px)", t = e.getComputedStyle(n).getPropertyValue(o[a]));
                return i.body.removeChild(n), t !== r && t.length > 0 && "none" !== t
            }

            function Fe() {
                i.addEventListener ? (i.removeEventListener("mousewheel", Dt, !1), i.removeEventListener("wheel", Dt, !1), i.removeEventListener("MozMousePixelScroll", Dt, !1)) : i.detachEvent("onmousewheel", Dt)
            }

            function ke() {
                var t, n = "";
                e.addEventListener ? t = "addEventListener" : (t = "attachEvent", n = "on");
                var o = "onwheel" in i.createElement("div") ? "wheel" : i.onmousewheel !== r ? "mousewheel" : "DOMMouseScroll";
                "DOMMouseScroll" == o ? i[t](n + "MozMousePixelScroll", Dt, !1) : i[t](n + o, Dt, !1)
            }

            function Ue() {
                si.on("mousedown", ie).on("mouseup", ne)
            }

            function Be() {
                si.off("mousedown", ie).off("mouseup", ne)
            }

            function ze() {
                (oi || ai) && (Q.autoScrolling && $e.off(wi.touchmove).on(wi.touchmove, Ct), t(a).off(wi.touchstart).on(wi.touchstart, Ot).off(wi.touchmove).on(wi.touchmove, Pt))
            }

            function je() {
                (oi || ai) && (Q.autoScrolling && $e.off(wi.touchmove), t(a).off(wi.touchstart).off(wi.touchmove))
            }

            function He(t) {
                var e = [];
                return e.y = void 0 !== t.pageY && (t.pageY || t.pageX) ? t.pageY : t.touches[0].pageY, e.x = void 0 !== t.pageX && (t.pageY || t.pageX) ? t.pageX : t.touches[0].pageX, ai && Rt(t) && Q.scrollBar && (e.y = t.touches[0].pageY, e.x = t.touches[0].pageX), e
            }

            function Ge(t, e) {
                $(0, "internal"), void 0 !== e && (ci = !0), ue(t.closest(D), t), void 0 !== e && (ci = !1), $(Ti.scrollingSpeed, "internal")
            }

            function Ve(t) {
                var e = n.round(t);
                Q.css3 && Q.autoScrolling && !Q.scrollBar ? Ee("translate3d(0px, -" + e + "px, 0px)", !1) : Q.autoScrolling && !Q.scrollBar ? si.css("top", -e) : Je.scrollTop(e)
            }

            function We(t) {
                return {
                    "-webkit-transform": t,
                    "-moz-transform": t,
                    "-ms-transform": t,
                    transform: t
                }
            }

            function Xe(e, i, n) {
                "all" !== i ? pi[n][i] = e : t.each(Object.keys(pi[n]), function(t, i) {
                    pi[n][i] = e
                })
            }

            function qe() {
                Ve(0), si.find("img[data-src], source[data-src], audio[data-src], iframe[data-src]").each(function() {
                    Vt(t(this), "src")
                }), si.find("img[data-srcset]").each(function() {
                    Vt(t(this), "srcset")
                }), t(M + ", " + B + ", " + j).remove(), t(v).css({
                    height: "",
                    "background-color": "",
                    padding: ""
                }), t(R).css({
                    width: ""
                }), si.css({
                    height: "",
                    position: "",
                    "-ms-touch-action": "",
                    "touch-action": ""
                }), Je.css({
                    overflow: "",
                    height: ""
                }), t("html").removeClass(u), $e.removeClass(s), t.each($e.get(0).className.split(/\s+/), function(t, e) {
                    0 === e.indexOf(h) && $e.removeClass(e)
                }), t(v + ", " + R).each(function() {
                    Q.scrollOverflowHandler && Q.scrollOverflowHandler.remove(t(this)), t(this).removeClass(k + " " + d)
                }), ve(si), si.find(w + ", " + F + ", " + D).each(function() {
                    t(this).replaceWith(this.childNodes)
                }), si.css({
                    "-webkit-transition": "none",
                    transition: "none"
                }), Je.scrollTop(0);
                var e = [g, P, N];
                t.each(e, function(e, i) {
                    t("." + i).removeClass(i)
                })
            }

            function Ye(t, e, i) {
                Q[t] = e, "internal" !== i && (Ti[t] = e)
            }

            function Qe() {
                var e = ["fadingEffect", "continuousHorizontal", "scrollHorizontally", "interlockedSlides", "resetSliders", "responsiveSlides", "offsetSections", "dragAndMove", "scrollOverflowReset", "parallax"];
                t("html").hasClass(u) ? Ze("error", "Fullpage.js can only be initialized once and you are doing it multiple times!") : (Q.continuousVertical && (Q.loopTop || Q.loopBottom) && (Q.continuousVertical = !1, Ze("warn", "Option `loopTop/loopBottom` is mutually exclusive with `continuousVertical`; `continuousVertical` disabled")), Q.scrollBar && Q.scrollOverflow && Ze("warn", "Option `scrollBar` is mutually exclusive with `scrollOverflow`. Sections with scrollOverflow might not work well in Firefox"), !Q.continuousVertical || !Q.scrollBar && Q.autoScrolling || (Q.continuousVertical = !1, Ze("warn", "Scroll bars (`scrollBar:true` or `autoScrolling:false`) are mutually exclusive with `continuousVertical`; `continuousVertical` disabled")), Q.scrollOverflow && !Q.scrollOverflowHandler && (Q.scrollOverflow = !1, Ze("error", "The option `scrollOverflow:true` requires the file `scrolloverflow.min.js`. Please include it before fullPage.js.")), t.each(e, function(t, e) {
                    Q[e] && Ze("warn", "fullpage.js extensions require jquery.fullpage.extensions.min.js file instead of the usual jquery.fullpage.js. Requested: " + e)
                }), t.each(Q.anchors, function(e, i) {
                    var n = Y.find("[name]").filter(function() {
                            return t(this).attr("name") && t(this).attr("name").toLowerCase() == i.toLowerCase()
                        }),
                        r = Y.find("[id]").filter(function() {
                            return t(this).attr("id") && t(this).attr("id").toLowerCase() == i.toLowerCase()
                        });
                    (r.length || n.length) && (Ze("error", "data-anchor tags can not have the same value as any `id` element on the site (or `name` element for IE)."), r.length && Ze("error", '"' + i + '" is is being used by another element `id` property'), n.length && Ze("error", '"' + i + '" is is being used by another element `name` property'))
                }))
            }

            function Ze(t, e) {
                console && console[t] && console[t]("fullPage: " + e)
            }
            if (t("html").hasClass(u)) Qe();
            else {
                var Je = t("html, body"),
                    $e = t("body"),
                    Ke = t.fn.fullpage;
                Q = t.extend({
                    menu: !1,
                    anchors: [],
                    lockAnchors: !1,
                    navigation: !1,
                    navigationPosition: "right",
                    navigationTooltips: [],
                    showActiveTooltip: !1,
                    slidesNavigation: !1,
                    slidesNavPosition: "bottom",
                    scrollBar: !1,
                    hybrid: !1,
                    css3: !0,
                    scrollingSpeed: 700,
                    autoScrolling: !0,
                    fitToSection: !0,
                    fitToSectionDelay: 1e3,
                    easing: "easeInOutCubic",
                    easingcss3: "ease",
                    loopBottom: !1,
                    loopTop: !1,
                    loopHorizontal: !0,
                    continuousVertical: !1,
                    continuousHorizontal: !1,
                    scrollHorizontally: !1,
                    interlockedSlides: !1,
                    dragAndMove: !1,
                    offsetSections: !1,
                    resetSliders: !1,
                    fadingEffect: !1,
                    normalScrollElements: null,
                    scrollOverflow: !1,
                    scrollOverflowReset: !1,
                    scrollOverflowHandler: t.fn.fp_scrolloverflow ? t.fn.fp_scrolloverflow.iscrollHandler : null,
                    scrollOverflowOptions: null,
                    touchSensitivity: 5,
                    normalScrollElementTouchThreshold: 5,
                    bigSectionsDestination: null,
                    keyboardScrolling: !0,
                    animateAnchor: !0,
                    recordHistory: !0,
                    controlArrows: !0,
                    controlArrowColor: "#fff",
                    verticalCentered: !0,
                    sectionsColor: [],
                    paddingTop: 0,
                    paddingBottom: 0,
                    fixedElements: null,
                    responsive: 0,
                    responsiveWidth: 0,
                    responsiveHeight: 0,
                    responsiveSlides: !1,
                    parallax: !1,
                    parallaxOptions: {
                        type: "reveal",
                        percentage: 62,
                        property: "translate"
                    },
                    sectionSelector: ".section",
                    slideSelector: ".slide",
                    afterLoad: null,
                    onLeave: null,
                    afterRender: null,
                    afterResize: null,
                    afterReBuild: null,
                    afterSlideLoad: null,
                    onSlideLeave: null,
                    afterResponsive: null,
                    lazyLoading: !0
                }, Q);
                var ti, ei, ii, ni, ri = !1,
                    oi = navigator.userAgent.match(/(iPhone|iPod|iPad|Android|playbook|silk|BlackBerry|BB10|Windows Phone|Tizen|Bada|webOS|IEMobile|Opera Mini)/),
                    ai = "ontouchstart" in e || navigator.msMaxTouchPoints > 0 || navigator.maxTouchPoints,
                    si = t(this),
                    li = q.height(),
                    ci = !1,
                    ui = !0,
                    hi = !0,
                    di = [],
                    pi = {};
                pi.m = {
                    up: !0,
                    down: !0,
                    left: !0,
                    right: !0
                }, pi.k = t.extend(!0, {}, pi.m);
                var fi, mi, gi, vi, yi, _i, xi, bi = e.PointerEvent ? {
                        down: "pointerdown",
                        move: "pointermove"
                    } : {
                        down: "MSPointerDown",
                        move: "MSPointerMove"
                    },
                    wi = {
                        touchmove: "ontouchmove" in e ? "touchmove" : bi.move,
                        touchstart: "ontouchstart" in e ? "touchstart" : bi.down
                    },
                    Ti = t.extend(!0, {}, Q);
                Qe(), t.extend(t.easing, {
                    easeInOutCubic: function(t, e, i, n, r) {
                        return (e /= r / 2) < 1 ? n / 2 * e * e * e + i : n / 2 * ((e -= 2) * e * e + 2) + i
                    }
                }), t(this).length && (Ke.version = "2.9.5", Ke.setAutoScrolling = Z, Ke.setRecordHistory = J, Ke.setScrollingSpeed = $, Ke.setFitToSection = K, Ke.setLockAnchors = function(t) {
                    Q.lockAnchors = t
                }, Ke.setMouseWheelScrolling = tt, Ke.setAllowScrolling = et, Ke.setKeyboardScrolling = it, Ke.moveSectionUp = nt, Ke.moveSectionDown = rt, Ke.silentMoveTo = ot, Ke.moveTo = at, Ke.moveSlideRight = st, Ke.moveSlideLeft = lt, Ke.fitToSection = Et, Ke.reBuild = ct, Ke.setResponsive = ut, Ke.destroy = function(e) {
                    Z(!1, "internal"), et(!1), it(!1), si.addClass(c), clearTimeout(vi), clearTimeout(gi), clearTimeout(mi), clearTimeout(yi), clearTimeout(_i), q.off("scroll", St).off("hashchange", Jt).off("resize", fe), Y.off("click touchstart", M + " a").off("mouseenter", M + " li").off("mouseleave", M + " li").off("click touchstart", z).off("mouseover", Q.normalScrollElements).off("mouseout", Q.normalScrollElements), t(v).off("click touchstart", j), clearTimeout(vi), clearTimeout(gi), e && qe()
                }, Ke.shared = {
                    afterRenderActions: wt
                }, Q.css3 && (Q.css3 = Ne()), Q.scrollBar = Q.scrollBar || Q.hybrid, ht(), dt(), et(!0), Z(Q.autoScrolling, "internal"), me(), De(), "complete" === i.readyState && Zt(), q.on("load", Zt), q.on("scroll", St).on("hashchange", Jt).blur(oe).resize(fe), Y.keydown(Kt).keyup(ee).on("click touchstart", M + " a", ae).on("click touchstart", z, se).on("click", L, te), t(v).on("click touchstart", j, re), Q.normalScrollElements && (Y.on("mouseenter touchstart", Q.normalScrollElements, function() {
                    et(!1)
                }), Y.on("mouseleave touchend", Q.normalScrollElements, function() {
                    et(!0)
                })));
                var Si = !1,
                    Ei = 0,
                    Mi = 0,
                    Ai = 0,
                    Li = 0,
                    Ci = 0,
                    Pi = (new Date).getTime(),
                    Ri = 0,
                    Oi = 0,
                    Ii = li
            }
        }
    })
}, function(t, e, i) {
    var n, r, o = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t) {
        return typeof t
    } : function(t) {
        return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
    };
    ! function(o, a) {
        "use strict";
        n = [i(8)], void 0 !== (r = function(t) {
            return a(t, o, o.document, o.Math)
        }.apply(e, n)) && (t.exports = r)
    }("undefined" != typeof window ? window : void 0, function(t, e, i, n, r) {
        "use strict";
        var a = "fullpage-wrapper",
            s = "." + a,
            l = "fp-responsive",
            c = "fp-notransition",
            u = "fp-destroyed",
            h = "fp-enabled",
            d = "fp-viewing",
            p = "active",
            f = "." + p,
            m = "fp-completely",
            g = "." + m,
            v = "fp-section",
            y = "." + v,
            _ = y + f,
            x = y + ":first",
            b = y + ":last",
            w = "fp-tableCell",
            T = "." + w,
            S = "fp-auto-height",
            E = "fp-normal-scroll",
            M = "fp-nav",
            A = "#" + M,
            L = "fp-tooltip",
            C = "." + L,
            P = "fp-show-active",
            R = "fp-slide",
            O = "." + R,
            I = O + f,
            D = "fp-slides",
            N = "." + D,
            F = "fp-slidesContainer",
            k = "." + F,
            U = "fp-table",
            B = "fp-slidesNav",
            z = "." + B,
            j = z + " a",
            H = "fp-controlArrow",
            G = "." + H,
            V = "fp-prev",
            W = H + " " + V,
            X = G + ("." + V),
            q = "fp-next",
            Y = H + " " + q,
            Q = G + ".fp-next",
            Z = t(e),
            J = t(i);
        t.fn.fullpage = function(H) {
            function q(e, i) {
                e || ti(0), ci("autoScrolling", e, i);
                var n = t(_);
                H.autoScrolling && !H.scrollBar ? (di.css({
                    overflow: "hidden",
                    height: "100%"
                }), $(zi.recordHistory, "internal"), wi.css({
                    "-ms-touch-action": "none",
                    "touch-action": "none"
                }), n.length && ti(n.position().top)) : (di.css({
                    overflow: "visible",
                    height: "initial"
                }), $(!1, "internal"), wi.css({
                    "-ms-touch-action": "",
                    "touch-action": ""
                }), ri(wi), n.length && di.scrollTop(n.position().top)), wi.trigger("setAutoScrolling", [e])
            }

            function $(t, e) {
                ci("recordHistory", t, e)
            }

            function K(t, e) {
                "internal" !== e && H.fadingEffect && fi.fadingEffect && fi.fadingEffect.update(t), ci("scrollingSpeed", t, e)
            }

            function tt(t, e) {
                ci("fitToSection", t, e)
            }

            function et(t) {
                t ? (Xe(), qe()) : (We(), Ye())
            }

            function it(e, i) {
                void 0 !== i ? (i = i.replace(/ /g, "").split(","), t.each(i, function(t, i) {
                    ii(e, i, "m")
                })) : (ii(e, "all", "m"), e ? (et(!0), oi("dragAndMove") && "mouseonly" !== H.dragAndMove || Qe()) : (et(!1), Ze()))
            }

            function nt(e, i) {
                void 0 !== i ? (i = i.replace(/ /g, "").split(","), t.each(i, function(t, i) {
                    ii(e, i, "k")
                })) : (ii(e, "all", "k"), H.keyboardScrolling = e)
            }

            function rt() {
                var e = t(_).prev(y);
                e.length || !H.loopTop && !H.continuousVertical || (e = t(y).last()), e.length && jt(e, null, !0)
            }

            function ot() {
                var e = t(_).next(y);
                e.length || !H.loopBottom && !H.continuousVertical || (e = t(y).first()), e.length && jt(e, null, !1)
            }

            function at(t, e) {
                K(0, "internal"), st(t, e), K(zi.scrollingSpeed, "internal")
            }

            function st(t, e) {
                var i = Ne(t);
                void 0 !== e ? ke(t, e) : i.length > 0 && jt(i)
            }

            function lt(t) {
                Ut("right", t)
            }

            function ct(t) {
                Ut("left", t)
            }

            function ut(e) {
                if (!wi.hasClass(u)) {
                    Si = !0, Ti = Z.height(), t(y).each(function() {
                        var e = t(this).find(N),
                            i = t(this).find(O);
                        H.verticalCentered && t(this).find(T).css("height", Ie(t(this)) + "px"), t(this).css("height", gt(t(this)) + "px"), i.length > 1 && ye(e, e.find(I))
                    }), H.scrollOverflow && Ci.createScrollBarForAll();
                    var i = t(_).index(y);
                    i && !oi("fadingEffect") && at(i + 1), Si = !1, t.isFunction(H.afterResize) && e && H.afterResize.call(wi), t.isFunction(H.afterReBuild) && !e && H.afterReBuild.call(wi)
                }
            }

            function ht(e) {
                var i = pi.hasClass(l);
                e ? i || (q(!1, "internal"), tt(!1, "internal"), t(A).hide(), pi.addClass(l), t.isFunction(H.afterResponsive) && H.afterResponsive.call(wi, e), H.responsiveSlides && fi.responsiveSlides && fi.responsiveSlides.toSections(), wi.trigger("afterResponsive", [e])) : i && (q(zi.autoScrolling, "internal"), tt(zi.autoScrolling, "internal"), t(A).show(), pi.removeClass(l), t.isFunction(H.afterResponsive) && H.afterResponsive.call(wi, e), H.responsiveSlides && fi.responsiveSlides && fi.responsiveSlides.toSlides(), wi.trigger("afterResponsive", [e]))
            }

            function dt(t) {
                var i = "fp_" + t + "Extension";
                ji[t] = H[t + "Key"], fi[t] = void 0 !== e[i] ? new e[i] : null, fi[t] && fi[t].c(t)
            }

            function pt() {
                var e = wi.find(H.sectionSelector);
                H.anchors.length || (H.anchors = e.filter("[data-anchor]").map(function() {
                    return t(this).data("anchor").toString()
                }).get()), H.navigationTooltips.length || (H.navigationTooltips = e.filter("[data-tooltip]").map(function() {
                    return t(this).data("tooltip").toString()
                }).get())
            }

            function ft() {
                wi.css({
                    height: "100%",
                    position: "relative"
                }), wi.addClass(a), t("html").addClass(h), Ti = Z.height(), wi.removeClass(u), _t(), ai("parallax", "init"), t(y).each(function(e) {
                    var i = t(this),
                        n = i.find(O),
                        r = n.length;
                    vt(i, e), yt(i, e), r > 0 ? mt(i, n, r) : H.verticalCentered && Oe(i)
                }), H.fixedElements && H.css3 && t(H.fixedElements).appendTo(pi), H.navigation && bt(), wt(), H.fadingEffect && fi.fadingEffect && fi.fadingEffect.apply(), H.scrollOverflow ? Ci = H.scrollOverflowHandler.init(H) : Et()
            }

            function mt(e, i, n) {
                var r = 100 * n,
                    o = 100 / n;
                i.wrapAll('<div class="' + F + '" />'), i.parent().wrap('<div class="' + D + '" />'), e.find(k).css("width", r + "%"), n > 1 && (H.controlArrows && xt(e), H.slidesNavigation && Be(e, n)), i.each(function(e) {
                    t(this).css("width", o + "%"), H.verticalCentered && Oe(t(this))
                });
                var a = e.find(I);
                a.length && (0 !== t(_).index(y) || 0 === t(_).index(y) && 0 !== a.index()) ? Ke(a, "internal") : i.eq(0).addClass(p)
            }

            function gt(t) {
                return H.offsetSections && fi.offsetSections ? n.round(fi.offsetSections.getWindowHeight(t)) : Ti
            }

            function vt(e, i) {
                i || 0 !== t(_).length || e.addClass(p), yi = t(_), e.css("height", gt(e) + "px"), H.paddingTop && e.css("padding-top", H.paddingTop), H.paddingBottom && e.css("padding-bottom", H.paddingBottom), void 0 !== H.sectionsColor[i] && e.css("background-color", H.sectionsColor[i]), void 0 !== H.anchors[i] && e.attr("data-anchor", H.anchors[i])
            }

            function yt(e, i) {
                void 0 !== H.anchors[i] && e.hasClass(p) && Ce(H.anchors[i], i), H.menu && H.css3 && t(H.menu).closest(s).length && t(H.menu).appendTo(pi)
            }

            function _t() {
                wi.find(H.sectionSelector).addClass(v), wi.find(H.slideSelector).addClass(R)
            }

            function xt(t) {
                t.find(N).after('<div class="' + W + '"></div><div class="' + Y + '"></div>'), "#fff" != H.controlArrowColor && (t.find(Q).css("border-color", "transparent transparent transparent " + H.controlArrowColor), t.find(X).css("border-color", "transparent " + H.controlArrowColor + " transparent transparent")), H.loopHorizontal || t.find(X).hide()
            }

            function bt() {
                pi.append('<div id="' + M + '"><ul></ul></div>');
                var e = t(A);
                e.addClass(function() {
                    return H.showActiveTooltip ? P + " " + H.navigationPosition : H.navigationPosition
                });
                for (var i = 0; i < t(y).length; i++) {
                    var n = "";
                    H.anchors.length && (n = H.anchors[i]);
                    var r = '<li><a href="#' + n + '"><span></span></a>',
                        o = H.navigationTooltips[i];
                    void 0 !== o && "" !== o && (r += '<div class="' + L + " " + H.navigationPosition + '">' + o + "</div>"), r += "</li>", e.find("ul").append(r)
                }
                t(A).css("margin-top", "-" + t(A).height() / 2 + "px"), t(A).find("li").eq(t(_).index(y)).find("a").addClass(p)
            }

            function wt() {
                wi.find('iframe[src*="youtube.com/embed/"]').each(function() {
                    Tt(t(this), "enablejsapi=1")
                })
            }

            function Tt(t, e) {
                var i = t.attr("src");
                t.attr("src", i + St(i) + e)
            }

            function St(t) {
                return /\?/.test(t) ? "&" : "?"
            }

            function Et() {
                var e = t(_);
                e.addClass(m), Qt(e), Zt(e), H.scrollOverflow && H.scrollOverflowHandler.afterLoad(), Mt() && t.isFunction(H.afterLoad) && H.afterLoad.call(e, e.data("anchor"), e.index(y) + 1), t.isFunction(H.afterRender) && H.afterRender.call(wi)
            }

            function Mt() {
                var t = Ne(ae().section);
                return !t.length || t.length && t.index() === yi.index()
            }

            function At() {
                Qi || (requestAnimationFrame(Lt), Qi = !0)
            }

            function Lt() {
                wi.trigger("onScroll");
                var e;
                if ((!H.autoScrolling || H.scrollBar || oi("dragAndMove")) && !li()) {
                    var r = oi("dragAndMove") ? n.abs(fi.dragAndMove.getCurrentScroll()) : Z.scrollTop(),
                        o = (Pt(r), 0),
                        a = r + Z.height() / 2,
                        s = (oi("dragAndMove") ? fi.dragAndMove.getDocumentHeight() : pi.height() - Z.height()) === r,
                        l = i.querySelectorAll(y);
                    if (s) o = l.length - 1;
                    else if (r)
                        for (var c = 0; c < l.length; ++c) l[c].offsetTop <= a && (o = c);
                    else o = 0;
                    if (!(e = t(l).eq(o)).hasClass(p)) {
                        Hi = !0;
                        var u, h, d = t(_),
                            f = d.index(y) + 1,
                            m = Pe(e),
                            g = e.data("anchor"),
                            v = e.index(y) + 1,
                            x = e.find(I);
                        x.length && (h = x.data("anchor"), u = x.index()), Mi && (e.addClass(p).siblings().removeClass(p), ai("parallax", "afterLoad"), t.isFunction(H.onLeave) && H.onLeave.call(d, f, v, m), t.isFunction(H.afterLoad) && H.afterLoad.call(e, g, v), H.resetSliders && fi.resetSliders && fi.resetSliders.apply({
                            localIsResizing: Si,
                            leavingSection: f
                        }), $t(d), Qt(e), Zt(e), Ce(g, v - 1), H.anchors.length && (mi = g), ze(u, h, g, v)), clearTimeout(Ii), Ii = setTimeout(function() {
                            Hi = !1
                        }, 100)
                    }
                    H.fitToSection && (clearTimeout(Di), Di = setTimeout(function() {
                        H.fitToSection && t(_).outerHeight() <= Ti && Ct()
                    }, H.fitToSectionDelay))
                }
                Qi = !1
            }

            function Ct() {
                Mi && (Si = !0, jt(t(_)), Si = !1)
            }

            function Pt(t) {
                var e = t > Gi ? "down" : "up";
                return Gi = t, Zi = t, e
            }

            function Rt(e) {
                if (Li.m[e]) {
                    var i = "down" === e ? ot : rt;
                    if (fi.scrollHorizontally && (i = fi.scrollHorizontally.getScrollSection(e, i)), H.scrollOverflow) {
                        var n = H.scrollOverflowHandler.scrollable(t(_)),
                            r = "down" === e ? "bottom" : "top";
                        if (n.length > 0) {
                            if (!H.scrollOverflowHandler.isScrolled(r, n)) return !0;
                            i()
                        } else i()
                    } else i()
                }
            }

            function Ot(t) {
                var e = t.originalEvent;
                H.autoScrolling && Dt(e) && t.preventDefault()
            }

            function It(e) {
                var i = e.originalEvent,
                    r = t(i.target).closest(y);
                if (Dt(i)) {
                    H.autoScrolling && e.preventDefault();
                    var o = $e(i);
                    Xi = o.y, qi = o.x, r.find(N).length && n.abs(Wi - qi) > n.abs(Vi - Xi) ? !_i && n.abs(Wi - qi) > Z.outerWidth() / 100 * H.touchSensitivity && (Wi > qi ? Li.m.right && lt(r) : Li.m.left && ct(r)) : H.autoScrolling && Mi && n.abs(Vi - Xi) > Z.height() / 100 * H.touchSensitivity && (Vi > Xi ? Rt("down") : Xi > Vi && Rt("up"))
                }
            }

            function Dt(t) {
                return void 0 === t.pointerType || "mouse" != t.pointerType
            }

            function Nt(t) {
                var e = t.originalEvent;
                if (H.fitToSection && di.stop(), Dt(e)) {
                    var i = $e(e);
                    Vi = i.y, Wi = i.x
                }
            }

            function Ft(t, e) {
                for (var i = 0, r = t.slice(n.max(t.length - e, 1)), o = 0; o < r.length; o++) i += r[o];
                return n.ceil(i / e)
            }

            function kt(i) {
                var r = (new Date).getTime(),
                    o = t(g).hasClass(E);
                if (H.autoScrolling && !vi && !o) {
                    var a = (i = i || e.event).wheelDelta || -i.deltaY || -i.detail,
                        s = n.max(-1, n.min(1, a)),
                        l = void 0 !== i.wheelDeltaX || void 0 !== i.deltaX,
                        c = n.abs(i.wheelDeltaX) < n.abs(i.wheelDelta) || n.abs(i.deltaX) < n.abs(i.deltaY) || !l;
                    Ai.length > 149 && Ai.shift(), Ai.push(n.abs(a)), H.scrollBar && (i.preventDefault ? i.preventDefault() : i.returnValue = !1);
                    var u = r - Yi;
                    return Yi = r, u > 200 && (Ai = []), Mi && !si() && Ft(Ai, 10) >= Ft(Ai, 70) && c && Rt(s < 0 ? "down" : "up"), !1
                }
                H.fitToSection && di.stop()
            }

            function Ut(e, i) {
                var n = (void 0 === i ? t(_) : i).find(N);
                if (!(!n.length || si() || _i || n.find(O).length < 2)) {
                    var r = n.find(I),
                        o = null;
                    if (!(o = "left" === e ? r.prev(O) : r.next(O)).length) {
                        if (!H.loopHorizontal) return;
                        o = "left" === e ? r.siblings(":last") : r.siblings(":first")
                    }
                    _i = !0, ye(n, o, e)
                }
            }

            function Bt() {
                t(I).each(function() {
                    Ke(t(this), "internal")
                })
            }

            function zt(t) {
                var e = t.position(),
                    i = e.top,
                    n = oi("dragAndMove") && fi.dragAndMove.isGrabbing ? fi.dragAndMove.isScrollingDown() : e.top > Zi,
                    r = i - Ti + t.outerHeight(),
                    o = H.bigSectionsDestination;
                return t.outerHeight() > Ti ? (n || o) && "bottom" !== o || (i = r) : (n || Si && t.is(":last-child")) && (i = r), H.offsetSections && fi.offsetSections && (i = fi.offsetSections.getSectionPosition(n, i, t)), Zi = i, i
            }

            function jt(e, i, n) {
                if (void 0 !== e && e.length) {
                    var r, o, a = {
                        element: e,
                        callback: i,
                        isMovementUp: n,
                        dtop: zt(e),
                        yMovement: Pe(e),
                        anchorLink: e.data("anchor"),
                        sectionIndex: e.index(y),
                        activeSlide: e.find(I),
                        activeSection: t(_),
                        leavingSection: t(_).index(y) + 1,
                        localIsResizing: Si
                    };
                    a.activeSection.is(e) && !Si || H.scrollBar && Z.scrollTop() === a.dtop && !e.hasClass(S) || (a.activeSlide.length && (r = a.activeSlide.data("anchor"), o = a.activeSlide.index()), t.isFunction(H.onLeave) && !a.localIsResizing && !1 === H.onLeave.call(a.activeSection, a.leavingSection, a.sectionIndex + 1, a.yMovement) || (ai("parallax", "apply", a), H.autoScrolling && H.continuousVertical && void 0 !== a.isMovementUp && (!a.isMovementUp && "up" == a.yMovement || a.isMovementUp && "down" == a.yMovement) && (a = Wt(a)), oi("scrollOverflowReset") && fi.scrollOverflowReset.setPrevious(a.activeSection), a.localIsResizing || $t(a.activeSection), H.scrollOverflow && H.scrollOverflowHandler.beforeLeave(), e.addClass(p).siblings().removeClass(p), Qt(e), H.scrollOverflow && H.scrollOverflowHandler.onLeave(), Mi = !1, ze(o, r, a.anchorLink, a.sectionIndex), Gt(a), mi = a.anchorLink, Ce(a.anchorLink, Ht(a))))
                }
            }

            function Ht(e) {
                return e.wrapAroundElements && e.wrapAroundElements.length ? e.isMovementUp ? t(y).length - 1 : 0 : e.sectionIndex
            }

            function Gt(e) {
                if (H.css3 && H.autoScrolling && !H.scrollBar) De("translate3d(0px, -" + n.round(e.dtop) + "px, 0px)", !0), H.scrollingSpeed ? (clearTimeout(Ri), Ri = setTimeout(function() {
                    qt(e)
                }, H.scrollingSpeed)) : qt(e);
                else {
                    var i = Vt(e);
                    t(i.element).animate(i.options, H.scrollingSpeed, H.easing).promise().done(function() {
                        H.scrollBar ? setTimeout(function() {
                            qt(e)
                        }, 30) : qt(e)
                    })
                }
            }

            function Vt(t) {
                var e = {};
                return H.autoScrolling && !H.scrollBar ? (e.options = {
                    top: -t.dtop
                }, e.element = s) : (e.options = {
                    scrollTop: t.dtop
                }, e.element = "html, body"), e
            }

            function Wt(e) {
                return e.isMovementUp ? e.activeSection.before(e.activeSection.nextAll(y)) : e.activeSection.after(e.activeSection.prevAll(y).get().reverse()), ti(t(_).position().top), Bt(), e.wrapAroundElements = e.activeSection, e.dtop = e.element.position().top, e.yMovement = Pe(e.element), e.leavingSection = e.activeSection.index(y) + 1, e.sectionIndex = e.element.index(y), t(s).trigger("onContinuousVertical", [e]), e
            }

            function Xt(e) {
                e.wrapAroundElements && e.wrapAroundElements.length && (e.isMovementUp ? t(x).before(e.wrapAroundElements) : t(b).after(e.wrapAroundElements), ti(t(_).position().top), Bt(), e.sectionIndex = e.element.index(y), e.leavingSection = e.activeSection.index(y) + 1)
            }

            function qt(e) {
                Xt(e), t.isFunction(H.afterLoad) && !e.localIsResizing && H.afterLoad.call(e.element, e.anchorLink, e.sectionIndex + 1), H.scrollOverflow && H.scrollOverflowHandler.afterLoad(), ai("parallax", "afterLoad"), oi("scrollOverflowReset") && fi.scrollOverflowReset.reset(), H.resetSliders && fi.resetSliders && fi.resetSliders.apply(e), e.localIsResizing || Zt(e.element), e.element.addClass(m).siblings().removeClass(m), Mi = !0, t.isFunction(e.callback) && e.callback.call(this)
            }

            function Yt(t, e) {
                t.attr(e, t.data(e)).removeAttr("data-" + e)
            }

            function Qt(e) {
                if (H.lazyLoading) {
                    var i;
                    Kt(e).find("img[data-src], img[data-srcset], source[data-src], video[data-src], audio[data-src], iframe[data-src]").each(function() {
                        if (i = t(this), t.each(["src", "srcset"], function(t, e) {
                                var n = i.attr("data-" + e);
                                void 0 !== n && n && Yt(i, e)
                            }), i.is("source")) {
                            var e = i.closest("video").length ? "video" : "audio";
                            i.closest(e).get(0).load()
                        }
                    })
                }
            }

            function Zt(e) {
                var i = Kt(e);
                i.find("video, audio").each(function() {
                    var e = t(this).get(0);
                    e.hasAttribute("data-autoplay") && "function" == typeof e.play && e.play()
                }), i.find('iframe[src*="youtube.com/embed/"]').each(function() {
                    var e = t(this).get(0);
                    e.hasAttribute("data-autoplay") && Jt(e), e.onload = function() {
                        e.hasAttribute("data-autoplay") && Jt(e)
                    }
                })
            }

            function Jt(t) {
                t.contentWindow.postMessage('{"event":"command","func":"playVideo","args":""}', "*")
            }

            function $t(e) {
                var i = Kt(e);
                i.find("video, audio").each(function() {
                    var e = t(this).get(0);
                    e.hasAttribute("data-keepplaying") || "function" != typeof e.pause || e.pause()
                }), i.find('iframe[src*="youtube.com/embed/"]').each(function() {
                    var e = t(this).get(0);
                    /youtube\.com\/embed\//.test(t(this).attr("src")) && !e.hasAttribute("data-keepplaying") && t(this).get(0).contentWindow.postMessage('{"event":"command","func":"pauseVideo","args":""}', "*")
                })
            }

            function Kt(e) {
                var i = e.find(I);
                return i.length && (e = t(i)), e
            }

            function te(t) {
                function e(t) {
                    var e, n, o, a, s, l, c = "",
                        u = 0;
                    for (t = t.replace(/[^A-Za-z0-9+\/=]/g, ""); u < t.length;) e = r.indexOf(t.charAt(u++)) << 2 | (a = r.indexOf(t.charAt(u++))) >> 4, n = (15 & a) << 4 | (s = r.indexOf(t.charAt(u++))) >> 2, o = (3 & s) << 6 | (l = r.indexOf(t.charAt(u++))), c += String.fromCharCode(e), 64 != s && (c += String.fromCharCode(n)), 64 != l && (c += String.fromCharCode(o));
                    return c = i(c)
                }

                function i(t) {
                    for (var e, i = "", n = 0, r = 0, o = 0; n < t.length;)(r = t.charCodeAt(n)) < 128 ? (i += String.fromCharCode(r), n++) : r > 191 && r < 224 ? (o = t.charCodeAt(n + 1), i += String.fromCharCode((31 & r) << 6 | 63 & o), n += 2) : (o = t.charCodeAt(n + 1), e = t.charCodeAt(n + 2), i += String.fromCharCode((15 & r) << 12 | (63 & o) << 6 | 63 & e), n += 3);
                    return i
                }

                function n(t) {
                    return t.slice(3).slice(0, -3)
                }
                var r = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
                return function(t) {
                    return t
                }(function(t) {
                    var i = t.split("_");
                    if (i.length > 1) {
                        var r = i[1];
                        return t.replace(n(i[1]), "").split("_")[0] + "_" + e(r.slice(3).slice(0, -3))
                    }
                    return n(t)
                }(e(t)))
            }

            function ee() {
                if (i.domain.length) {
                    for (var t = i.domain.replace(/^(www\.)/, "").split("."); t.length > 2;) t.shift();
                    return t.join(".").replace(/(^\.*)|(\.*$)/g, "")
                }
                return ""
            }

            function ie(t) {
                var e = ee(),
                    i = ["MTM0bG9jYWxob3N0MjM0", "MTM0MC4xMjM0", "MTM0anNoZWxsLm5ldDIzNA==", "UDdDQU5ZNlNN"],
                    n = te(i[0]),
                    r = te(i[1]),
                    o = te(i[2]),
                    a = te(i[3]),
                    s = [n, r, o].indexOf(e) < 0 && 0 !== e.length,
                    l = void 0 !== ji[t] && ji[t].length;
                if (!l && s) return !1;
                var c = l ? te(ji[t]) : "",
                    u = (c = c.split("_")).length > 1 && c[1].indexOf(t, c[1].length - t.length) > -1;
                return !(c[0].indexOf(e, c[0].length - e.length) < 0 && s && a != c[0]) && u || !s
            }

            function ne(e) {
                function i() {
                    Bi || (n.random() < .5 ? pi.prepend(s) : pi.append(s), Bi = !0, s.bind("destroyed", function() {
                        clearTimeout(o), o = setTimeout(r, 900)
                    })), t(s).attr("style", te("MTIzei1pbmRleDo5OTk5OTk5O3Bvc2l0aW9uOmZpeGVkO3RvcDoyMHB4O2JvdHRvbTphdXRvO2xlZnQ6MjBweDtyaWdodDphdXRvO2JhY2tncm91bmQ6cmVkO3BhZGRpbmc6N3B4IDE1cHg7Zm9udC1zaXplOjE0cHg7Zm9udC1mYW1pbHk6YXJpYWw7Y29sb3I6I2ZmZjtkaXNwbGF5OmlubGluZS1ibG9jazt0cmFuc2Zvcm06dHJhbnNsYXRlM2QoMCwwLDApO29wYWNpdHk6MTtoZWlnaHQ6YXV0bzt3aWR0aDphdXRvO3pvb206MTttYXJnaW46YXV0bztib3JkZXI6bm9uZTt2aXNpYmlsaXR5OnZpc2libGU7Y2xpcC1wYXRoOm5vbmU7MTIz").replace(/;/g, te("MTIzICFpbXBvcnRhbnQ7MzQ1")))
                }

                function r() {
                    Bi = !1
                }
                if (oi(e) && fi[e]) {
                    var o, a = te("MTIzPGRpdj48YSBocmVmPSJodHRwOi8vYWx2YXJvdHJpZ28uY29tL2Z1bGxQYWdlL2V4dGVuc2lvbnMvIiBzdHlsZT0iY29sb3I6ICNmZmYgIWltcG9ydGFudDsgdGV4dC1kZWNvcmF0aW9uOm5vbmUgIWltcG9ydGFudDsiPlVubGljZW5zZWQgZnVsbFBhZ2UuanMgRXh0ZW5zaW9uPC9hPjwvZGl2PjEyMw=="),
                        s = t("<div/>").html(a).contents();
                    ie(e) || (i(), setInterval(i, 2e3))
                }
            }

            function re() {
                var t = ae(),
                    e = t.section,
                    i = t.slide;
                e && (H.animateAnchor ? ke(e, i) : at(e, i))
            }

            function oe() {
                if (!Hi && !H.lockAnchors) {
                    var t = ae(),
                        e = t.section,
                        i = t.slide,
                        n = void 0 === mi,
                        r = void 0 === mi && void 0 === i && !_i;
                    e.length && (e && e !== mi && !n || r || !_i && gi != i) && ke(e, i)
                }
            }

            function ae() {
                var t = e.location.hash,
                    i = t.replace("#", "").split("/"),
                    n = t.indexOf("#/") > -1;
                return {
                    section: n ? "/" + i[1] : decodeURIComponent(i[0]),
                    slide: n ? decodeURIComponent(i[2]) : decodeURIComponent(i[1])
                }
            }

            function se(e) {
                clearTimeout(Ni);
                var i = t(":focus");
                if (!i.is("textarea") && !i.is("input") && !i.is("select") && "true" !== i.attr("contentEditable") && "" !== i.attr("contentEditable") && H.keyboardScrolling && H.autoScrolling) {
                    var n = e.which,
                        r = [40, 38, 32, 33, 34];
                    t.inArray(n, r) > -1 && e.preventDefault(), vi = e.ctrlKey, Ni = setTimeout(function() {
                        ge(e)
                    }, 150)
                }
            }

            function le() {
                t(this).prev().trigger("click")
            }

            function ce(t) {
                Ei && (vi = t.ctrlKey)
            }

            function ue(t) {
                2 == t.which && (Ji = t.pageY, wi.on("mousemove", ve))
            }

            function he(t) {
                2 == t.which && wi.off("mousemove")
            }

            function de() {
                var e = t(this).closest(y);
                t(this).hasClass(V) ? Li.m.left && ct(e) : Li.m.right && lt(e)
            }

            function pe() {
                Ei = !1, vi = !1
            }

            function fe(e) {
                e.preventDefault();
                var i = t(this).parent().index();
                jt(t(y).eq(i))
            }

            function me(e) {
                e.preventDefault();
                var i = t(this).closest(y).find(N);
                ye(i, i.find(O).eq(t(this).closest("li").index()))
            }

            function ge(e) {
                var i = e.shiftKey;
                if (Mi || !([37, 39].indexOf(e.which) < 0)) switch (e.which) {
                    case 38:
                    case 33:
                        Li.k.up && rt();
                        break;
                    case 32:
                        if (i && Li.k.up) {
                            rt();
                            break
                        }
                    case 40:
                    case 34:
                        Li.k.down && ot();
                        break;
                    case 36:
                        Li.k.up && st(1);
                        break;
                    case 35:
                        Li.k.down && st(t(y).length);
                        break;
                    case 37:
                        Li.k.left && ct();
                        break;
                    case 39:
                        Li.k.right && lt();
                        break;
                    default:
                        return
                }
            }

            function ve(t) {
                Mi && (t.pageY < Ji && Li.m.up ? rt() : t.pageY > Ji && Li.m.down && ot()), Ji = t.pageY
            }

            function ye(e, i, n) {
                var r = e.closest(y),
                    o = {
                        slides: e,
                        destiny: i,
                        direction: n,
                        destinyPos: i.position(),
                        slideIndex: i.index(),
                        section: r,
                        sectionIndex: r.index(y),
                        anchorLink: r.data("anchor"),
                        slidesNav: r.find(z),
                        slideAnchor: He(i),
                        prevSlide: r.find(I),
                        prevSlideIndex: r.find(I).index(),
                        localIsResizing: Si
                    };
                return o.xMovement = Re(o.prevSlideIndex, o.slideIndex), o.localIsResizing || (Mi = !1), ai("parallax", "applyHorizontal", o), H.onSlideLeave && !o.localIsResizing && "none" !== o.xMovement && t.isFunction(H.onSlideLeave) && !1 === H.onSlideLeave.call(o.prevSlide, o.anchorLink, o.sectionIndex + 1, o.prevSlideIndex, o.direction, o.slideIndex) ? void(_i = !1) : (i.addClass(p).siblings().removeClass(p), o.localIsResizing || ($t(o.prevSlide), Qt(i)), _e(o), r.hasClass(p) && !o.localIsResizing && ze(o.slideIndex, o.slideAnchor, o.anchorLink, o.sectionIndex), fi.continuousHorizontal && fi.continuousHorizontal.apply(o), void(li() ? xe(o) : be(e, o, !0)))
            }

            function _e(t) {
                !H.loopHorizontal && H.controlArrows && (t.section.find(X).toggle(0 !== t.slideIndex), t.section.find(Q).toggle(!t.destiny.is(":last-child")))
            }

            function xe(e) {
                fi.continuousHorizontal && fi.continuousHorizontal.afterSlideLoads(e), we(e.slidesNav, e.slideIndex), e.localIsResizing || (ai("parallax", "afterSlideLoads"), t.isFunction(H.afterSlideLoad) && H.afterSlideLoad.call(e.destiny, e.anchorLink, e.sectionIndex + 1, e.slideAnchor, e.slideIndex), Mi = !0, Zt(e.destiny)), _i = !1, fi.interlockedSlides && fi.interlockedSlides.apply(e)
            }

            function be(t, e, i) {
                var r = e.destinyPos;
                if (H.css3) {
                    var o = "translate3d(-" + n.round(r.left) + "px, 0px, 0px)";
                    Ee(t.find(k)).css(ei(o)), Oi = setTimeout(function() {
                        i && xe(e)
                    }, H.scrollingSpeed, H.easing)
                } else t.animate({
                    scrollLeft: n.round(r.left)
                }, H.scrollingSpeed, H.easing, function() {
                    i && xe(e)
                })
            }

            function we(t, e) {
                t.find(f).removeClass(p), t.find("li").eq(e).find("a").addClass(p)
            }

            function Te() {
                if (wi.trigger("onResize"), Se(), xi) {
                    var e = t(i.activeElement);
                    if (!e.is("textarea") && !e.is("input") && !e.is("select")) {
                        var r = Z.height();
                        n.abs(r - $i) > 20 * n.max($i, r) / 100 && (ut(!0), $i = r)
                    }
                } else clearTimeout(Pi), Pi = setTimeout(function() {
                    ut(!0)
                }, 350)
            }

            function Se() {
                var t = H.responsive || H.responsiveWidth,
                    e = H.responsiveHeight,
                    i = t && Z.outerWidth() < t,
                    n = e && Z.height() < e;
                t && e ? ht(i || n) : t ? ht(i) : e && ht(n)
            }

            function Ee(t) {
                var e = "all " + H.scrollingSpeed + "ms " + H.easingcss3;
                return t.removeClass(c), t.css({
                    "-webkit-transition": e,
                    transition: e
                })
            }

            function Me(t) {
                return t.addClass(c)
            }

            function Ae(e, i) {
                H.navigation && (t(A).find(f).removeClass(p), e ? t(A).find('a[href="#' + e + '"]').addClass(p) : t(A).find("li").eq(i).find("a").addClass(p))
            }

            function Le(e) {
                H.menu && (t(H.menu).find(f).removeClass(p), t(H.menu).find('[data-menuanchor="' + e + '"]').addClass(p))
            }

            function Ce(t, e) {
                Le(t), Ae(t, e)
            }

            function Pe(e) {
                var i = t(_).index(y),
                    n = e.index(y);
                return i == n ? "none" : i > n ? "up" : "down"
            }

            function Re(t, e) {
                return t == e ? "none" : t > e ? "left" : "right"
            }

            function Oe(t) {
                t.hasClass(U) || t.addClass(U).wrapInner('<div class="' + w + '" style="height:' + Ie(t) + 'px;" />')
            }

            function Ie(t) {
                var e = gt(t);
                if (H.paddingTop || H.paddingBottom) {
                    var i = t;
                    i.hasClass(v) || (i = t.closest(y)), e -= parseInt(i.css("padding-top")) + parseInt(i.css("padding-bottom"))
                }
                return e
            }

            function De(t, e) {
                e ? Ee(wi) : Me(wi), clearTimeout(Fi), wi.css(ei(t)), Fi = setTimeout(function() {
                    wi.removeClass(c)
                }, 10)
            }

            function Ne(e) {
                if (!e) return [];
                var i = wi.find(y + '[data-anchor="' + e + '"]');
                return i.length || (i = t(y).eq(e - 1)), i
            }

            function Fe(t, e) {
                var i = e.find(N),
                    n = i.find(O + '[data-anchor="' + t + '"]');
                return n.length || (n = i.find(O).eq(t)), n
            }

            function ke(t, e) {
                var i = Ne(t);
                i.length && (void 0 === e && (e = 0), t === mi || i.hasClass(p) ? Ue(i, e) : jt(i, function() {
                    Ue(i, e)
                }))
            }

            function Ue(t, e) {
                if (void 0 !== e) {
                    var i = t.find(N),
                        n = Fe(e, t);
                    n.length && ye(i, n)
                }
            }

            function Be(t, e) {
                t.append('<div class="' + B + '"><ul></ul></div>');
                var i = t.find(z);
                i.addClass(H.slidesNavPosition);
                for (var n = 0; n < e; n++) i.find("ul").append('<li><a href="#"><span></span></a></li>');
                i.css("margin-left", "-" + i.width() / 2 + "px"), i.find("li").first().find("a").addClass(p)
            }

            function ze(t, e, i, n) {
                var r = "";
                H.anchors.length && !H.lockAnchors && (t ? (void 0 !== i && (r = i), void 0 === e && (e = t), gi = e, je(r + "/" + e)) : void 0 !== t ? (gi = e, je(i)) : je(i)), Ge()
            }

            function je(t) {
                if (H.recordHistory) location.hash = t;
                else if (xi || bi) e.history.replaceState(r, r, "#" + t);
                else {
                    var i = e.location.href.split("#")[0];
                    e.location.replace(i + "#" + t)
                }
            }

            function He(t) {
                var e = t.data("anchor"),
                    i = t.index();
                return void 0 === e && (e = i), e
            }

            function Ge() {
                var e = t(_),
                    i = e.find(I),
                    n = He(e),
                    r = He(i),
                    o = String(n);
                i.length && (o = o + "-" + r), o = o.replace("/", "-").replace("#", "");
                var a = new RegExp("\\b\\s?" + d + "-[^\\s]+\\b", "g");
                pi[0].className = pi[0].className.replace(a, ""), pi.addClass(d + "-" + o)
            }

            function Ve() {
                var t, n = i.createElement("p"),
                    o = {
                        webkitTransform: "-webkit-transform",
                        OTransform: "-o-transform",
                        msTransform: "-ms-transform",
                        MozTransform: "-moz-transform",
                        transform: "transform"
                    };
                i.body.insertBefore(n, null);
                for (var a in o) n.style[a] !== r && (n.style[a] = "translate3d(1px,1px,1px)", t = e.getComputedStyle(n).getPropertyValue(o[a]));
                return i.body.removeChild(n), t !== r && t.length > 0 && "none" !== t
            }

            function We() {
                i.addEventListener ? (i.removeEventListener("mousewheel", kt, !1), i.removeEventListener("wheel", kt, !1), i.removeEventListener("MozMousePixelScroll", kt, !1)) : i.detachEvent("onmousewheel", kt)
            }

            function Xe() {
                var t, n = "";
                e.addEventListener ? t = "addEventListener" : (t = "attachEvent", n = "on");
                var o = "onwheel" in i.createElement("div") ? "wheel" : i.onmousewheel !== r ? "mousewheel" : "DOMMouseScroll";
                "DOMMouseScroll" == o ? i[t](n + "MozMousePixelScroll", kt, !1) : i[t](n + o, kt, !1)
            }

            function qe() {
                wi.on("mousedown", ue).on("mouseup", he)
            }

            function Ye() {
                wi.off("mousedown", ue).off("mouseup", he)
            }

            function Qe() {
                (xi || bi) && (H.autoScrolling && pi.off(Ui.touchmove).on(Ui.touchmove, Ot), t(s).off(Ui.touchstart).on(Ui.touchstart, Nt).off(Ui.touchmove).on(Ui.touchmove, It))
            }

            function Ze() {
                (xi || bi) && t(s).off(Ui.touchstart).off(Ui.touchmove)
            }

            function Je() {
                return e.PointerEvent ? {
                    down: "pointerdown",
                    move: "pointermove"
                } : {
                    down: "MSPointerDown",
                    move: "MSPointerMove"
                }
            }

            function $e(t) {
                var e = [];
                return e.y = void 0 !== t.pageY && (t.pageY || t.pageX) ? t.pageY : t.touches[0].pageY, e.x = void 0 !== t.pageX && (t.pageY || t.pageX) ? t.pageX : t.touches[0].pageX, bi && Dt(t) && H.scrollBar && void 0 !== t.touches && (e.y = t.touches[0].pageY, e.x = t.touches[0].pageX), e
            }

            function Ke(t, e) {
                K(0, "internal"), void 0 !== e && (Si = !0), ye(t.closest(N), t), void 0 !== e && (Si = !1), K(zi.scrollingSpeed, "internal")
            }

            function ti(t) {
                var e = n.round(t);
                H.css3 && H.autoScrolling && !H.scrollBar ? De("translate3d(0px, -" + e + "px, 0px)", !1) : H.autoScrolling && !H.scrollBar ? wi.css("top", -e) : di.scrollTop(e)
            }

            function ei(t) {
                return {
                    "-webkit-transform": t,
                    "-moz-transform": t,
                    "-ms-transform": t,
                    transform: t
                }
            }

            function ii(e, i, n) {
                "all" !== i ? Li[n][i] = e : t.each(Object.keys(Li[n]), function(t, i) {
                    Li[n][i] = e
                })
            }

            function ni() {
                ti(0), wi.find("img[data-src], source[data-src], audio[data-src], iframe[data-src]").each(function() {
                    Yt(t(this), "src")
                }), wi.find("img[data-srcset]").each(function() {
                    Yt(t(this), "srcset")
                }), t(A + ", " + z + ", " + G).remove(), t(y).css({
                    height: "",
                    "background-color": "",
                    padding: ""
                }), t(O).css({
                    width: ""
                }), wi.css({
                    height: "",
                    position: "",
                    "-ms-touch-action": "",
                    "touch-action": ""
                }), di.css({
                    overflow: "",
                    height: ""
                }), t("html").removeClass(h), pi.removeClass(l), t.each(pi.get(0).className.split(/\s+/), function(t, e) {
                    0 === e.indexOf(d) && pi.removeClass(e)
                }), t(y + ", " + O).each(function() {
                    H.scrollOverflowHandler && H.scrollOverflowHandler.remove(t(this)), t(this).removeClass(U + " " + p)
                }), ri(wi), wi.find(T + ", " + k + ", " + N).each(function() {
                    t(this).replaceWith(this.childNodes)
                }), di.scrollTop(0);
                var e = [v, R, F];
                t.each(e, function(e, i) {
                    t("." + i).removeClass(i)
                })
            }

            function ri(t) {
                return t.css({
                    "-webkit-transition": "none",
                    transition: "none"
                })
            }

            function oi(t) {
                return null !== H[t] && "object" == o(H[t]) ? H[t].enabled && fi[t] : H[t] && fi[t]
            }

            function ai(t, e, i) {
                if (oi(t)) return fi[t][e](i)
            }

            function si() {
                return oi("dragAndMove") && fi.dragAndMove.isAnimating
            }

            function li() {
                return oi("dragAndMove") && fi.dragAndMove.isGrabbing
            }

            function ci(t, e, i) {
                H[t] = e, "internal" !== i && (zi[t] = e)
            }

            function ui() {
                return t("html").hasClass(h) ? void hi("error", "Fullpage.js can only be initialized once and you are doing it multiple times!") : (H.continuousVertical && (H.loopTop || H.loopBottom) && (H.continuousVertical = !1, hi("warn", "Option `loopTop/loopBottom` is mutually exclusive with `continuousVertical`; `continuousVertical` disabled")), H.scrollBar && H.scrollOverflow && hi("warn", "Option `scrollBar` is mutually exclusive with `scrollOverflow`. Sections with scrollOverflow might not work well in Firefox"), !H.continuousVertical || !H.scrollBar && H.autoScrolling || (H.continuousVertical = !1, hi("warn", "Scroll bars (`scrollBar:true` or `autoScrolling:false`) are mutually exclusive with `continuousVertical`; `continuousVertical` disabled")), H.scrollOverflow && !H.scrollOverflowHandler && (H.scrollOverflow = !1, hi("error", "The option `scrollOverflow:true` requires the file `scrolloverflow.min.js`. Please include it before fullPage.js.")), void t.each(H.anchors, function(e, i) {
                    var n = J.find("[name]").filter(function() {
                            return t(this).attr("name") && t(this).attr("name").toLowerCase() == i.toLowerCase()
                        }),
                        r = J.find("[id]").filter(function() {
                            return t(this).attr("id") && t(this).attr("id").toLowerCase() == i.toLowerCase()
                        });
                    (r.length || n.length) && (hi("error", "data-anchor tags can not have the same value as any `id` element on the site (or `name` element for IE)."), r.length && hi("error", '"' + i + '" is is being used by another element `id` property'), n.length && hi("error", '"' + i + '" is is being used by another element `name` property'))
                }))
            }

            function hi(t, e) {
                console && console[t] && console[t]("fullPage: " + e)
            }
            if (t("html").hasClass(h)) ui();
            else {
                var di = t("html, body"),
                    pi = t("body"),
                    fi = t.fn.fullpage;
                H = t.extend(!0, {
                    menu: !1,
                    anchors: [],
                    lockAnchors: !1,
                    navigation: !1,
                    navigationPosition: "right",
                    navigationTooltips: [],
                    showActiveTooltip: !1,
                    slidesNavigation: !1,
                    slidesNavPosition: "bottom",
                    scrollBar: !1,
                    hybrid: !1,
                    css3: !0,
                    scrollingSpeed: 700,
                    autoScrolling: !0,
                    fitToSection: !0,
                    fitToSectionDelay: 1e3,
                    easing: "easeInOutCubic",
                    easingcss3: "ease",
                    loopBottom: !1,
                    loopTop: !1,
                    loopHorizontal: !0,
                    continuousVertical: !1,
                    continuousHorizontal: !1,
                    scrollHorizontally: !1,
                    interlockedSlides: !1,
                    dragAndMove: !1,
                    offsetSections: !1,
                    resetSliders: !1,
                    fadingEffect: !1,
                    normalScrollElements: null,
                    scrollOverflow: !1,
                    scrollOverflowReset: !1,
                    scrollOverflowHandler: t.fn.fp_scrolloverflow ? t.fn.fp_scrolloverflow.iscrollHandler : null,
                    scrollOverflowOptions: null,
                    touchSensitivity: 5,
                    normalScrollElementTouchThreshold: 5,
                    bigSectionsDestination: null,
                    keyboardScrolling: !0,
                    animateAnchor: !0,
                    recordHistory: !0,
                    controlArrows: !0,
                    controlArrowColor: "#fff",
                    verticalCentered: !0,
                    sectionsColor: [],
                    paddingTop: 0,
                    paddingBottom: 0,
                    fixedElements: null,
                    responsive: 0,
                    responsiveWidth: 0,
                    responsiveHeight: 0,
                    responsiveSlides: !1,
                    parallax: !1,
                    parallaxOptions: {
                        type: "reveal",
                        percentage: 62,
                        property: "translate"
                    },
                    sectionSelector: ".section",
                    slideSelector: ".slide",
                    afterLoad: null,
                    onLeave: null,
                    afterRender: null,
                    afterResize: null,
                    afterReBuild: null,
                    afterSlideLoad: null,
                    onSlideLeave: null,
                    afterResponsive: null,
                    lazyLoading: !0
                }, H);
                var mi, gi, vi, yi, _i = !1,
                    xi = navigator.userAgent.match(/(iPhone|iPod|iPad|Android|playbook|silk|BlackBerry|BB10|Windows Phone|Tizen|Bada|webOS|IEMobile|Opera Mini)/),
                    bi = "ontouchstart" in e || navigator.msMaxTouchPoints > 0 || navigator.maxTouchPoints,
                    wi = t(this),
                    Ti = Z.height(),
                    Si = !1,
                    Ei = !0,
                    Mi = !0,
                    Ai = [],
                    Li = {};
                Li.m = {
                    up: !0,
                    down: !0,
                    left: !0,
                    right: !0
                }, Li.k = t.extend(!0, {}, Li.m);
                var Ci, Pi, Ri, Oi, Ii, Di, Ni, Fi, ki = Je(),
                    Ui = {
                        touchmove: "ontouchmove" in e ? "touchmove" : ki.move,
                        touchstart: "ontouchstart" in e ? "touchstart" : ki.down
                    },
                    Bi = !1,
                    zi = t.extend(!0, {}, H),
                    ji = {};
                ui(), t.extend(t.easing, {
                    easeInOutCubic: function(t, e, i, n, r) {
                        return (e /= r / 2) < 1 ? n / 2 * e * e * e + i : n / 2 * ((e -= 2) * e * e + 2) + i
                    }
                }), t.event.special.destroyed = {
                    remove: function(t) {
                        t.handler && t.handler()
                    }
                }, t(this).length && (fi.version = "2.9.5", fi.setAutoScrolling = q, fi.setRecordHistory = $, fi.setScrollingSpeed = K, fi.setFitToSection = tt, fi.setLockAnchors = function(t) {
                    H.lockAnchors = t
                }, fi.setMouseWheelScrolling = et, fi.setAllowScrolling = it, fi.setKeyboardScrolling = nt, fi.moveSectionUp = rt, fi.moveSectionDown = ot, fi.silentMoveTo = at, fi.moveTo = st, fi.moveSlideRight = lt, fi.moveSlideLeft = ct, fi.fitToSection = Ct, fi.reBuild = ut, fi.setResponsive = ht, fi.getFullpageData = function() {
                    return {
                        options: H,
                        internals: {
                            canScroll: Mi,
                            isScrollAllowed: Li,
                            getDestinationPosition: zt,
                            isTouch: bi,
                            c: ne,
                            getXmovement: Re,
                            removeAnimation: Me,
                            getTransforms: ei,
                            lazyLoad: Qt,
                            addAnimation: Ee,
                            performHorizontalMove: be,
                            landscapeScroll: ye,
                            silentLandscapeScroll: Ke,
                            keepSlidesPosition: Bt,
                            silentScroll: ti,
                            styleSlides: mt,
                            scrollHandler: At,
                            getEventsPage: $e,
                            getMSPointer: Je,
                            isReallyTouch: Dt,
                            usingExtension: oi,
                            toggleControlArrows: _e
                        }
                    }
                }, fi.destroy = function(e) {
                    wi.trigger("destroy", [e]), q(!1, "internal"), it(!1), nt(!1), wi.addClass(u), clearTimeout(Oi), clearTimeout(Ri), clearTimeout(Pi), clearTimeout(Ii), clearTimeout(Di), Z.off("scroll", At).off("hashchange", oe).off("resize", Te), J.off("click touchstart", A + " a").off("mouseenter", A + " li").off("mouseleave", A + " li").off("click touchstart", j).off("mouseover", H.normalScrollElements).off("mouseout", H.normalScrollElements), t(y).off("click touchstart", G), oi("dragAndMove") && fi.dragAndMove.destroy(), clearTimeout(Oi), clearTimeout(Ri), e && ni()
                }, fi.landscapeScroll = ye, fi.shared = {
                    afterRenderActions: Et
                }, dt("continuousHorizontal"), dt("scrollHorizontally"), dt("resetSliders"), dt("interlockedSlides"), dt("responsiveSlides"), dt("fadingEffect"), dt("dragAndMove"), dt("offsetSections"), dt("scrollOverflowReset"), dt("parallax"), oi("dragAndMove") && fi.dragAndMove.init(), H.css3 && (H.css3 = Ve()), H.scrollBar = H.scrollBar || H.hybrid, pt(), ft(), it(!0), q(H.autoScrolling, "internal"), Se(), Ge(), "complete" === i.readyState && re(), Z.on("load", re), Z.on("scroll", At).on("hashchange", oe).blur(pe).resize(Te), J.keydown(se).keyup(ce).on("click touchstart", A + " a", fe).on("click touchstart", j, me).on("click", C, le), t(y).on("click touchstart", G, de), H.normalScrollElements && (J.on("mouseenter touchstart", H.normalScrollElements, function() {
                    it(!1)
                }), J.on("mouseleave touchend", H.normalScrollElements, function() {
                    it(!0)
                })), oi("dragAndMove") && fi.dragAndMove.turnOffTouch());
                var Hi = !1,
                    Gi = 0,
                    Vi = 0,
                    Wi = 0,
                    Xi = 0,
                    qi = 0;
                ! function() {
                    var t = e.requestAnimationFrame || e.mozRequestAnimationFrame || e.webkitRequestAnimationFrame || e.msRequestAnimationFrame;
                    e.requestAnimationFrame = t
                }();
                var Yi = (new Date).getTime(),
                    Qi = !1,
                    Zi = 0,
                    Ji = 0,
                    $i = Ti
            }
        }
    })
}, function(t, e, i) {
    "use strict";
    ! function(t) {
        window.fp_fadingEffectExtension = function() {
            function e() {
                t(d).on("afterResponsive", i)
            }

            function i(t, e) {
                e ? (a = !1, s.turnOff()) : (a = o.autoScrolling, s.turnOn())
            }
            var n, r, o, a, s = this,
                l = t.fn.fullpage.getFullpageData(),
                c = l.options,
                u = l.internals,
                h = c.scrollingSpeed,
                d = ".fullpage-wrapper",
                p = ".active",
                f = ".fp-section",
                m = f + p,
                g = ".fp-slide",
                v = "fp-fading-animations",
                y = "#" + v,
                _ = "fp-fading-sheet",
                x = "#" + _;
            s.apply = function() {
                e(), o = t.extend(!0, {}, c), a = o.autoScrolling, c.scrollBar = !1, s.isFadingPanel("sections") && t.fn.fullpage.setAutoScrolling(!0);
                var i = s.isFadingPanel("slides") ? s.getStyles(g) : "",
                    n = s.isFadingPanel("sections") ? s.getStyles(f) : "";
                c.fadingEffect && s.appendStyleSheet(_, n + i), clearTimeout(r), r = setTimeout(s.applyAnimation, 300)
            }, s.isFadingPanel = function(t) {
                return !0 === c.fadingEffect || c.fadingEffect === t
            }, s.appendStyleSheet = function(e, i) {
                t('<style id="' + e + '">' + i + "</style>").appendTo("head")
            }, s.applyAnimation = function() {
                n = s.getTransition();
                var t = s.isFadingPanel("slides") ? s.getPanelAnimation(g) : "",
                    e = s.isFadingPanel("sections") ? s.getPanelAnimation(f) : "";
                s.appendStyleSheet(v, t + e)
            }, s.getPanelAnimation = function(t) {
                return t + "{-webkit-transition: " + n + ";transition: " + n + ";}"
            }, s.getStyles = function(t) {
                return s.getContainerStyles(t) + "" + s.getPanelStyles(t) + s.getActivePanelStyles(t)
            }, s.getContainerStyles = function(t) {
                return t === g ? ".fp-slidesContainer {width: 100% !important;transform: none!important;}" : ""
            }, s.getPanelStyles = function(t) {
                return t + "{width: 100% !important;position: absolute;left: 0;top: 0;visibility: hidden;opacity: 0;}"
            }, s.getActivePanelStyles = function(t) {
                return t + ".active{visibility: visible;opacity: 1;}"
            }, s.update = function(e) {
                t(y).remove(), h = e, s.applyAnimation()
            }, s.getTransition = function() {
                return "all " + h + "ms " + c.easingcss3
            }, s.turnOff = function() {
                if (t(x).length) {
                    t(y).remove();
                    var e = t(m).find(".fp-slide.active"),
                        i = t(m).find(".fp-slidesContainer");
                    u.removeAnimation(i), t(x).remove(), c.scrollBar = o.scrollBar, t.fn.fullpage.setAutoScrolling(a), e.length && u.silentLandscapeScroll(e)
                }
            }, s.turnOn = function() {
                t(x).length || (s.apply(), t("html,body").scrollTop(0), u.silentScroll(0))
            }, s.c = u.c;
            var b = s["common".charAt(0)];
            return "complete" === document.readyState && b("fadingEffect"), t(window).on("load", function() {
                b("fadingEffect")
            }), s
        }
    }(i(8))
}, function(t, e, i) {
    "use strict";

    function n(t, e) {
        if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
    }
    var r = function() {
            function t(t, e) {
                for (var i = 0; i < e.length; i++) {
                    var n = e[i];
                    n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(t, n.key, n)
                }
            }
            return function(e, i, n) {
                return i && t(e.prototype, i), n && t(e, n), e
            }
        }(),
        o = i(13),
        a = i(8),
        s = (i(4), function() {
            function t() {
                var e = this;
                n(this, t), this.queue = new o.LoadQueue, this.dom = {}, this.progressHandlers = [], this.completeHandlers = [], this.transitionOutHandlers = [], this.queue.on("progress", function(t) {
                    return e.progressHandlers.forEach(function(i) {
                        return i(t, e)
                    })
                }), this.queue.on("complete", function(t) {
                    return e.completeHandlers.forEach(function(i) {
                        return i(t, e)
                    })
                }), this.queue.on("error", function(t) {
                    return console.log(t)
                }), this.queue.setMaxConnections(5), this.addOnProgress(function(t) {
                    var i = Math.round(100 * e.queue.progress);
                    a(".pl-progress").css("width", i + "%"), a(".plc-number").html(i)
                }), this.addOnComplete(function(t) {
                    TweenLite.to(a(".pl-progress-wrap"), 1, {
                        scaleX: 0,
                        delay: .4,
                        ease: Power4.easeInOut,
                        onComplete: function() {
                            e.transitionOutHandlers.forEach(function(t) {
                                return t(e)
                            })
                        }
                    }), a(".plc-number").addClass("hide"), TweenLite.to(a(".plc-vc-cover.left"), 2, {
                        x: "-100%",
                        delay: 1.6,
                        ease: Power4.easeInOut,
                        onComplete: function() {
                            a("#preloader").hide()
                        }
                    }), TweenLite.to(a(".plc-vc-cover.right"), 2, {
                        x: "100%",
                        delay: 1.6,
                        ease: Power4.easeInOut
                    }), TweenLite.to(a(".plc-vc-cover.top"), 2, {
                        y: "-100%",
                        delay: 1.6,
                        ease: Power4.easeInOut
                    }), TweenLite.to(a(".plc-vc-cover.bottom"), 2, {
                        y: "100%",
                        delay: 1.6,
                        ease: Power4.easeInOut
                    })
                })
            }
            return r(t, [{
                key: "addOnProgress",
                value: function(t) {
                    this.progressHandlers.push(t)
                }
            }, {
                key: "addOnComplete",
                value: function(t) {
                    this.completeHandlers.push(t)
                }
            }, {
                key: "addOnTransitionOut",
                value: function(t) {
                    this.transitionOutHandlers.push(t)
                }
            }]), t
        }());
    t.exports = s
}, function(module, exports) {
    window.createjs = window.createjs || {},
        function() {
            "use strict";
            var t = createjs.PreloadJS = createjs.PreloadJS || {};
            t.version = "0.4.1", t.buildDate = "Thu, 12 Dec 2013 23:33:38 GMT"
        }(),
        function() {
            "use strict";
            var t = function(t, e, i) {
                    this.initialize(t, e, i)
                },
                e = t.prototype;
            e.type = null, e.target = null, e.currentTarget = null, e.eventPhase = 0, e.bubbles = !1, e.cancelable = !1, e.timeStamp = 0, e.defaultPrevented = !1, e.propagationStopped = !1, e.immediatePropagationStopped = !1, e.removed = !1, e.initialize = function(t, e, i) {
                this.type = t, this.bubbles = e, this.cancelable = i, this.timeStamp = (new Date).getTime()
            }, e.preventDefault = function() {
                this.defaultPrevented = !0
            }, e.stopPropagation = function() {
                this.propagationStopped = !0
            }, e.stopImmediatePropagation = function() {
                this.immediatePropagationStopped = this.propagationStopped = !0
            }, e.remove = function() {
                this.removed = !0
            }, e.clone = function() {
                return new t(this.type, this.bubbles, this.cancelable)
            }, e.toString = function() {
                return "[Event (type=" + this.type + ")]"
            }, createjs.Event = t
        }(),
        function() {
            "use strict";
            var t = function() {},
                e = t.prototype;
            t.initialize = function(t) {
                t.addEventListener = e.addEventListener, t.on = e.on, t.removeEventListener = t.off = e.removeEventListener, t.removeAllEventListeners = e.removeAllEventListeners, t.hasEventListener = e.hasEventListener, t.dispatchEvent = e.dispatchEvent, t._dispatchEvent = e._dispatchEvent, t.willTrigger = e.willTrigger
            }, e._listeners = null, e._captureListeners = null, e.initialize = function() {}, e.addEventListener = function(t, e, i) {
                var n, r = (n = i ? this._captureListeners = this._captureListeners || {} : this._listeners = this._listeners || {})[t];
                return r && this.removeEventListener(t, e, i), r = n[t], r ? r.push(e) : n[t] = [e], e
            }, e.on = function(t, e, i, n, r, o) {
                return e.handleEvent && (i = i || e, e = e.handleEvent), i = i || this, this.addEventListener(t, function(t) {
                    e.call(i, t, r), n && t.remove()
                }, o)
            }, e.removeEventListener = function(t, e, i) {
                var n = i ? this._captureListeners : this._listeners;
                if (n) {
                    var r = n[t];
                    if (r)
                        for (var o = 0, a = r.length; a > o; o++)
                            if (r[o] == e) {
                                1 == a ? delete n[t] : r.splice(o, 1);
                                break
                            }
                }
            }, e.off = e.removeEventListener, e.removeAllEventListeners = function(t) {
                t ? (this._listeners && delete this._listeners[t], this._captureListeners && delete this._captureListeners[t]) : this._listeners = this._captureListeners = null
            }, e.dispatchEvent = function(t, e) {
                if ("string" == typeof t) {
                    var i = this._listeners;
                    if (!i || !i[t]) return !1;
                    t = new createjs.Event(t)
                }
                if (t.target = e || this, t.bubbles && this.parent) {
                    for (var n = this, r = [n]; n.parent;) r.push(n = n.parent);
                    var o, a = r.length;
                    for (o = a - 1; o >= 0 && !t.propagationStopped; o--) r[o]._dispatchEvent(t, 1 + (0 == o));
                    for (o = 1; a > o && !t.propagationStopped; o++) r[o]._dispatchEvent(t, 3)
                } else this._dispatchEvent(t, 2);
                return t.defaultPrevented
            }, e.hasEventListener = function(t) {
                var e = this._listeners,
                    i = this._captureListeners;
                return !!(e && e[t] || i && i[t])
            }, e.willTrigger = function(t) {
                for (var e = this; e;) {
                    if (e.hasEventListener(t)) return !0;
                    e = e.parent
                }
                return !1
            }, e.toString = function() {
                return "[EventDispatcher]"
            }, e._dispatchEvent = function(t, e) {
                var i, n = 1 == e ? this._captureListeners : this._listeners;
                if (t && n) {
                    var r = n[t.type];
                    if (!r || !(i = r.length)) return;
                    t.currentTarget = this, t.eventPhase = e, t.removed = !1, r = r.slice();
                    for (var o = 0; i > o && !t.immediatePropagationStopped; o++) {
                        var a = r[o];
                        a.handleEvent ? a.handleEvent(t) : a(t), t.removed && (this.off(t.type, a, 1 == e), t.removed = !1)
                    }
                }
            }, createjs.EventDispatcher = t
        }(),
        function() {
            "use strict";
            createjs.indexOf = function(t, e) {
                for (var i = 0, n = t.length; n > i; i++)
                    if (e === t[i]) return i;
                return -1
            }
        }(),
        function() {
            "use strict";
            createjs.proxy = function(t, e) {
                var i = Array.prototype.slice.call(arguments, 2);
                return function() {
                    return t.apply(e, Array.prototype.slice.call(arguments, 0).concat(i))
                }
            }
        }(),
        function() {
            "use strict";
            var t = function() {
                    this.init()
                },
                e = t.prototype = new createjs.EventDispatcher,
                i = t;
            i.FILE_PATTERN = /^(?:(\w+:)\/{2}(\w+(?:\.\w+)*\/?)|(.{0,2}\/{1}))?([/.]*?(?:[^?]+)?\/)?((?:[^/?]+)\.(\w+))(?:\?(\S+)?)?$/, i.PATH_PATTERN = /^(?:(\w+:)\/{2})|(.{0,2}\/{1})?([/.]*?(?:[^?]+)?\/?)?$/, e.loaded = !1, e.canceled = !1, e.progress = 0, e._item = null, e.getItem = function() {
                return this._item
            }, e.init = function() {}, e.load = function() {}, e.close = function() {}, e._sendLoadStart = function() {
                this._isCanceled() || this.dispatchEvent("loadstart")
            }, e._sendProgress = function(t) {
                if (!this._isCanceled()) {
                    var e = null;
                    "number" == typeof t ? (this.progress = t, e = new createjs.Event("progress"), e.loaded = this.progress, e.total = 1) : (e = t, this.progress = t.loaded / t.total, (isNaN(this.progress) || 1 / 0 == this.progress) && (this.progress = 0)), e.progress = this.progress, this.hasEventListener("progress") && this.dispatchEvent(e)
                }
            }, e._sendComplete = function() {
                this._isCanceled() || this.dispatchEvent("complete")
            }, e._sendError = function(t) {
                !this._isCanceled() && this.hasEventListener("error") && (null == t && (t = new createjs.Event("error")), this.dispatchEvent(t))
            }, e._isCanceled = function() {
                return !(null != window.createjs && !this.canceled)
            }, e._parseURI = function(t) {
                return t ? t.match(i.FILE_PATTERN) : null
            }, e._parsePath = function(t) {
                return t ? t.match(i.PATH_PATTERN) : null
            }, e._formatQueryString = function(t, e) {
                if (null == t) throw new Error("You must specify data.");
                var i = [];
                for (var n in t) i.push(n + "=" + escape(t[n]));
                return e && (i = i.concat(e)), i.join("&")
            }, e.buildPath = function(t, e) {
                if (null == e) return t;
                var i = [],
                    n = t.indexOf("?");
                if (-1 != n) {
                    var r = t.slice(n + 1);
                    i = i.concat(r.split("&"))
                }
                return -1 != n ? t.slice(0, n) + "?" + this._formatQueryString(e, i) : t + "?" + this._formatQueryString(e, i)
            }, e._isCrossDomain = function(t) {
                var e = document.createElement("a");
                e.href = t.src;
                var i = document.createElement("a");
                return i.href = location.href, "" != e.hostname && (e.port != i.port || e.protocol != i.protocol || e.hostname != i.hostname)
            }, e._isLocal = function(t) {
                var e = document.createElement("a");
                return e.href = t.src, "" == e.hostname && "file:" == e.protocol
            }, e.toString = function() {
                return "[PreloadJS AbstractLoader]"
            }, createjs.AbstractLoader = t
        }(),
        function() {
            "use strict";
            var t = function(t, e, i) {
                    this.init(t, e, i)
                },
                e = t.prototype = new createjs.AbstractLoader,
                i = t;
            i.loadTimeout = 8e3, i.LOAD_TIMEOUT = 0, i.BINARY = "binary", i.CSS = "css", i.IMAGE = "image", i.JAVASCRIPT = "javascript", i.JSON = "json", i.JSONP = "jsonp", i.MANIFEST = "manifest", i.SOUND = "sound", i.SVG = "svg", i.TEXT = "text", i.XML = "xml", i.POST = "POST", i.GET = "GET", e._basePath = null, e._crossOrigin = "", e.useXHR = !0, e.stopOnError = !1, e.maintainScriptOrder = !0, e.next = null, e._typeCallbacks = null, e._extensionCallbacks = null, e._loadStartWasDispatched = !1, e._maxConnections = 1, e._currentlyLoadingScript = null, e._currentLoads = null, e._loadQueue = null, e._loadQueueBackup = null, e._loadItemsById = null, e._loadItemsBySrc = null, e._loadedResults = null, e._loadedRawResults = null, e._numItems = 0, e._numItemsLoaded = 0, e._scriptOrder = null, e._loadedScripts = null, e.init = function(t, e, i) {
                this._numItems = this._numItemsLoaded = 0, this._paused = !1, this._loadStartWasDispatched = !1, this._currentLoads = [], this._loadQueue = [], this._loadQueueBackup = [], this._scriptOrder = [], this._loadedScripts = [], this._loadItemsById = {}, this._loadItemsBySrc = {}, this._loadedResults = {}, this._loadedRawResults = {}, this._typeCallbacks = {}, this._extensionCallbacks = {}, this._basePath = e, this.setUseXHR(t), this._crossOrigin = !0 === i ? "Anonymous" : !1 === i || null == i ? "" : i
            }, e.setUseXHR = function(t) {
                return this.useXHR = 0 != t && null != window.XMLHttpRequest, this.useXHR
            }, e.removeAll = function() {
                this.remove()
            }, e.remove = function(t) {
                var e = null;
                if (!t || t instanceof Array) {
                    if (t) e = t;
                    else if (arguments.length > 0) return
                } else e = [t];
                var i = !1;
                if (e) {
                    for (; e.length;) {
                        var n = e.pop(),
                            r = this.getResult(n);
                        for (o = this._loadQueue.length - 1; o >= 0; o--)
                            if ((a = this._loadQueue[o].getItem()).id == n || a.src == n) {
                                this._loadQueue.splice(o, 1)[0].cancel();
                                break
                            } for (o = this._loadQueueBackup.length - 1; o >= 0; o--)
                            if ((a = this._loadQueueBackup[o].getItem()).id == n || a.src == n) {
                                this._loadQueueBackup.splice(o, 1)[0].cancel();
                                break
                            } if (r) delete this._loadItemsById[r.id], delete this._loadItemsBySrc[r.src], this._disposeItem(r);
                        else
                            for (var o = this._currentLoads.length - 1; o >= 0; o--) {
                                var a = this._currentLoads[o].getItem();
                                if (a.id == n || a.src == n) {
                                    this._currentLoads.splice(o, 1)[0].cancel(), i = !0;
                                    break
                                }
                            }
                    }
                    i && this._loadNext()
                } else {
                    this.close();
                    for (var s in this._loadItemsById) this._disposeItem(this._loadItemsById[s]);
                    this.init(this.useXHR)
                }
            }, e.reset = function() {
                this.close();
                for (var t in this._loadItemsById) this._disposeItem(this._loadItemsById[t]);
                for (var e = [], i = 0, n = this._loadQueueBackup.length; n > i; i++) e.push(this._loadQueueBackup[i].getItem());
                this.loadManifest(e, !1)
            }, i.isBinary = function(t) {
                switch (t) {
                    case createjs.LoadQueue.IMAGE:
                    case createjs.LoadQueue.BINARY:
                        return !0;
                    default:
                        return !1
                }
            }, i.isText = function(t) {
                switch (t) {
                    case createjs.LoadQueue.TEXT:
                    case createjs.LoadQueue.JSON:
                    case createjs.LoadQueue.MANIFEST:
                    case createjs.LoadQueue.XML:
                    case createjs.LoadQueue.HTML:
                    case createjs.LoadQueue.CSS:
                    case createjs.LoadQueue.SVG:
                    case createjs.LoadQueue.JAVASCRIPT:
                        return !0;
                    default:
                        return !1
                }
            }, e.installPlugin = function(t) {
                if (null != t && null != t.getPreloadHandlers) {
                    var e = t.getPreloadHandlers();
                    if (e.scope = t, null != e.types)
                        for (var i = 0, n = e.types.length; n > i; i++) this._typeCallbacks[e.types[i]] = e;
                    if (null != e.extensions)
                        for (i = 0, n = e.extensions.length; n > i; i++) this._extensionCallbacks[e.extensions[i]] = e
                }
            }, e.setMaxConnections = function(t) {
                this._maxConnections = t, !this._paused && this._loadQueue.length > 0 && this._loadNext()
            }, e.loadFile = function(t, e, i) {
                if (null == t) {
                    var n = new createjs.Event("error");
                    return n.text = "PRELOAD_NO_FILE", void this._sendError(n)
                }
                this._addItem(t, null, i), !1 !== e ? this.setPaused(!1) : this.setPaused(!0)
            }, e.loadManifest = function(t, e, n) {
                var r = null,
                    o = null;
                if (t instanceof Array) {
                    if (0 == t.length) return (a = new createjs.Event("error")).text = "PRELOAD_MANIFEST_EMPTY", void this._sendError(a);
                    r = t
                } else if ("string" == typeof t) r = [{
                    src: t,
                    type: i.MANIFEST
                }];
                else {
                    if ("object" != typeof t) return (a = new createjs.Event("error")).text = "PRELOAD_MANIFEST_NULL", void this._sendError(a);
                    if (void 0 !== t.src) {
                        if (null == t.type) t.type = i.MANIFEST;
                        else if (t.type != i.MANIFEST) {
                            var a = new createjs.Event("error");
                            a.text = "PRELOAD_MANIFEST_ERROR", this._sendError(a)
                        }
                        r = [t]
                    } else void 0 !== t.manifest && (r = t.manifest, o = t.path)
                }
                for (var s = 0, l = r.length; l > s; s++) this._addItem(r[s], o, n);
                !1 !== e ? this.setPaused(!1) : this.setPaused(!0)
            }, e.load = function() {
                this.setPaused(!1)
            }, e.getItem = function(t) {
                return this._loadItemsById[t] || this._loadItemsBySrc[t]
            }, e.getResult = function(t, e) {
                var i = this._loadItemsById[t] || this._loadItemsBySrc[t];
                if (null == i) return null;
                var n = i.id;
                return e && this._loadedRawResults[n] ? this._loadedRawResults[n] : this._loadedResults[n]
            }, e.setPaused = function(t) {
                this._paused = t, this._paused || this._loadNext()
            }, e.close = function() {
                for (; this._currentLoads.length;) this._currentLoads.pop().cancel();
                this._scriptOrder.length = 0, this._loadedScripts.length = 0, this.loadStartWasDispatched = !1
            }, e._addItem = function(t, e, i) {
                var n = this._createLoadItem(t, e, i);
                if (null != n) {
                    var r = this._createLoader(n);
                    null != r && (this._loadQueue.push(r), this._loadQueueBackup.push(r), this._numItems++, this._updateProgress(), this.maintainScriptOrder && n.type == createjs.LoadQueue.JAVASCRIPT && r instanceof createjs.XHRLoader && (this._scriptOrder.push(n), this._loadedScripts.push(null)))
                }
            }, e._createLoadItem = function(t, e, i) {
                var n = null;
                switch (typeof t) {
                    case "string":
                        n = {
                            src: t
                        };
                        break;
                    case "object":
                        n = window.HTMLAudioElement && t instanceof window.HTMLAudioElement ? {
                            tag: t,
                            src: n.tag.src,
                            type: createjs.LoadQueue.SOUND
                        } : t;
                        break;
                    default:
                        return null
                }
                var r = this._parseURI(n.src);
                null != r && (n.ext = r[6]), null == n.type && (n.type = this._getTypeByExtension(n.ext));
                var o = "",
                    a = i || this._basePath,
                    s = n.src;
                if (r && null == r[1] && null == r[3])
                    if (e) {
                        o = e;
                        var l = this._parsePath(e);
                        s = e + s, null != a && l && null == l[1] && null == l[2] && (o = a + o)
                    } else null != a && (o = a);
                if (n.src = o + n.src, n.path = o, (n.type == createjs.LoadQueue.JSON || n.type == createjs.LoadQueue.MANIFEST) && (n._loadAsJSONP = null != n.callback), n.type == createjs.LoadQueue.JSONP && null == n.callback) throw new Error("callback is required for loading JSONP requests.");
                (void 0 === n.tag || null === n.tag) && (n.tag = this._createTag(n)), (void 0 === n.id || null === n.id || "" === n.id) && (n.id = s);
                var c = this._typeCallbacks[n.type] || this._extensionCallbacks[n.ext];
                if (c) {
                    var u = c.callback.call(c.scope, n.src, n.type, n.id, n.data, o, this);
                    if (!1 === u) return null;
                    !0 === u || (null != u.src && (n.src = u.src), null != u.id && (n.id = u.id), null != u.tag && (n.tag = u.tag), null != u.completeHandler && (n.completeHandler = u.completeHandler), u.type && (n.type = u.type), null != (r = this._parseURI(n.src)) && null != r[6] && (n.ext = r[6].toLowerCase()))
                }
                return this._loadItemsById[n.id] = n, this._loadItemsBySrc[n.src] = n, n
            }, e._createLoader = function(t) {
                var e = this.useXHR;
                switch (t.type) {
                    case createjs.LoadQueue.JSON:
                    case createjs.LoadQueue.MANIFEST:
                        e = !t._loadAsJSONP;
                        break;
                    case createjs.LoadQueue.XML:
                    case createjs.LoadQueue.TEXT:
                        e = !0;
                        break;
                    case createjs.LoadQueue.SOUND:
                    case createjs.LoadQueue.JSONP:
                        e = !1;
                        break;
                    case null:
                        return null
                }
                return e ? new createjs.XHRLoader(t, this._crossOrigin) : new createjs.TagLoader(t)
            }, e._loadNext = function() {
                if (!this._paused) {
                    this._loadStartWasDispatched || (this._sendLoadStart(), this._loadStartWasDispatched = !0), this._numItems == this._numItemsLoaded ? (this.loaded = !0, this._sendComplete(), this.next && this.next.load && this.next.load()) : this.loaded = !1;
                    for (var t = 0; t < this._loadQueue.length && !(this._currentLoads.length >= this._maxConnections); t++) {
                        var e = this._loadQueue[t];
                        if (this.maintainScriptOrder && e instanceof createjs.TagLoader && e.getItem().type == createjs.LoadQueue.JAVASCRIPT) {
                            if (this._currentlyLoadingScript) continue;
                            this._currentlyLoadingScript = !0
                        }
                        this._loadQueue.splice(t, 1), t--, this._loadItem(e)
                    }
                }
            }, e._loadItem = function(t) {
                t.on("progress", this._handleProgress, this), t.on("complete", this._handleFileComplete, this), t.on("error", this._handleFileError, this), this._currentLoads.push(t), this._sendFileStart(t.getItem()), t.load()
            }, e._handleFileError = function(t) {
                var e = t.target;
                this._numItemsLoaded++, this._updateProgress();
                var i = new createjs.Event("error");
                i.text = "FILE_LOAD_ERROR", i.item = e.getItem(), this._sendError(i), this.stopOnError || (this._removeLoadItem(e), this._loadNext())
            }, e._handleFileComplete = function(t) {
                var e = t.target,
                    i = e.getItem();
                if (this._loadedResults[i.id] = e.getResult(), e instanceof createjs.XHRLoader && (this._loadedRawResults[i.id] = e.getResult(!0)), this._removeLoadItem(e), this.maintainScriptOrder && i.type == createjs.LoadQueue.JAVASCRIPT) {
                    if (!(e instanceof createjs.TagLoader)) return this._loadedScripts[createjs.indexOf(this._scriptOrder, i)] = i, void this._checkScriptLoadOrder(e);
                    this._currentlyLoadingScript = !1
                }
                if (delete i._loadAsJSONP, i.type == createjs.LoadQueue.MANIFEST) {
                    var n = e.getResult();
                    null != n && void 0 !== n.manifest && this.loadManifest(n, !0)
                }
                this._processFinishedLoad(i, e)
            }, e._processFinishedLoad = function(t, e) {
                this._numItemsLoaded++, this._updateProgress(), this._sendFileComplete(t, e), this._loadNext()
            }, e._checkScriptLoadOrder = function() {
                for (var t = this._loadedScripts.length, e = 0; t > e; e++) {
                    var i = this._loadedScripts[e];
                    if (null === i) break;
                    if (!0 !== i) {
                        var n = this._loadedResults[i.id];
                        (document.body || document.getElementsByTagName("body")[0]).appendChild(n), this._processFinishedLoad(i), this._loadedScripts[e] = !0
                    }
                }
            }, e._removeLoadItem = function(t) {
                for (var e = this._currentLoads.length, i = 0; e > i; i++)
                    if (this._currentLoads[i] == t) {
                        this._currentLoads.splice(i, 1);
                        break
                    }
            }, e._handleProgress = function(t) {
                var e = t.target;
                this._sendFileProgress(e.getItem(), e.progress), this._updateProgress()
            }, e._updateProgress = function() {
                var t = this._numItemsLoaded / this._numItems,
                    e = this._numItems - this._numItemsLoaded;
                if (e > 0) {
                    for (var i = 0, n = 0, r = this._currentLoads.length; r > n; n++) i += this._currentLoads[n].progress;
                    t += i / e * (e / this._numItems)
                }
                this._sendProgress(t)
            }, e._disposeItem = function(t) {
                delete this._loadedResults[t.id], delete this._loadedRawResults[t.id], delete this._loadItemsById[t.id], delete this._loadItemsBySrc[t.src]
            }, e._createTag = function(t) {
                var e = null;
                switch (t.type) {
                    case createjs.LoadQueue.IMAGE:
                        return e = document.createElement("img"), "" == this._crossOrigin || this._isLocal(t) || (e.crossOrigin = this._crossOrigin), e;
                    case createjs.LoadQueue.SOUND:
                        return e = document.createElement("audio"), e.autoplay = !1, e;
                    case createjs.LoadQueue.JSON:
                    case createjs.LoadQueue.JSONP:
                    case createjs.LoadQueue.JAVASCRIPT:
                    case createjs.LoadQueue.MANIFEST:
                        return e = document.createElement("script"), e.type = "text/javascript", e;
                    case createjs.LoadQueue.CSS:
                        return e = this.useXHR ? document.createElement("style") : document.createElement("link"), e.rel = "stylesheet", e.type = "text/css", e;
                    case createjs.LoadQueue.SVG:
                        return this.useXHR ? e = document.createElement("svg") : (e = document.createElement("object"), e.type = "image/svg+xml"), e
                }
                return null
            }, e._getTypeByExtension = function(t) {
                if (null == t) return createjs.LoadQueue.TEXT;
                switch (t.toLowerCase()) {
                    case "jpeg":
                    case "jpg":
                    case "gif":
                    case "png":
                    case "webp":
                    case "bmp":
                        return createjs.LoadQueue.IMAGE;
                    case "ogg":
                    case "mp3":
                    case "wav":
                        return createjs.LoadQueue.SOUND;
                    case "json":
                        return createjs.LoadQueue.JSON;
                    case "xml":
                        return createjs.LoadQueue.XML;
                    case "css":
                        return createjs.LoadQueue.CSS;
                    case "js":
                        return createjs.LoadQueue.JAVASCRIPT;
                    case "svg":
                        return createjs.LoadQueue.SVG;
                    default:
                        return createjs.LoadQueue.TEXT
                }
            }, e._sendFileProgress = function(t, e) {
                if (this._isCanceled()) this._cleanUp();
                else if (this.hasEventListener("fileprogress")) {
                    var i = new createjs.Event("fileprogress");
                    i.progress = e, i.loaded = e, i.total = 1, i.item = t, this.dispatchEvent(i)
                }
            }, e._sendFileComplete = function(t, e) {
                if (!this._isCanceled()) {
                    var i = new createjs.Event("fileload");
                    i.loader = e, i.item = t, i.result = this._loadedResults[t.id], i.rawResult = this._loadedRawResults[t.id], t.completeHandler && t.completeHandler(i), this.hasEventListener("fileload") && this.dispatchEvent(i)
                }
            }, e._sendFileStart = function(t) {
                var e = new createjs.Event("filestart");
                e.item = t, this.hasEventListener("filestart") && this.dispatchEvent(e)
            }, e.toString = function() {
                return "[PreloadJS LoadQueue]"
            }, createjs.LoadQueue = t;
            var n = function() {};
            n.init = function() {
                var t = navigator.userAgent;
                n.isFirefox = t.indexOf("Firefox") > -1, n.isOpera = null != window.opera, n.isChrome = t.indexOf("Chrome") > -1, n.isIOS = t.indexOf("iPod") > -1 || t.indexOf("iPhone") > -1 || t.indexOf("iPad") > -1
            }, n.init(), createjs.LoadQueue.BrowserDetect = n
        }(),
        function() {
            "use strict";
            var t = function(t) {
                    this.init(t)
                },
                e = t.prototype = new createjs.AbstractLoader;
            e._loadTimeout = null, e._tagCompleteProxy = null, e._isAudio = !1, e._tag = null, e._jsonResult = null, e.init = function(t) {
                this._item = t, this._tag = t.tag, this._isAudio = window.HTMLAudioElement && t.tag instanceof window.HTMLAudioElement, this._tagCompleteProxy = createjs.proxy(this._handleLoad, this)
            }, e.getResult = function() {
                return this._item.type == createjs.LoadQueue.JSONP || this._item.type == createjs.LoadQueue.MANIFEST ? this._jsonResult : this._tag
            }, e.cancel = function() {
                this.canceled = !0, this._clean()
            }, e.load = function() {
                var t = this._item,
                    e = this._tag;
                clearTimeout(this._loadTimeout);
                var i = createjs.LoadQueue.LOAD_TIMEOUT;
                0 == i && (i = createjs.LoadQueue.loadTimeout), this._loadTimeout = setTimeout(createjs.proxy(this._handleTimeout, this), i), this._isAudio && (e.src = null, e.preload = "auto"), e.onerror = createjs.proxy(this._handleError, this), this._isAudio ? (e.onstalled = createjs.proxy(this._handleStalled, this), e.addEventListener("canplaythrough", this._tagCompleteProxy, !1)) : (e.onload = createjs.proxy(this._handleLoad, this), e.onreadystatechange = createjs.proxy(this._handleReadyStateChange, this));
                var n = this.buildPath(t.src, t.values);
                switch (t.type) {
                    case createjs.LoadQueue.CSS:
                        e.href = n;
                        break;
                    case createjs.LoadQueue.SVG:
                        e.data = n;
                        break;
                    default:
                        e.src = n
                }
                if (t.type == createjs.LoadQueue.JSONP || t.type == createjs.LoadQueue.JSON || t.type == createjs.LoadQueue.MANIFEST) {
                    if (null == t.callback) throw new Error("callback is required for loading JSONP requests.");
                    if (null != window[t.callback]) throw new Error('JSONP callback "' + t.callback + '" already exists on window. You need to specify a different callback. Or re-name the current one.');
                    window[t.callback] = createjs.proxy(this._handleJSONPLoad, this)
                }(t.type == createjs.LoadQueue.SVG || t.type == createjs.LoadQueue.JSONP || t.type == createjs.LoadQueue.JSON || t.type == createjs.LoadQueue.MANIFEST || t.type == createjs.LoadQueue.JAVASCRIPT || t.type == createjs.LoadQueue.CSS) && (this._startTagVisibility = e.style.visibility, e.style.visibility = "hidden", (document.body || document.getElementsByTagName("body")[0]).appendChild(e)), null != e.load && e.load()
            }, e._handleJSONPLoad = function(t) {
                this._jsonResult = t
            }, e._handleTimeout = function() {
                this._clean();
                var t = new createjs.Event("error");
                t.text = "PRELOAD_TIMEOUT", this._sendError(t)
            }, e._handleStalled = function() {}, e._handleError = function() {
                this._clean();
                var t = new createjs.Event("error");
                this._sendError(t)
            }, e._handleReadyStateChange = function() {
                clearTimeout(this._loadTimeout);
                var t = this.getItem().tag;
                ("loaded" == t.readyState || "complete" == t.readyState) && this._handleLoad()
            }, e._handleLoad = function() {
                if (!this._isCanceled()) {
                    var t = this.getItem(),
                        e = t.tag;
                    if (!(this.loaded || this._isAudio && 4 !== e.readyState)) {
                        switch (this.loaded = !0, t.type) {
                            case createjs.LoadQueue.SVG:
                            case createjs.LoadQueue.JSON:
                            case createjs.LoadQueue.JSONP:
                            case createjs.LoadQueue.MANIFEST:
                            case createjs.LoadQueue.CSS:
                                e.style.visibility = this._startTagVisibility, (document.body || document.getElementsByTagName("body")[0]).removeChild(e)
                        }
                        this._clean(), this._sendComplete()
                    }
                }
            }, e._clean = function() {
                clearTimeout(this._loadTimeout);
                var t = this.getItem(),
                    e = t.tag;
                null != e && (e.onload = null, e.removeEventListener && e.removeEventListener("canplaythrough", this._tagCompleteProxy, !1), e.onstalled = null, e.onprogress = null, e.onerror = null, null != e.parentNode && t.type == createjs.LoadQueue.SVG && t.type == createjs.LoadQueue.JSON && t.type == createjs.LoadQueue.MANIFEST && t.type == createjs.LoadQueue.CSS && t.type == createjs.LoadQueue.JSONP && e.parentNode.removeChild(e)), ((t = this.getItem()).type == createjs.LoadQueue.JSONP || t.type == createjs.LoadQueue.MANIFEST) && (window[t.callback] = null)
            }, e.toString = function() {
                return "[PreloadJS TagLoader]"
            }, createjs.TagLoader = t
        }(),
        function() {
            "use strict";
            var t = function(t, e) {
                    this.init(t, e)
                },
                e = t.prototype = new createjs.AbstractLoader;
            e._request = null, e._loadTimeout = null, e._xhrLevel = 1, e._response = null, e._rawResponse = null, e._crossOrigin = "", e.init = function(t, e) {
                this._item = t, this._crossOrigin = e, this._createXHR(t)
            }, e.getResult = function(t) {
                return t && this._rawResponse ? this._rawResponse : this._response
            }, e.cancel = function() {
                this.canceled = !0, this._clean(), this._request.abort()
            }, e.load = function() {
                if (null != this._request) {
                    if (this._request.onloadstart = createjs.proxy(this._handleLoadStart, this), this._request.onprogress = createjs.proxy(this._handleProgress, this), this._request.onabort = createjs.proxy(this._handleAbort, this), this._request.onerror = createjs.proxy(this._handleError, this), this._request.ontimeout = createjs.proxy(this._handleTimeout, this), 1 == this._xhrLevel) {
                        var t = createjs.LoadQueue.LOAD_TIMEOUT;
                        if (0 == t) t = createjs.LoadQueue.loadTimeout;
                        else try {
                            console.warn("LoadQueue.LOAD_TIMEOUT has been deprecated in favor of LoadQueue.loadTimeout")
                        } catch (t) {}
                        this._loadTimeout = setTimeout(createjs.proxy(this._handleTimeout, this), t)
                    }
                    this._request.onload = createjs.proxy(this._handleLoad, this), this._request.onreadystatechange = createjs.proxy(this._handleReadyStateChange, this);
                    try {
                        this._item.values && this._item.method != createjs.LoadQueue.GET ? this._item.method == createjs.LoadQueue.POST && this._request.send(this._formatQueryString(this._item.values)) : this._request.send()
                    } catch (t) {
                        var e = new createjs.Event("error");
                        e.error = t, this._sendError(e)
                    }
                } else this._handleError()
            }, e.getAllResponseHeaders = function() {
                return this._request.getAllResponseHeaders instanceof Function ? this._request.getAllResponseHeaders() : null
            }, e.getResponseHeader = function(t) {
                return this._request.getResponseHeader instanceof Function ? this._request.getResponseHeader(t) : null
            }, e._handleProgress = function(t) {
                if (t && !(t.loaded > 0 && 0 == t.total)) {
                    var e = new createjs.Event("progress");
                    e.loaded = t.loaded, e.total = t.total, this._sendProgress(e)
                }
            }, e._handleLoadStart = function() {
                clearTimeout(this._loadTimeout), this._sendLoadStart()
            }, e._handleAbort = function() {
                this._clean();
                var t = new createjs.Event("error");
                t.text = "XHR_ABORTED", this._sendError(t)
            }, e._handleError = function() {
                this._clean();
                var t = new createjs.Event("error");
                this._sendError(t)
            }, e._handleReadyStateChange = function() {
                4 == this._request.readyState && this._handleLoad()
            }, e._handleLoad = function() {
                if (!this.loaded) {
                    if (this.loaded = !0, !this._checkError()) return void this._handleError();
                    this._response = this._getResponse(), this._clean(), this._generateTag() && this._sendComplete()
                }
            }, e._handleTimeout = function(t) {
                this._clean(), new createjs.Event("error").text = "PRELOAD_TIMEOUT", this._sendError(t)
            }, e._checkError = function() {
                switch (parseInt(this._request.status)) {
                    case 404:
                    case 0:
                        return !1
                }
                return !0
            }, e._getResponse = function() {
                if (null != this._response) return this._response;
                if (null != this._request.response) return this._request.response;
                try {
                    if (null != this._request.responseText) return this._request.responseText
                } catch (t) {}
                try {
                    if (null != this._request.responseXML) return this._request.responseXML
                } catch (t) {}
                return null
            }, e._createXHR = function(t) {
                var e = this._isCrossDomain(t),
                    i = null;
                if (e && window.XDomainRequest) i = new XDomainRequest;
                else if (window.XMLHttpRequest) i = new XMLHttpRequest;
                else try {
                    i = new ActiveXObject("Msxml2.XMLHTTP.6.0")
                } catch (t) {
                    try {
                        i = new ActiveXObject("Msxml2.XMLHTTP.3.0")
                    } catch (t) {
                        try {
                            i = new ActiveXObject("Msxml2.XMLHTTP")
                        } catch (t) {
                            return !1
                        }
                    }
                }
                createjs.LoadQueue.isText(t.type) && i.overrideMimeType && i.overrideMimeType("text/plain; charset=utf-8"), this._xhrLevel = "string" == typeof i.responseType ? 2 : 1;
                var n = null;
                return n = t.method == createjs.LoadQueue.GET ? this.buildPath(t.src, t.values) : t.src, i.open(t.method || createjs.LoadQueue.GET, n, !0), e && i instanceof XMLHttpRequest && 1 == this._xhrLevel && i.setRequestHeader("Origin", location.origin), t.values && t.method == createjs.LoadQueue.POST && i.setRequestHeader("Content-Type", "application/x-www-form-urlencoded"), createjs.LoadQueue.isBinary(t.type) && (i.responseType = "arraybuffer"), this._request = i, !0
            }, e._clean = function() {
                clearTimeout(this._loadTimeout);
                var t = this._request;
                t.onloadstart = null, t.onprogress = null, t.onabort = null, t.onerror = null, t.onload = null, t.ontimeout = null, t.onloadend = null, t.onreadystatechange = null
            }, e._generateTag = function() {
                var t = this._item.type,
                    e = this._item.tag;
                switch (t) {
                    case createjs.LoadQueue.IMAGE:
                        return e.onload = createjs.proxy(this._handleTagReady, this), "" != this._crossOrigin && (e.crossOrigin = "Anonymous"), e.src = this.buildPath(this._item.src, this._item.values), this._rawResponse = this._response, this._response = e, !1;
                    case createjs.LoadQueue.JAVASCRIPT:
                        return e = document.createElement("script"), e.text = this._response, this._rawResponse = this._response, this._response = e, !0;
                    case createjs.LoadQueue.CSS:
                        if (document.getElementsByTagName("head")[0].appendChild(e), e.styleSheet) e.styleSheet.cssText = this._response;
                        else {
                            var i = document.createTextNode(this._response);
                            e.appendChild(i)
                        }
                        return this._rawResponse = this._response, this._response = e, !0;
                    case createjs.LoadQueue.XML:
                        n = this._parseXML(this._response, "text/xml");
                        return this._rawResponse = this._response, this._response = n, !0;
                    case createjs.LoadQueue.SVG:
                        var n = this._parseXML(this._response, "image/svg+xml");
                        return this._rawResponse = this._response, null != n.documentElement ? (e.appendChild(n.documentElement), this._response = e) : this._response = n, !0;
                    case createjs.LoadQueue.JSON:
                    case createjs.LoadQueue.MANIFEST:
                        var r = {};
                        try {
                            r = JSON.parse(this._response)
                        } catch (t) {
                            r = t
                        }
                        return this._rawResponse = this._response, this._response = r, !0
                }
                return !0
            }, e._parseXML = function(t, e) {
                var i = null;
                try {
                    window.DOMParser ? i = (new DOMParser).parseFromString(t, e) : (i = new ActiveXObject("Microsoft.XMLDOM"), i.async = !1, i.loadXML(t))
                } catch (t) {}
                return i
            }, e._handleTagReady = function() {
                this._sendComplete()
            }, e.toString = function() {
                return "[PreloadJS XHRLoader]"
            }, createjs.XHRLoader = t
        }(), "object" != typeof JSON && (JSON = {}),
        function() {
            "use strict";

            function f(t) {
                return 10 > t ? "0" + t : t
            }

            function quote(t) {
                return escapable.lastIndex = 0, escapable.test(t) ? '"' + t.replace(escapable, function(t) {
                    var e = meta[t];
                    return "string" == typeof e ? e : "\\u" + ("0000" + t.charCodeAt(0).toString(16)).slice(-4)
                }) + '"' : '"' + t + '"'
            }

            function str(t, e) {
                var i, n, r, o, a, s = gap,
                    l = e[t];
                switch (l && "object" == typeof l && "function" == typeof l.toJSON && (l = l.toJSON(t)), "function" == typeof rep && (l = rep.call(e, t, l)), typeof l) {
                    case "string":
                        return quote(l);
                    case "number":
                        return isFinite(l) ? String(l) : "null";
                    case "boolean":
                    case "null":
                        return String(l);
                    case "object":
                        if (!l) return "null";
                        if (gap += indent, a = [], "[object Array]" === Object.prototype.toString.apply(l)) {
                            for (o = l.length, i = 0; o > i; i += 1) a[i] = str(i, l) || "null";
                            return r = 0 === a.length ? "[]" : gap ? "[\n" + gap + a.join(",\n" + gap) + "\n" + s + "]" : "[" + a.join(",") + "]", gap = s, r
                        }
                        if (rep && "object" == typeof rep)
                            for (o = rep.length, i = 0; o > i; i += 1) "string" == typeof rep[i] && (n = rep[i], (r = str(n, l)) && a.push(quote(n) + (gap ? ": " : ":") + r));
                        else
                            for (n in l) Object.prototype.hasOwnProperty.call(l, n) && (r = str(n, l)) && a.push(quote(n) + (gap ? ": " : ":") + r);
                        return r = 0 === a.length ? "{}" : gap ? "{\n" + gap + a.join(",\n" + gap) + "\n" + s + "}" : "{" + a.join(",") + "}", gap = s, r
                }
            }
            "function" != typeof Date.prototype.toJSON && (Date.prototype.toJSON = function() {
                return isFinite(this.valueOf()) ? this.getUTCFullYear() + "-" + f(this.getUTCMonth() + 1) + "-" + f(this.getUTCDate()) + "T" + f(this.getUTCHours()) + ":" + f(this.getUTCMinutes()) + ":" + f(this.getUTCSeconds()) + "Z" : null
            }, String.prototype.toJSON = Number.prototype.toJSON = Boolean.prototype.toJSON = function() {
                return this.valueOf()
            });
            var cx = /[\u0000\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,
                escapable = /[\\\"\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,
                gap, indent, meta = {
                    "\b": "\\b",
                    "\t": "\\t",
                    "\n": "\\n",
                    "\f": "\\f",
                    "\r": "\\r",
                    '"': '\\"',
                    "\\": "\\\\"
                },
                rep;
            "function" != typeof JSON.stringify && (JSON.stringify = function(t, e, i) {
                var n;
                if (gap = "", indent = "", "number" == typeof i)
                    for (n = 0; i > n; n += 1) indent += " ";
                else "string" == typeof i && (indent = i);
                if (rep = e, e && "function" != typeof e && ("object" != typeof e || "number" != typeof e.length)) throw new Error("JSON.stringify");
                return str("", {
                    "": t
                })
            }), "function" != typeof JSON.parse && (JSON.parse = function(text, reviver) {
                function walk(t, e) {
                    var i, n, r = t[e];
                    if (r && "object" == typeof r)
                        for (i in r) Object.prototype.hasOwnProperty.call(r, i) && (n = walk(r, i), void 0 !== n ? r[i] = n : delete r[i]);
                    return reviver.call(t, e, r)
                }
                var j;
                if (text = String(text), cx.lastIndex = 0, cx.test(text) && (text = text.replace(cx, function(t) {
                        return "\\u" + ("0000" + t.charCodeAt(0).toString(16)).slice(-4)
                    })), /^[\],:{}\s]*$/.test(text.replace(/\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g, "@").replace(/"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g, "]").replace(/(?:^|:|,)(?:\s*\[)+/g, ""))) return j = eval("(" + text + ")"), "function" == typeof reviver ? walk({
                    "": j
                }, "") : j;
                throw new SyntaxError("JSON.parse")
            })
        }(), module.exports = window.createjs
}, function(t, e, i) {
    "use strict";

    function n(t, e) {
        if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
    }
    var r = function() {
            function t(t, e) {
                for (var i = 0; i < e.length; i++) {
                    var n = e[i];
                    n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(t, n.key, n)
                }
            }
            return function(e, i, n) {
                return i && t(e.prototype, i), n && t(e, n), e
            }
        }(),
        o = i(8),
        a = (i(4), function() {
            function t(e) {
                var i = this;
                n(this, t), this.$elm = o(e.selector), this.status = "close", this.$elm.bind("click", function(t) {
                    t.preventDefault(), t.stopPropagation(), i.toggleMenu()
                }), o("a:not(.extl)").bind("click", function(t) {
                    t.preventDefault();
                    var e = o(t.currentTarget).attr("href"),
                        n = o(t.currentTarget).attr("target");
                    "#" != e && "_blank" != n && i.goToPage(e)
                })
            }
            return r(t, [{
                key: "toggleMenu",
                value: function() {
                    var t = this;
                    "close" == this.status && (this.status = "animating", this.$elm.addClass("active"), o("#main-nav").show(), TweenLite.to(o("#main-nav"), 1, {
                        y: "0%",
                        ease: Power4.easeOut,
                        onComplete: function() {
                            t.status = "open"
                        }
                    })), "open" == this.status && (this.status = "animating", this.$elm.removeClass("active"), TweenLite.to(o("#main-nav"), 1, {
                        y: "-100%",
                        ease: Power4.easeIn,
                        onComplete: function() {
                            t.status = "close", o("#main-nav").removeAttr("style")
                        }
                    }))
                }
            }, {
                key: "goToPage",
                value: function(t) {
                    "open" == this.status && this.toggleMenu(), o("#preloader").show(), TweenLite.to(o(".plc-vc-cover.left"), 1.2, {
                        x: "0%",
                        ease: Power4.easeInOut,
                        onComplete: function() {
                            document.location.href = t
                        }
                    }), o(".pl-progress-wrap").addClass("shift"), TweenLite.set(o(".pl-progress"), {
                        scaleX: 0
                    }), TweenLite.to(o(".plc-vc-cover.right"), 1.2, {
                        x: "0%",
                        ease: Power4.easeInOut
                    }), TweenLite.to(o(".plc-vc-cover.top"), 1.2, {
                        y: "0%",
                        ease: Power4.easeInOut
                    }), TweenLite.to(o(".plc-vc-cover.bottom"), 1.2, {
                        y: "0%",
                        ease: Power4.easeInOut
                    }), TweenLite.to(o(".pl-progress-wrap"), 1.2, {
                        scaleX: 1,
                        ease: Power4.easeInOut
                    })
                }
            }]), t
        }());
    t.exports = a
}]);